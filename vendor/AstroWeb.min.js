(function () {
/**
 * almond 0.2.5 Copyright (c) 2011-2012, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap,
            foundI, foundStarMap, starI, i, j, part,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                //Convert baseName to array, and lop off the last part,
                //so that . matches that "directory" and not name of the baseName's
                //module. For instance, baseName of "one/two/three", maps to
                //"one/two/three.js", but we want the directory, "one/two" for
                //this normalization.
                baseParts = baseParts.slice(0, baseParts.length - 1);

                name = baseParts.concat(name.split("/"));

                //start trimDots
                for (i = 0; i < name.length; i += 1) {
                    part = name[i];
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            break;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            } else if (name.indexOf('./') === 0) {
                // No baseName, so this is ID is resolved relative
                // to baseUrl, pull off the leading dot.
                name = name.substring(2);
            }
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relName) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i,
            args = [],
            usingExports;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (typeof callback === 'function') {

            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                           hasProp(waiting, depName) ||
                           hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback.apply(defined[name], args);

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                        cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        config = cfg;
        if (config.deps) {
            req(config.deps, config.callback);
        }
        return req;
    };

    define = function (name, deps, callback) {

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());

define("../build/almond", function(){});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define( 'Numeric',[],function() {

/**************************************************************************************************************/

/**
	Declare namespace for Numeric functions.
	TODO : Should be put into GlobWeb
 */
var Numeric = {};

/**************************************************************************************************************/

/**
  Linear interpolation between [a, b], t must be [0, 1]
*/
Numeric.lerp = function(t, a, b)
{
    return a + ((b - a) * t);
}

/**************************************************************************************************************/

/**
  Cosine interpolation between [a, b], t must be [0, 1]
*/
Numeric.coserp = function(t, a, b)
{
	var t2 = (1 - Math.cos(t * Math.PI))/2;
    return a + ((b - a) * t2);
}

/**************************************************************************************************************/

/**
 Cubic interpolation between [a, b], t must be [0, 1]
*/
Numeric.cubicInterpolation = function(t, startPos, startVel, endPos, endVel)
{
	var t2 = t * t;
	var t3 = t2 * t; 
	
	// Evaluate the position
	
	var M00 = 2 * startPos[0] - 2 * endPos[0] + startVel[0] + endVel[0];
	var M10 = 2 * startPos[1] - 2 * endPos[1] + startVel[1] + endVel[1];
	var M20 = 2 * startPos[2] - 2 * endPos[2] + startVel[2] + endVel[2];

	var M01 = -3 * startPos[0] + 3 * endPos[0] - 2 * startVel[0] - endVel[0];
	var M11 = -3 * startPos[1] + 3 * endPos[1] - 2 * startVel[1] - endVel[1];
	var M21 = -3 * startPos[2] + 3 * endPos[2] - 2 * startVel[2] - endVel[2];
	
	var position = vec3.create();
	position[0] = M00 * t3 + M01 * t2 + startVel[0] * t + startPos[0];
	position[1] = M10 * t3 + M11 * t2 + startVel[1] * t + startPos[1];
	position[2] = M20 * t3 + M21 * t2 + startVel[2] * t + startPos[2];
	
	return position;
}

/**************************************************************************************************************/

/**
 Cubic interpolation between [a, b], t must be [0, 1]
*/
Numeric.cubicInterpolationDerivative = function(t, startPos, startVel, endPos, endVel)
{
	var t2 = t * t;
	
	// Evaluates the direction

	var M01 = 6 * startPos[0] - 6 * endPos[0] + 3 * startVel[0] + 3 * endVel[0];
	var M11 = 6 * startPos[1] - 6 * endPos[1] + 3 * startVel[1] + 3 * endVel[1];
	var M21 = 6 * startPos[2] - 6 * endPos[2] + 3 * startVel[2] + 3 * endVel[2];

	var M02 = -6 * startPos[0] + 6 * endPos[0] - 4 * startVel[0] - 2 * endVel[0];
	var M12 = -6 * startPos[1] + 6 * endPos[1] - 4 * startVel[1] - 2 * endVel[1];
	var M22 = -6 * startPos[2] + 6 * endPos[2] - 4 * startVel[2] - 2 * endVel[2];

	var direction = vec3.create();
	direction[0] = M01 * t2 + M02 * t + startVel[0];
	direction[1] = M11 * t2 + M12 * t + startVel[1];
	direction[2] = M21 * t2 + M22 * t + startVel[2];
	
	return direction;
}

/**************************************************************************************************************/

/**
  Map x between [xMin, xMax] to [0, 1]
*/
Numeric.map01 = function(x, xMin, xMax)
{
    return (xMin != xMax) ? (x - xMin) / (xMax - xMin) : 0;
}

/**************************************************************************************************************/

/*
  Map x between [xMin, xMax] to [outMin, outMax]
*/
Numeric.mapLinear = function(x, xMin, xMax, outMin, outMax)
{
    return Numeric.lerp(Numeric.map01(x, xMin, xMax), outMin, outMax);
}

/**************************************************************************************************************/

Numeric.easeInQuad = function(t)
{
    return t*t;
}

/**************************************************************************************************************/

Numeric.easeOutQuad = function(t)
{
    // use 1-(t^2) with input [-1, 0]
    var v = t - 1; // map [0 1] to [-1 0]
    return 1.0-(v*v);
}

/**************************************************************************************************************/

/**
  Remap input t ([0, 1]) to a curve starting slowly
  and accelerating till 0.5 an decelerating till 1
*/
Numeric.easeInOutQuad = function(t)
{
    var out = t;
    if (out < 0.5)
    {
        // use (0.5*t^2) with input [0, 1]
        out = out+out; // map [0 0.5] outo [0 1]
        out = 0.5*(out*out);
    }
    else
    {
        // use (0.5*(1-t)^2) with input [-1, 0]
        out = (out+out) - 2.0; // map [0.5 1] to [-1 0]
        out = 0.5*(1.0-(out*out));
        out = 0.5 + out;
    }
    return out;
}

/**************************************************************************************************************/

/*
 */
Numeric.easeOutInQuad = function(t)
{
    var out = t;
    if (out < 0.5)
    {
        // use (0.5*(1-t)^2) with input [-1, 0]
        out = (out+out) - 1.0; // map [0 0.5] to [-1 0]
        out = 0.5*(1.0-(out*out));
    }
    else
    {
        // use (0.5*t^2) with input [0, 1]
        out = (out+out) - 1.0; // map [0.5 1] outo [0 1]
        out = 0.5*(out*out);
        out = 0.5 + out;
    }
    return out;
}

/**************************************************************************************************************/

/**
  Convert the given degree value in radian
*/
Numeric.toRadian = function(degree)
{
    return degree * Math.PI / 180.0;
}

/**************************************************************************************************************/

/**
  Convert the given radian value in degree
*/
Numeric.toDegree = function(radian)
{
    return radian * 180.0 / Math.PI;
}

/**************************************************************************************************************/

/**
  Line-line intersection
  rayDirection must be normalized.
  Returns t at which intersection occurs or -1 if no intersection.
*/

Numeric.lineIntersection = function( x1, y1, x2, y2, x3, y3, x4, y4 )
{
	var det = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
	if ( det == 0 )
	{
		return [-1,-1];
	}
	
	var ua = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);
	var ub = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);
	
	ua /= det;
	ub /= det;
	
	return [ ua, ub ];
	//return ua > 0.0 && ua < 1.0 && ub > 0.0 && ub < 1.0;
}

/**************************************************************************************************************/

/**
 * 	Round the given number
 * 
 * 	@param num Number to round
 * 	@param dec Number of decimals
 */
Numeric.roundNumber = function (num, dec)
{
	var result = Math.round(num*Math.pow(10,dec))/Math.pow(10,dec);
	return result;
}

/**************************************************************************************************************/

return Numeric;

});


/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define( 'CoordinateSystem',['./Numeric' ], function(Numeric) {
 
var CoordinateSystem = function(options)
{
	this.radius = options && options.hasOwnProperty('radius') ? options.radius : 1.0;
	this.realEarthRadius = options && options.hasOwnProperty('realEarthRadius') ? options.realEarthRadius : 6356752.3142;
	this.heightScale = 1.0 / this.realEarthRadius;
};

/**************************************************************************************************************/

/*
	Convert a geographic position to 3D
 */
CoordinateSystem.prototype.fromGeoTo3D = function(geo, dest)
{
    if (!dest) { dest = new Array(3); }

	var longInRad = Numeric.toRadian(geo[0]);
	var latInRad = Numeric.toRadian(geo[1]);
	var cosLat = Math.cos(latInRad);
	
	// Take height into account
	var height = geo.length > 2 ? this.heightScale * geo[2] : 0;
	var radius = this.radius + height;

    dest[0] = radius * Math.cos(longInRad) * cosLat;
    dest[1] = radius * Math.sin(longInRad) * cosLat;
    dest[2] = radius * Math.sin(latInRad);

    return dest;
};

/**************************************************************************************************************/

/*
	Convert a 3D position to geographic
    Returns 3 values [long, lat, distance from earth surface]
 */
CoordinateSystem.prototype.from3DToGeo = function(position3d, dest)
{
    if (!dest) { dest = new Array(3); }

    var r = Math.sqrt(position3d[0]*position3d[0] +
                      position3d[1]*position3d[1] +
                      position3d[2]*position3d[2]);
    var lon = Math.atan2(position3d[1] / r, position3d[0] / r);
    var lat = Math.asin(position3d[2] / r);

    dest[0] = Numeric.toDegree(lon);
    dest[1] = Numeric.toDegree(lat);
    dest[2] = this.realEarthRadius * (r - this.radius);

    return dest;
};

/**************************************************************************************************************/

/*
	Get local transformation
 */
CoordinateSystem.prototype.getLocalTransform = function(geo, dest)
{
    if (!dest) { dest = mat4.create(); }

	var longitude = geo[0] * Math.PI / 180.0;
	var latitude = geo[1] * Math.PI / 180.0;
	
	var up = [  Math.cos(longitude)*Math.cos(latitude), Math.sin(longitude)*Math.cos(latitude), Math.sin(latitude) ];
	var east = [ -Math.sin(longitude), Math.cos(longitude), 0 ];
	var north = vec3.create();
	vec3.cross( up, east, north );
	
	dest[0] = east[0];
	dest[1] = east[1];
	dest[2] = east[2];
	dest[3] = 0.0;
		
	dest[4] = north[0];
	dest[5] = north[1];
	dest[6] = north[2];
	dest[7] = 0.0;
		
	dest[8] = up[0];
	dest[9] = up[1];
	dest[10] = up[2];
	dest[11] = 0.0;

	dest[12] = 0.0;
	dest[13] = 0.0;
	dest[14] = 0.0;
	dest[15] = 1.0;

	return dest;
};

/**************************************************************************************************************/

/*
	Get local transformation
 */
CoordinateSystem.prototype.getLHVTransform = function(geo, dest)
{
    if (!dest) { dest = mat4.create(); }

	var longitude = geo[0] * Math.PI / 180.0;
	var latitude = geo[1] * Math.PI / 180.0;
	
	var up = [  Math.cos(longitude)*Math.cos(latitude), Math.sin(longitude)*Math.cos(latitude), Math.sin(latitude) ];
	var east = [ -Math.sin(longitude), Math.cos(longitude), 0 ];
	var north = vec3.create();
	vec3.cross( up, east, north );
	
	var pt = this.fromGeoTo3D(geo);
	
	dest[0] = east[0];
	dest[1] = east[1];
	dest[2] = east[2];
	dest[3] = 0.0;
		
	dest[4] = north[0];
	dest[5] = north[1];
	dest[6] = north[2];
	dest[7] = 0.0;
		
	dest[8] = up[0];
	dest[9] = up[1];
	dest[10] = up[2];
	dest[11] = 0.0;

	dest[12] = pt[0];
	dest[13] = pt[1];
	dest[14] = pt[2];
	dest[15] = 1.0;

	return dest;
};

/**************************************************************************************************************/

/*
	Get the side (i.e. X) vector from a local transformation
 */
CoordinateSystem.prototype.getSideVector = function( matrix, v )
{
	v[0] = matrix[0];
	v[1] = matrix[1];
	v[2] = matrix[2];
	
    return v;
};

/**************************************************************************************************************/

/*
	Get the front (i.e. Y) vector from a local transformation
 */
CoordinateSystem.prototype.getFrontVector = function( matrix, v )
{
	v[0] = matrix[4];
	v[1] = matrix[5];
	v[2] = matrix[6];
	
    return v;
};

/**************************************************************************************************************/

/*
	Get the up (i.e. Z) vector from a local transformation
 */
CoordinateSystem.prototype.getUpVector = function( matrix, v )
{
	v[0] = matrix[8];
	v[1] = matrix[9];
	v[2] = matrix[10];
	
    return v;
};

/**************************************************************************************************************/

return CoordinateSystem;

});
/**
 * @fileoverview gl-matrix - High performance matrix and vector operations for WebGL
 * @author Brandon Jones
 * @author Colin MacKenzie IV
 * @version 1.3.7
 */

/*
 * Copyright (c) 2012 Brandon Jones, Colin MacKenzie IV
 *
 * This software is provided 'as-is', without any express or implied
 * warranty. In no event will the authors be held liable for any damages
 * arising from the use of this software.
 *
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 *
 *    1. The origin of this software must not be misrepresented; you must not
 *    claim that you wrote the original software. If you use this software
 *    in a product, an acknowledgment in the product documentation would be
 *    appreciated but is not required.
 *
 *    2. Altered source versions must be plainly marked as such, and must not
 *    be misrepresented as being the original software.
 *
 *    3. This notice may not be removed or altered from any source
 *    distribution.
 */

// Modification to plain glMatrix
//	- Always use Array for MatrixType
//	- Remove export management
//	- Remove vec2, mat2, mat3, vec4
//	- Comments some not needed functions
//	- Add mat4.project and mat4.rotateVec3

define( 'glMatrix',[],function () {

    // Tweak to your liking
    var FLOAT_EPSILON = 0.000001;

    /**
     * @class System-specific optimal array type
     * @name MatrixArray
     */
    var MatrixArray = Array;
    
    /**
     * @class 3 Dimensional Vector
     * @name vec3
     */
    var vec3 = {};
     
    /**
     * Creates a new instance of a vec3 using the default array type
     * Any javascript array-like objects containing at least 3 numeric elements can serve as a vec3
     *
     * @param {vec3} [vec] vec3 containing values to initialize with
     *
     * @returns {vec3} New vec3
     */
    vec3.create = function (vec) {
        var dest = new MatrixArray(3);

        if (vec) {
            dest[0] = vec[0];
            dest[1] = vec[1];
            dest[2] = vec[2];
        } else {
            dest[0] = dest[1] = dest[2] = 0;
        }

        return dest;
    };

    /**
     * Creates a new instance of a vec3, initializing it with the given arguments
     *
     * @param {number} x X value
     * @param {number} y Y value
     * @param {number} z Z value

     * @returns {vec3} New vec3
     */
    vec3.createFrom = function (x, y, z) {
        var dest = new MatrixArray(3);

        dest[0] = x;
        dest[1] = y;
        dest[2] = z;

        return dest;
    };

    /**
     * Copies the values of one vec3 to another
     *
     * @param {vec3} vec vec3 containing values to copy
     * @param {vec3} dest vec3 receiving copied values
     *
     * @returns {vec3} dest
     */
    vec3.set = function (vec, dest) {
        dest[0] = vec[0];
        dest[1] = vec[1];
        dest[2] = vec[2];

        return dest;
    };

    /**
     * Compares two vectors for equality within a certain margin of error
     *
     * @param {vec3} a First vector
     * @param {vec3} b Second vector
     *
     * @returns {Boolean} True if a is equivalent to b
     */
    vec3.equal = function (a, b) {
        return a === b || (
            Math.abs(a[0] - b[0]) < FLOAT_EPSILON &&
            Math.abs(a[1] - b[1]) < FLOAT_EPSILON &&
            Math.abs(a[2] - b[2]) < FLOAT_EPSILON
        );
    };

    /**
     * Performs a vector addition
     *
     * @param {vec3} vec First operand
     * @param {vec3} vec2 Second operand
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.add = function (vec, vec2, dest) {
        if (!dest || vec === dest) {
            vec[0] += vec2[0];
            vec[1] += vec2[1];
            vec[2] += vec2[2];
            return vec;
        }

        dest[0] = vec[0] + vec2[0];
        dest[1] = vec[1] + vec2[1];
        dest[2] = vec[2] + vec2[2];
        return dest;
    };

    /**
     * Performs a vector subtraction
     *
     * @param {vec3} vec First operand
     * @param {vec3} vec2 Second operand
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.subtract = function (vec, vec2, dest) {
        if (!dest || vec === dest) {
            vec[0] -= vec2[0];
            vec[1] -= vec2[1];
            vec[2] -= vec2[2];
            return vec;
        }

        dest[0] = vec[0] - vec2[0];
        dest[1] = vec[1] - vec2[1];
        dest[2] = vec[2] - vec2[2];
        return dest;
    };

    /**
     * Performs a vector multiplication
     *
     * @param {vec3} vec First operand
     * @param {vec3} vec2 Second operand
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.multiply = function (vec, vec2, dest) {
        if (!dest || vec === dest) {
            vec[0] *= vec2[0];
            vec[1] *= vec2[1];
            vec[2] *= vec2[2];
            return vec;
        }

        dest[0] = vec[0] * vec2[0];
        dest[1] = vec[1] * vec2[1];
        dest[2] = vec[2] * vec2[2];
        return dest;
    };

    /**
     * Negates the components of a vec3
     *
     * @param {vec3} vec vec3 to negate
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.negate = function (vec, dest) {
        if (!dest) { dest = vec; }

        dest[0] = -vec[0];
        dest[1] = -vec[1];
        dest[2] = -vec[2];
        return dest;
    };

    /**
     * Multiplies the components of a vec3 by a scalar value
     *
     * @param {vec3} vec vec3 to scale
     * @param {number} val Value to scale by
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.scale = function (vec, val, dest) {
        if (!dest || vec === dest) {
            vec[0] *= val;
            vec[1] *= val;
            vec[2] *= val;
            return vec;
        }

        dest[0] = vec[0] * val;
        dest[1] = vec[1] * val;
        dest[2] = vec[2] * val;
        return dest;
    };

    /**
     * Generates a unit vector of the same direction as the provided vec3
     * If vector length is 0, returns [0, 0, 0]
     *
     * @param {vec3} vec vec3 to normalize
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.normalize = function (vec, dest) {
        if (!dest) { dest = vec; }

        var x = vec[0], y = vec[1], z = vec[2],
            len = Math.sqrt(x * x + y * y + z * z);

        if (!len) {
            dest[0] = 0;
            dest[1] = 0;
            dest[2] = 0;
            return dest;
        } else if (len === 1) {
            dest[0] = x;
            dest[1] = y;
            dest[2] = z;
            return dest;
        }

        len = 1 / len;
        dest[0] = x * len;
        dest[1] = y * len;
        dest[2] = z * len;
        return dest;
    };

    /**
     * Generates the cross product of two vec3s
     *
     * @param {vec3} vec First operand
     * @param {vec3} vec2 Second operand
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.cross = function (vec, vec2, dest) {
        if (!dest) { dest = vec; }

        var x = vec[0], y = vec[1], z = vec[2],
            x2 = vec2[0], y2 = vec2[1], z2 = vec2[2];

        dest[0] = y * z2 - z * y2;
        dest[1] = z * x2 - x * z2;
        dest[2] = x * y2 - y * x2;
        return dest;
    };

    /**
     * Caclulates the length of a vec3
     *
     * @param {vec3} vec vec3 to calculate length of
     *
     * @returns {number} Length of vec
     */
    vec3.length = function (vec) {
        var x = vec[0], y = vec[1], z = vec[2];
        return Math.sqrt(x * x + y * y + z * z);
    };

    /**
     * Caclulates the squared length of a vec3
     *
     * @param {vec3} vec vec3 to calculate squared length of
     *
     * @returns {number} Squared Length of vec
     */
    vec3.squaredLength = function (vec) {
        var x = vec[0], y = vec[1], z = vec[2];
        return x * x + y * y + z * z;
    };

    /**
     * Caclulates the dot product of two vec3s
     *
     * @param {vec3} vec First operand
     * @param {vec3} vec2 Second operand
     *
     * @returns {number} Dot product of vec and vec2
     */
    vec3.dot = function (vec, vec2) {
        return vec[0] * vec2[0] + vec[1] * vec2[1] + vec[2] * vec2[2];
    };

    /**
     * Generates a unit vector pointing from one vector to another
     *
     * @param {vec3} vec Origin vec3
     * @param {vec3} vec2 vec3 to point to
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
/*   vec3.direction = function (vec, vec2, dest) {
        if (!dest) { dest = vec; }

        var x = vec[0] - vec2[0],
            y = vec[1] - vec2[1],
            z = vec[2] - vec2[2],
            len = Math.sqrt(x * x + y * y + z * z);

        if (!len) {
            dest[0] = 0;
            dest[1] = 0;
            dest[2] = 0;
            return dest;
        }

        len = 1 / len;
        dest[0] = x * len;
        dest[1] = y * len;
        dest[2] = z * len;
        return dest;
    };*/

    /**
     * Performs a linear interpolation between two vec3
     *
     * @param {vec3} vec First vector
     * @param {vec3} vec2 Second vector
     * @param {number} lerp Interpolation amount between the two inputs
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.lerp = function (vec, vec2, lerp, dest) {
        if (!dest) { dest = vec; }

        dest[0] = vec[0] + lerp * (vec2[0] - vec[0]);
        dest[1] = vec[1] + lerp * (vec2[1] - vec[1]);
        dest[2] = vec[2] + lerp * (vec2[2] - vec[2]);

        return dest;
    };

    /**
     * Calculates the euclidian distance between two vec3
     *
     * Params:
     * @param {vec3} vec First vector
     * @param {vec3} vec2 Second vector
     *
     * @returns {number} Distance between vec and vec2
     */
    vec3.dist = function (vec, vec2) {
        var x = vec2[0] - vec[0],
            y = vec2[1] - vec[1],
            z = vec2[2] - vec[2];
            
        return Math.sqrt(x*x + y*y + z*z);
    };

    // Pre-allocated to prevent unecessary garbage collection
    //var unprojectMat = null;
    //var unprojectVec = new MatrixArray(4);
    /**
     * Projects the specified vec3 from screen space into object space
     * Based on the <a href="http://webcvs.freedesktop.org/mesa/Mesa/src/glu/mesa/project.c?revision=1.4&view=markup">Mesa gluUnProject implementation</a>
     *
     * @param {vec3} vec Screen-space vector to project
     * @param {mat4} view View matrix
     * @param {mat4} proj Projection matrix
     * @param {vec4} viewport Viewport as given to gl.viewport [x, y, width, height]
     * @param {vec3} [dest] vec3 receiving unprojected result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
 /*   vec3.unproject = function (vec, view, proj, viewport, dest) {
        if (!dest) { dest = vec; }

        if(!unprojectMat) {
            unprojectMat = mat4.create();
        }

        var m = unprojectMat;
        var v = unprojectVec;
        
        v[0] = (vec[0] - viewport[0]) * 2.0 / viewport[2] - 1.0;
        v[1] = (vec[1] - viewport[1]) * 2.0 / viewport[3] - 1.0;
        v[2] = 2.0 * vec[2] - 1.0;
        v[3] = 1.0;
        
        mat4.multiply(proj, view, m);
        if(!mat4.inverse(m)) { return null; }
        
        mat4.multiplyVec4(m, v);
        if(v[3] === 0.0) { return null; }

        dest[0] = v[0] / v[3];
        dest[1] = v[1] / v[3];
        dest[2] = v[2] / v[3];
        
        return dest;
    };*/

/*    var xUnitVec3 = vec3.createFrom(1,0,0);
    var yUnitVec3 = vec3.createFrom(0,1,0);
    var zUnitVec3 = vec3.createFrom(0,0,1);

    var tmpvec3 = vec3.create();*/
    /**
     * Generates a quaternion of rotation between two given normalized vectors
     *
     * @param {vec3} a Normalized source vector
     * @param {vec3} b Normalized target vector
     * @param {quat4} [dest] quat4 receiving operation result.
     *
     * @returns {quat4} dest if specified, a new quat4 otherwise
     */
/*    vec3.rotationTo = function (a, b, dest) {
        if (!dest) { dest = quat4.create(); }
        
        var d = vec3.dot(a, b);
        var axis = tmpvec3;
        if (d >= 1.0) {
            quat4.set(identityQuat4, dest);
        } else if (d < (0.000001 - 1.0)) {
            vec3.cross(xUnitVec3, a, axis);
            if (vec3.length(axis) < 0.000001)
                vec3.cross(yUnitVec3, a, axis);
            if (vec3.length(axis) < 0.000001)
                vec3.cross(zUnitVec3, a, axis);
            vec3.normalize(axis);
            quat4.fromAngleAxis(Math.PI, axis, dest);
        } else {
            var s = Math.sqrt((1.0 + d) * 2.0);
            var sInv = 1.0 / s;
            vec3.cross(a, b, axis);
            dest[0] = axis[0] * sInv;
            dest[1] = axis[1] * sInv;
            dest[2] = axis[2] * sInv;
            dest[3] = s * 0.5;
            quat4.normalize(dest);
        }
        if (dest[3] > 1.0) dest[3] = 1.0;
        else if (dest[3] < -1.0) dest[3] = -1.0;
        return dest;
    };*/

    /**
     * Returns a string representation of a vector
     *
     * @param {vec3} vec Vector to represent as a string
     *
     * @returns {string} String representation of vec
     */
    vec3.str = function (vec) {
        return '[' + vec[0] + ', ' + vec[1] + ', ' + vec[2] + ']';
    };
	
	/**
	 * @class 3x3 Matrix
	 * @name mat3
	 */
    var mat3 = {};
	
	/**
	 * Creates a new isntance of mat3
	 *
     * @param {mat3} [mat] mat3 containing values to initialize with
	 *
	 * @returns {mat3} a new 3x3 matrix
	 */
    mat3.create = function (mat) {
        var dest = new MatrixArray(9);

        if (mat) {
            dest[0] = mat[0];
            dest[1] = mat[1];
            dest[2] = mat[2];
            dest[3] = mat[3];
            dest[4] = mat[4];
            dest[5] = mat[5];
            dest[6] = mat[6];
            dest[7] = mat[7];
            dest[8] = mat[8];
        }

        return dest;
    };

    /**
     * @class 4x4 Matrix
     * @name mat4
     */
    var mat4 = {};

    /**
     * Creates a new instance of a mat4 using the default array type
     * Any javascript array-like object containing at least 16 numeric elements can serve as a mat4
     *
     * @param {mat4} [mat] mat4 containing values to initialize with
     *
     * @returns {mat4} New mat4
     */
    mat4.create = function (mat) {
        var dest = new MatrixArray(16);

        if (mat) {
            dest[0] = mat[0];
            dest[1] = mat[1];
            dest[2] = mat[2];
            dest[3] = mat[3];
            dest[4] = mat[4];
            dest[5] = mat[5];
            dest[6] = mat[6];
            dest[7] = mat[7];
            dest[8] = mat[8];
            dest[9] = mat[9];
            dest[10] = mat[10];
            dest[11] = mat[11];
            dest[12] = mat[12];
            dest[13] = mat[13];
            dest[14] = mat[14];
            dest[15] = mat[15];
        }

        return dest;
    };

    /**
     * Creates a new instance of a mat4, initializing it with the given arguments
     *
     * @param {number} m00
     * @param {number} m01
     * @param {number} m02
     * @param {number} m03
     * @param {number} m10
     * @param {number} m11
     * @param {number} m12
     * @param {number} m13
     * @param {number} m20
     * @param {number} m21
     * @param {number} m22
     * @param {number} m23
     * @param {number} m30
     * @param {number} m31
     * @param {number} m32
     * @param {number} m33

     * @returns {mat4} New mat4
     */
 /*   mat4.createFrom = function (m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
        var dest = new MatrixArray(16);

        dest[0] = m00;
        dest[1] = m01;
        dest[2] = m02;
        dest[3] = m03;
        dest[4] = m10;
        dest[5] = m11;
        dest[6] = m12;
        dest[7] = m13;
        dest[8] = m20;
        dest[9] = m21;
        dest[10] = m22;
        dest[11] = m23;
        dest[12] = m30;
        dest[13] = m31;
        dest[14] = m32;
        dest[15] = m33;

        return dest;
    };*/

    /**
     * Copies the values of one mat4 to another
     *
     * @param {mat4} mat mat4 containing values to copy
     * @param {mat4} dest mat4 receiving copied values
     *
     * @returns {mat4} dest
     */
    mat4.set = function (mat, dest) {
        dest[0] = mat[0];
        dest[1] = mat[1];
        dest[2] = mat[2];
        dest[3] = mat[3];
        dest[4] = mat[4];
        dest[5] = mat[5];
        dest[6] = mat[6];
        dest[7] = mat[7];
        dest[8] = mat[8];
        dest[9] = mat[9];
        dest[10] = mat[10];
        dest[11] = mat[11];
        dest[12] = mat[12];
        dest[13] = mat[13];
        dest[14] = mat[14];
        dest[15] = mat[15];
        return dest;
    };

    /**
     * Compares two matrices for equality within a certain margin of error
     *
     * @param {mat4} a First matrix
     * @param {mat4} b Second matrix
     *
     * @returns {Boolean} True if a is equivalent to b
     */
/*    mat4.equal = function (a, b) {
        return a === b || (
            Math.abs(a[0] - b[0]) < FLOAT_EPSILON &&
            Math.abs(a[1] - b[1]) < FLOAT_EPSILON &&
            Math.abs(a[2] - b[2]) < FLOAT_EPSILON &&
            Math.abs(a[3] - b[3]) < FLOAT_EPSILON &&
            Math.abs(a[4] - b[4]) < FLOAT_EPSILON &&
            Math.abs(a[5] - b[5]) < FLOAT_EPSILON &&
            Math.abs(a[6] - b[6]) < FLOAT_EPSILON &&
            Math.abs(a[7] - b[7]) < FLOAT_EPSILON &&
            Math.abs(a[8] - b[8]) < FLOAT_EPSILON &&
            Math.abs(a[9] - b[9]) < FLOAT_EPSILON &&
            Math.abs(a[10] - b[10]) < FLOAT_EPSILON &&
            Math.abs(a[11] - b[11]) < FLOAT_EPSILON &&
            Math.abs(a[12] - b[12]) < FLOAT_EPSILON &&
            Math.abs(a[13] - b[13]) < FLOAT_EPSILON &&
            Math.abs(a[14] - b[14]) < FLOAT_EPSILON &&
            Math.abs(a[15] - b[15]) < FLOAT_EPSILON
        );
    };*/

    /**
     * Sets a mat4 to an identity matrix
     *
     * @param {mat4} dest mat4 to set
     *
     * @returns {mat4} dest
     */
    mat4.identity = function (dest) {
        if (!dest) { dest = mat4.create(); }
        dest[0] = 1;
        dest[1] = 0;
        dest[2] = 0;
        dest[3] = 0;
        dest[4] = 0;
        dest[5] = 1;
        dest[6] = 0;
        dest[7] = 0;
        dest[8] = 0;
        dest[9] = 0;
        dest[10] = 1;
        dest[11] = 0;
        dest[12] = 0;
        dest[13] = 0;
        dest[14] = 0;
        dest[15] = 1;
        return dest;
    };

    /**
     * Transposes a mat4 (flips the values over the diagonal)
     *
     * @param {mat4} mat mat4 to transpose
     * @param {mat4} [dest] mat4 receiving transposed values. If not specified result is written to mat
     *
     * @param {mat4} dest is specified, mat otherwise
     */
    mat4.transpose = function (mat, dest) {
        // If we are transposing ourselves we can skip a few steps but have to cache some values
        if (!dest || mat === dest) {
            var a01 = mat[1], a02 = mat[2], a03 = mat[3],
                a12 = mat[6], a13 = mat[7],
                a23 = mat[11];

            mat[1] = mat[4];
            mat[2] = mat[8];
            mat[3] = mat[12];
            mat[4] = a01;
            mat[6] = mat[9];
            mat[7] = mat[13];
            mat[8] = a02;
            mat[9] = a12;
            mat[11] = mat[14];
            mat[12] = a03;
            mat[13] = a13;
            mat[14] = a23;
            return mat;
        }

        dest[0] = mat[0];
        dest[1] = mat[4];
        dest[2] = mat[8];
        dest[3] = mat[12];
        dest[4] = mat[1];
        dest[5] = mat[5];
        dest[6] = mat[9];
        dest[7] = mat[13];
        dest[8] = mat[2];
        dest[9] = mat[6];
        dest[10] = mat[10];
        dest[11] = mat[14];
        dest[12] = mat[3];
        dest[13] = mat[7];
        dest[14] = mat[11];
        dest[15] = mat[15];
        return dest;
    };

    /**
     * Calculates the determinant of a mat4
     *
     * @param {mat4} mat mat4 to calculate determinant of
     *
     * @returns {number} determinant of mat
     */
    mat4.determinant = function (mat) {
        // Cache the matrix values (makes for huge speed increases!)
        var a00 = mat[0], a01 = mat[1], a02 = mat[2], a03 = mat[3],
            a10 = mat[4], a11 = mat[5], a12 = mat[6], a13 = mat[7],
            a20 = mat[8], a21 = mat[9], a22 = mat[10], a23 = mat[11],
            a30 = mat[12], a31 = mat[13], a32 = mat[14], a33 = mat[15];

        return (a30 * a21 * a12 * a03 - a20 * a31 * a12 * a03 - a30 * a11 * a22 * a03 + a10 * a31 * a22 * a03 +
                a20 * a11 * a32 * a03 - a10 * a21 * a32 * a03 - a30 * a21 * a02 * a13 + a20 * a31 * a02 * a13 +
                a30 * a01 * a22 * a13 - a00 * a31 * a22 * a13 - a20 * a01 * a32 * a13 + a00 * a21 * a32 * a13 +
                a30 * a11 * a02 * a23 - a10 * a31 * a02 * a23 - a30 * a01 * a12 * a23 + a00 * a31 * a12 * a23 +
                a10 * a01 * a32 * a23 - a00 * a11 * a32 * a23 - a20 * a11 * a02 * a33 + a10 * a21 * a02 * a33 +
                a20 * a01 * a12 * a33 - a00 * a21 * a12 * a33 - a10 * a01 * a22 * a33 + a00 * a11 * a22 * a33);
    };

    /**
     * Calculates the inverse matrix of a mat4
     *
     * @param {mat4} mat mat4 to calculate inverse of
     * @param {mat4} [dest] mat4 receiving inverse matrix. If not specified result is written to mat
     *
     * @param {mat4} dest is specified, mat otherwise, null if matrix cannot be inverted
     */
    mat4.inverse = function (mat, dest) {
        if (!dest) { dest = mat; }

        // Cache the matrix values (makes for huge speed increases!)
        var a00 = mat[0], a01 = mat[1], a02 = mat[2], a03 = mat[3],
            a10 = mat[4], a11 = mat[5], a12 = mat[6], a13 = mat[7],
            a20 = mat[8], a21 = mat[9], a22 = mat[10], a23 = mat[11],
            a30 = mat[12], a31 = mat[13], a32 = mat[14], a33 = mat[15],

            b00 = a00 * a11 - a01 * a10,
            b01 = a00 * a12 - a02 * a10,
            b02 = a00 * a13 - a03 * a10,
            b03 = a01 * a12 - a02 * a11,
            b04 = a01 * a13 - a03 * a11,
            b05 = a02 * a13 - a03 * a12,
            b06 = a20 * a31 - a21 * a30,
            b07 = a20 * a32 - a22 * a30,
            b08 = a20 * a33 - a23 * a30,
            b09 = a21 * a32 - a22 * a31,
            b10 = a21 * a33 - a23 * a31,
            b11 = a22 * a33 - a23 * a32,

            d = (b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06),
            invDet;

            // Calculate the determinant
            if (!d) { return null; }
            invDet = 1 / d;

        dest[0] = (a11 * b11 - a12 * b10 + a13 * b09) * invDet;
        dest[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * invDet;
        dest[2] = (a31 * b05 - a32 * b04 + a33 * b03) * invDet;
        dest[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * invDet;
        dest[4] = (-a10 * b11 + a12 * b08 - a13 * b07) * invDet;
        dest[5] = (a00 * b11 - a02 * b08 + a03 * b07) * invDet;
        dest[6] = (-a30 * b05 + a32 * b02 - a33 * b01) * invDet;
        dest[7] = (a20 * b05 - a22 * b02 + a23 * b01) * invDet;
        dest[8] = (a10 * b10 - a11 * b08 + a13 * b06) * invDet;
        dest[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * invDet;
        dest[10] = (a30 * b04 - a31 * b02 + a33 * b00) * invDet;
        dest[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * invDet;
        dest[12] = (-a10 * b09 + a11 * b07 - a12 * b06) * invDet;
        dest[13] = (a00 * b09 - a01 * b07 + a02 * b06) * invDet;
        dest[14] = (-a30 * b03 + a31 * b01 - a32 * b00) * invDet;
        dest[15] = (a20 * b03 - a21 * b01 + a22 * b00) * invDet;

        return dest;
    };

    /**
     * Copies the upper 3x3 elements of a mat4 into another mat4
     *
     * @param {mat4} mat mat4 containing values to copy
     * @param {mat4} [dest] mat4 receiving copied values
     *
     * @returns {mat4} dest is specified, a new mat4 otherwise
     */
    mat4.toRotationMat = function (mat, dest) {
        if (!dest) { dest = mat4.create(); }

        dest[0] = mat[0];
        dest[1] = mat[1];
        dest[2] = mat[2];
        dest[3] = mat[3];
        dest[4] = mat[4];
        dest[5] = mat[5];
        dest[6] = mat[6];
        dest[7] = mat[7];
        dest[8] = mat[8];
        dest[9] = mat[9];
        dest[10] = mat[10];
        dest[11] = mat[11];
        dest[12] = 0;
        dest[13] = 0;
        dest[14] = 0;
        dest[15] = 1;

        return dest;
    };

    /**
     * Copies the upper 3x3 elements of a mat4 into a mat3
     *
     * @param {mat4} mat mat4 containing values to copy
     * @param {mat3} [dest] mat3 receiving copied values
     *
     * @returns {mat3} dest is specified, a new mat3 otherwise
     */
    mat4.toMat3 = function (mat, dest) {
        if (!dest) { dest = mat3.create(); }

        dest[0] = mat[0];
        dest[1] = mat[1];
        dest[2] = mat[2];
        dest[3] = mat[4];
        dest[4] = mat[5];
        dest[5] = mat[6];
        dest[6] = mat[8];
        dest[7] = mat[9];
        dest[8] = mat[10];

        return dest;
    };

    /**
     * Calculates the inverse of the upper 3x3 elements of a mat4 and copies the result into a mat3
     * The resulting matrix is useful for calculating transformed normals
     *
     * Params:
     * @param {mat4} mat mat4 containing values to invert and copy
     * @param {mat3} [dest] mat3 receiving values
     *
     * @returns {mat3} dest is specified, a new mat3 otherwise, null if the matrix cannot be inverted
     */
 /*   mat4.toInverseMat3 = function (mat, dest) {
        // Cache the matrix values (makes for huge speed increases!)
        var a00 = mat[0], a01 = mat[1], a02 = mat[2],
            a10 = mat[4], a11 = mat[5], a12 = mat[6],
            a20 = mat[8], a21 = mat[9], a22 = mat[10],

            b01 = a22 * a11 - a12 * a21,
            b11 = -a22 * a10 + a12 * a20,
            b21 = a21 * a10 - a11 * a20,

            d = a00 * b01 + a01 * b11 + a02 * b21,
            id;

        if (!d) { return null; }
        id = 1 / d;

        if (!dest) { dest = mat3.create(); }

        dest[0] = b01 * id;
        dest[1] = (-a22 * a01 + a02 * a21) * id;
        dest[2] = (a12 * a01 - a02 * a11) * id;
        dest[3] = b11 * id;
        dest[4] = (a22 * a00 - a02 * a20) * id;
        dest[5] = (-a12 * a00 + a02 * a10) * id;
        dest[6] = b21 * id;
        dest[7] = (-a21 * a00 + a01 * a20) * id;
        dest[8] = (a11 * a00 - a01 * a10) * id;

        return dest;
    };*/

    /**
     * Performs a matrix multiplication
     *
     * @param {mat4} mat First operand
     * @param {mat4} mat2 Second operand
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
     *
     * @returns {mat4} dest if specified, mat otherwise
     */
    mat4.multiply = function (mat, mat2, dest) {
        if (!dest) { dest = mat; }

        // Cache the matrix values (makes for huge speed increases!)
        var a00 = mat[ 0], a01 = mat[ 1], a02 = mat[ 2], a03 = mat[3];
        var a10 = mat[ 4], a11 = mat[ 5], a12 = mat[ 6], a13 = mat[7];
        var a20 = mat[ 8], a21 = mat[ 9], a22 = mat[10], a23 = mat[11];
        var a30 = mat[12], a31 = mat[13], a32 = mat[14], a33 = mat[15];

        // Cache only the current line of the second matrix
        var b0  = mat2[0], b1 = mat2[1], b2 = mat2[2], b3 = mat2[3];  
        dest[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
        dest[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
        dest[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
        dest[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

        b0 = mat2[4];
        b1 = mat2[5];
        b2 = mat2[6];
        b3 = mat2[7];
        dest[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
        dest[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
        dest[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
        dest[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

        b0 = mat2[8];
        b1 = mat2[9];
        b2 = mat2[10];
        b3 = mat2[11];
        dest[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
        dest[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
        dest[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
        dest[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

        b0 = mat2[12];
        b1 = mat2[13];
        b2 = mat2[14];
        b3 = mat2[15];
        dest[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
        dest[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
        dest[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
        dest[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

        return dest;
    };

    /**
     * Transforms a vec3 with the given matrix
     * 4th vector component is implicitly '1'
     *
     * @param {mat4} mat mat4 to transform the vector with
     * @param {vec3} vec vec3 to transform
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    mat4.multiplyVec3 = function (mat, vec, dest) {
        if (!dest) { dest = vec; }

        var x = vec[0], y = vec[1], z = vec[2];

        dest[0] = mat[0] * x + mat[4] * y + mat[8] * z + mat[12];
        dest[1] = mat[1] * x + mat[5] * y + mat[9] * z + mat[13];
        dest[2] = mat[2] * x + mat[6] * y + mat[10] * z + mat[14];

        return dest;
    };

    /**
     * Transforms a vec4 with the given matrix
     *
     * @param {mat4} mat mat4 to transform the vector with
     * @param {vec4} vec vec4 to transform
     * @param {vec4} [dest] vec4 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec4} dest if specified, vec otherwise
     */
    mat4.multiplyVec4 = function (mat, vec, dest) {
        if (!dest) { dest = vec; }

        var x = vec[0], y = vec[1], z = vec[2], w = vec[3];

        dest[0] = mat[0] * x + mat[4] * y + mat[8] * z + mat[12] * w;
        dest[1] = mat[1] * x + mat[5] * y + mat[9] * z + mat[13] * w;
        dest[2] = mat[2] * x + mat[6] * y + mat[10] * z + mat[14] * w;
        dest[3] = mat[3] * x + mat[7] * y + mat[11] * z + mat[15] * w;

        return dest;
    };

	/**
	  Project a vec3
	*/
	mat4.project = function(mat, vec, dest)
	{
		if(!dest) { dest = vec }
		mat4.multiplyVec4( mat, vec, dest );
		var iw = 1.0 / dest[3];
		dest[0] *= iw;
		dest[1] *= iw;
		dest[2] *= iw;
		return dest;
	}

	/**
	 * mat4.rotateVec3
	 * Rotate a vec3 with the given matrix
	 *
	 * Params:
	 * mat - mat4 to transform the vector with
	 * vec - vec3 to transform
	 * dest - Optional, vec3 receiving operation result. If not specified result is written to vec
	 *
	 * Returns:
	 * dest if specified, vec otherwise
	 */
	mat4.rotateVec3 = function(mat, vec, dest) {
		if(!dest) { dest = vec }
		
		var x = vec[0], y = vec[1], z = vec[2];
		
		dest[0] = mat[0]*x + mat[4]*y + mat[8]*z;
		dest[1] = mat[1]*x + mat[5]*y + mat[9]*z;
		dest[2] = mat[2]*x + mat[6]*y + mat[10]*z;
		
		return dest;
	};
	
    /**
     * Translates a matrix by the given vector
     *
     * @param {mat4} mat mat4 to translate
     * @param {vec3} vec vec3 specifying the translation
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
     *
     * @returns {mat4} dest if specified, mat otherwise
     */
    mat4.translate = function (mat, vec, dest) {
        var x = vec[0], y = vec[1], z = vec[2],
            a00, a01, a02, a03,
            a10, a11, a12, a13,
            a20, a21, a22, a23;

        if (!dest || mat === dest) {
            mat[12] = mat[0] * x + mat[4] * y + mat[8] * z + mat[12];
            mat[13] = mat[1] * x + mat[5] * y + mat[9] * z + mat[13];
            mat[14] = mat[2] * x + mat[6] * y + mat[10] * z + mat[14];
            mat[15] = mat[3] * x + mat[7] * y + mat[11] * z + mat[15];
            return mat;
        }

        a00 = mat[0]; a01 = mat[1]; a02 = mat[2]; a03 = mat[3];
        a10 = mat[4]; a11 = mat[5]; a12 = mat[6]; a13 = mat[7];
        a20 = mat[8]; a21 = mat[9]; a22 = mat[10]; a23 = mat[11];

        dest[0] = a00; dest[1] = a01; dest[2] = a02; dest[3] = a03;
        dest[4] = a10; dest[5] = a11; dest[6] = a12; dest[7] = a13;
        dest[8] = a20; dest[9] = a21; dest[10] = a22; dest[11] = a23;

        dest[12] = a00 * x + a10 * y + a20 * z + mat[12];
        dest[13] = a01 * x + a11 * y + a21 * z + mat[13];
        dest[14] = a02 * x + a12 * y + a22 * z + mat[14];
        dest[15] = a03 * x + a13 * y + a23 * z + mat[15];
        return dest;
    };

    /**
     * Scales a matrix by the given vector
     *
     * @param {mat4} mat mat4 to scale
     * @param {vec3} vec vec3 specifying the scale for each axis
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
     *
     * @param {mat4} dest if specified, mat otherwise
     */
    mat4.scale = function (mat, vec, dest) {
        var x = vec[0], y = vec[1], z = vec[2];

        if (!dest || mat === dest) {
            mat[0] *= x;
            mat[1] *= x;
            mat[2] *= x;
            mat[3] *= x;
            mat[4] *= y;
            mat[5] *= y;
            mat[6] *= y;
            mat[7] *= y;
            mat[8] *= z;
            mat[9] *= z;
            mat[10] *= z;
            mat[11] *= z;
            return mat;
        }

        dest[0] = mat[0] * x;
        dest[1] = mat[1] * x;
        dest[2] = mat[2] * x;
        dest[3] = mat[3] * x;
        dest[4] = mat[4] * y;
        dest[5] = mat[5] * y;
        dest[6] = mat[6] * y;
        dest[7] = mat[7] * y;
        dest[8] = mat[8] * z;
        dest[9] = mat[9] * z;
        dest[10] = mat[10] * z;
        dest[11] = mat[11] * z;
        dest[12] = mat[12];
        dest[13] = mat[13];
        dest[14] = mat[14];
        dest[15] = mat[15];
        return dest;
    };

    /**
     * Rotates a matrix by the given angle around the specified axis
     * If rotating around a primary axis (X,Y,Z) one of the specialized rotation functions should be used instead for performance
     *
     * @param {mat4} mat mat4 to rotate
     * @param {number} angle Angle (in radians) to rotate
     * @param {vec3} axis vec3 representing the axis to rotate around
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
     *
     * @returns {mat4} dest if specified, mat otherwise
     */
    mat4.rotate = function (mat, angle, axis, dest) {
        var x = axis[0], y = axis[1], z = axis[2],
            len = Math.sqrt(x * x + y * y + z * z),
            s, c, t,
            a00, a01, a02, a03,
            a10, a11, a12, a13,
            a20, a21, a22, a23,
            b00, b01, b02,
            b10, b11, b12,
            b20, b21, b22;

        if (!len) { return null; }
        if (len !== 1) {
            len = 1 / len;
            x *= len;
            y *= len;
            z *= len;
        }

        s = Math.sin(angle);
        c = Math.cos(angle);
        t = 1 - c;

        a00 = mat[0]; a01 = mat[1]; a02 = mat[2]; a03 = mat[3];
        a10 = mat[4]; a11 = mat[5]; a12 = mat[6]; a13 = mat[7];
        a20 = mat[8]; a21 = mat[9]; a22 = mat[10]; a23 = mat[11];

        // Construct the elements of the rotation matrix
        b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
        b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
        b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

        if (!dest) {
            dest = mat;
        } else if (mat !== dest) { // If the source and destination differ, copy the unchanged last row
            dest[12] = mat[12];
            dest[13] = mat[13];
            dest[14] = mat[14];
            dest[15] = mat[15];
        }

        // Perform rotation-specific matrix multiplication
        dest[0] = a00 * b00 + a10 * b01 + a20 * b02;
        dest[1] = a01 * b00 + a11 * b01 + a21 * b02;
        dest[2] = a02 * b00 + a12 * b01 + a22 * b02;
        dest[3] = a03 * b00 + a13 * b01 + a23 * b02;

        dest[4] = a00 * b10 + a10 * b11 + a20 * b12;
        dest[5] = a01 * b10 + a11 * b11 + a21 * b12;
        dest[6] = a02 * b10 + a12 * b11 + a22 * b12;
        dest[7] = a03 * b10 + a13 * b11 + a23 * b12;

        dest[8] = a00 * b20 + a10 * b21 + a20 * b22;
        dest[9] = a01 * b20 + a11 * b21 + a21 * b22;
        dest[10] = a02 * b20 + a12 * b21 + a22 * b22;
        dest[11] = a03 * b20 + a13 * b21 + a23 * b22;
        return dest;
    };

    /**
     * Rotates a matrix by the given angle around the X axis
     *
     * @param {mat4} mat mat4 to rotate
     * @param {number} angle Angle (in radians) to rotate
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
     *
     * @returns {mat4} dest if specified, mat otherwise
     */
    mat4.rotateX = function (mat, angle, dest) {
        var s = Math.sin(angle),
            c = Math.cos(angle),
            a10 = mat[4],
            a11 = mat[5],
            a12 = mat[6],
            a13 = mat[7],
            a20 = mat[8],
            a21 = mat[9],
            a22 = mat[10],
            a23 = mat[11];

        if (!dest) {
            dest = mat;
        } else if (mat !== dest) { // If the source and destination differ, copy the unchanged rows
            dest[0] = mat[0];
            dest[1] = mat[1];
            dest[2] = mat[2];
            dest[3] = mat[3];

            dest[12] = mat[12];
            dest[13] = mat[13];
            dest[14] = mat[14];
            dest[15] = mat[15];
        }

        // Perform axis-specific matrix multiplication
        dest[4] = a10 * c + a20 * s;
        dest[5] = a11 * c + a21 * s;
        dest[6] = a12 * c + a22 * s;
        dest[7] = a13 * c + a23 * s;

        dest[8] = a10 * -s + a20 * c;
        dest[9] = a11 * -s + a21 * c;
        dest[10] = a12 * -s + a22 * c;
        dest[11] = a13 * -s + a23 * c;
        return dest;
    };

    /**
     * Rotates a matrix by the given angle around the Y axis
     *
     * @param {mat4} mat mat4 to rotate
     * @param {number} angle Angle (in radians) to rotate
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
     *
     * @returns {mat4} dest if specified, mat otherwise
     */
    mat4.rotateY = function (mat, angle, dest) {
        var s = Math.sin(angle),
            c = Math.cos(angle),
            a00 = mat[0],
            a01 = mat[1],
            a02 = mat[2],
            a03 = mat[3],
            a20 = mat[8],
            a21 = mat[9],
            a22 = mat[10],
            a23 = mat[11];

        if (!dest) {
            dest = mat;
        } else if (mat !== dest) { // If the source and destination differ, copy the unchanged rows
            dest[4] = mat[4];
            dest[5] = mat[5];
            dest[6] = mat[6];
            dest[7] = mat[7];

            dest[12] = mat[12];
            dest[13] = mat[13];
            dest[14] = mat[14];
            dest[15] = mat[15];
        }

        // Perform axis-specific matrix multiplication
        dest[0] = a00 * c + a20 * -s;
        dest[1] = a01 * c + a21 * -s;
        dest[2] = a02 * c + a22 * -s;
        dest[3] = a03 * c + a23 * -s;

        dest[8] = a00 * s + a20 * c;
        dest[9] = a01 * s + a21 * c;
        dest[10] = a02 * s + a22 * c;
        dest[11] = a03 * s + a23 * c;
        return dest;
    };

    /**
     * Rotates a matrix by the given angle around the Z axis
     *
     * @param {mat4} mat mat4 to rotate
     * @param {number} angle Angle (in radians) to rotate
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
     *
     * @returns {mat4} dest if specified, mat otherwise
     */
    mat4.rotateZ = function (mat, angle, dest) {
        var s = Math.sin(angle),
            c = Math.cos(angle),
            a00 = mat[0],
            a01 = mat[1],
            a02 = mat[2],
            a03 = mat[3],
            a10 = mat[4],
            a11 = mat[5],
            a12 = mat[6],
            a13 = mat[7];

        if (!dest) {
            dest = mat;
        } else if (mat !== dest) { // If the source and destination differ, copy the unchanged last row
            dest[8] = mat[8];
            dest[9] = mat[9];
            dest[10] = mat[10];
            dest[11] = mat[11];

            dest[12] = mat[12];
            dest[13] = mat[13];
            dest[14] = mat[14];
            dest[15] = mat[15];
        }

        // Perform axis-specific matrix multiplication
        dest[0] = a00 * c + a10 * s;
        dest[1] = a01 * c + a11 * s;
        dest[2] = a02 * c + a12 * s;
        dest[3] = a03 * c + a13 * s;

        dest[4] = a00 * -s + a10 * c;
        dest[5] = a01 * -s + a11 * c;
        dest[6] = a02 * -s + a12 * c;
        dest[7] = a03 * -s + a13 * c;

        return dest;
    };

    /**
     * Generates a frustum matrix with the given bounds
     *
     * @param {number} left Left bound of the frustum
     * @param {number} right Right bound of the frustum
     * @param {number} bottom Bottom bound of the frustum
     * @param {number} top Top bound of the frustum
     * @param {number} near Near bound of the frustum
     * @param {number} far Far bound of the frustum
     * @param {mat4} [dest] mat4 frustum matrix will be written into
     *
     * @returns {mat4} dest if specified, a new mat4 otherwise
     */
    mat4.frustum = function (left, right, bottom, top, near, far, dest) {
        if (!dest) { dest = mat4.create(); }
        var rl = (right - left),
            tb = (top - bottom),
            fn = (far - near);
        dest[0] = (near * 2) / rl;
        dest[1] = 0;
        dest[2] = 0;
        dest[3] = 0;
        dest[4] = 0;
        dest[5] = (near * 2) / tb;
        dest[6] = 0;
        dest[7] = 0;
        dest[8] = (right + left) / rl;
        dest[9] = (top + bottom) / tb;
        dest[10] = -(far + near) / fn;
        dest[11] = -1;
        dest[12] = 0;
        dest[13] = 0;
        dest[14] = -(far * near * 2) / fn;
        dest[15] = 0;
        return dest;
    };

    /**
     * Generates a perspective projection matrix with the given bounds
     *
     * @param {number} fovy Vertical field of view
     * @param {number} aspect Aspect ratio. typically viewport width/height
     * @param {number} near Near bound of the frustum
     * @param {number} far Far bound of the frustum
     * @param {mat4} [dest] mat4 frustum matrix will be written into
     *
     * @returns {mat4} dest if specified, a new mat4 otherwise
     */
    mat4.perspective = function (fovy, aspect, near, far, dest) {
        var top = near * Math.tan(fovy * Math.PI / 360.0),
            right = top * aspect;
        return mat4.frustum(-right, right, -top, top, near, far, dest);
    };

    /**
     * Generates a orthogonal projection matrix with the given bounds
     *
     * @param {number} left Left bound of the frustum
     * @param {number} right Right bound of the frustum
     * @param {number} bottom Bottom bound of the frustum
     * @param {number} top Top bound of the frustum
     * @param {number} near Near bound of the frustum
     * @param {number} far Far bound of the frustum
     * @param {mat4} [dest] mat4 frustum matrix will be written into
     *
     * @returns {mat4} dest if specified, a new mat4 otherwise
     */
    mat4.ortho = function (left, right, bottom, top, near, far, dest) {
        if (!dest) { dest = mat4.create(); }
        var rl = (right - left),
            tb = (top - bottom),
            fn = (far - near);
        dest[0] = 2 / rl;
        dest[1] = 0;
        dest[2] = 0;
        dest[3] = 0;
        dest[4] = 0;
        dest[5] = 2 / tb;
        dest[6] = 0;
        dest[7] = 0;
        dest[8] = 0;
        dest[9] = 0;
        dest[10] = -2 / fn;
        dest[11] = 0;
        dest[12] = -(left + right) / rl;
        dest[13] = -(top + bottom) / tb;
        dest[14] = -(far + near) / fn;
        dest[15] = 1;
        return dest;
    };

    /**
     * Generates a look-at matrix with the given eye position, focal point, and up axis
     *
     * @param {vec3} eye Position of the viewer
     * @param {vec3} center Point the viewer is looking at
     * @param {vec3} up vec3 pointing "up"
     * @param {mat4} [dest] mat4 frustum matrix will be written into
     *
     * @returns {mat4} dest if specified, a new mat4 otherwise
     */
    mat4.lookAt = function (eye, center, up, dest) {
        if (!dest) { dest = mat4.create(); }

        var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
            eyex = eye[0],
            eyey = eye[1],
            eyez = eye[2],
            upx = up[0],
            upy = up[1],
            upz = up[2],
            centerx = center[0],
            centery = center[1],
            centerz = center[2];

        if (eyex === centerx && eyey === centery && eyez === centerz) {
            return mat4.identity(dest);
        }

        //vec3.direction(eye, center, z);
        z0 = eyex - centerx;
        z1 = eyey - centery;
        z2 = eyez - centerz;

        // normalize (no check needed for 0 because of early return)
        len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
        z0 *= len;
        z1 *= len;
        z2 *= len;

        //vec3.normalize(vec3.cross(up, z, x));
        x0 = upy * z2 - upz * z1;
        x1 = upz * z0 - upx * z2;
        x2 = upx * z1 - upy * z0;
        len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
        if (!len) {
            x0 = 0;
            x1 = 0;
            x2 = 0;
        } else {
            len = 1 / len;
            x0 *= len;
            x1 *= len;
            x2 *= len;
        }

        //vec3.normalize(vec3.cross(z, x, y));
        y0 = z1 * x2 - z2 * x1;
        y1 = z2 * x0 - z0 * x2;
        y2 = z0 * x1 - z1 * x0;

        len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
        if (!len) {
            y0 = 0;
            y1 = 0;
            y2 = 0;
        } else {
            len = 1 / len;
            y0 *= len;
            y1 *= len;
            y2 *= len;
        }

        dest[0] = x0;
        dest[1] = y0;
        dest[2] = z0;
        dest[3] = 0;
        dest[4] = x1;
        dest[5] = y1;
        dest[6] = z1;
        dest[7] = 0;
        dest[8] = x2;
        dest[9] = y2;
        dest[10] = z2;
        dest[11] = 0;
        dest[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
        dest[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
        dest[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
        dest[15] = 1;

        return dest;
    };

    /**
     * Creates a matrix from a quaternion rotation and vector translation
     * This is equivalent to (but much faster than):
     *
     *     mat4.identity(dest);
     *     mat4.translate(dest, vec);
     *     var quatMat = mat4.create();
     *     quat4.toMat4(quat, quatMat);
     *     mat4.multiply(dest, quatMat);
     *
     * @param {quat4} quat Rotation quaternion
     * @param {vec3} vec Translation vector
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to a new mat4
     *
     * @returns {mat4} dest if specified, a new mat4 otherwise
     */
/*    mat4.fromRotationTranslation = function (quat, vec, dest) {
        if (!dest) { dest = mat4.create(); }

        // Quaternion math
        var x = quat[0], y = quat[1], z = quat[2], w = quat[3],
            x2 = x + x,
            y2 = y + y,
            z2 = z + z,

            xx = x * x2,
            xy = x * y2,
            xz = x * z2,
            yy = y * y2,
            yz = y * z2,
            zz = z * z2,
            wx = w * x2,
            wy = w * y2,
            wz = w * z2;

        dest[0] = 1 - (yy + zz);
        dest[1] = xy + wz;
        dest[2] = xz - wy;
        dest[3] = 0;
        dest[4] = xy - wz;
        dest[5] = 1 - (xx + zz);
        dest[6] = yz + wx;
        dest[7] = 0;
        dest[8] = xz + wy;
        dest[9] = yz - wx;
        dest[10] = 1 - (xx + yy);
        dest[11] = 0;
        dest[12] = vec[0];
        dest[13] = vec[1];
        dest[14] = vec[2];
        dest[15] = 1;
        
        return dest;
    };*/

    /**
     * Returns a string representation of a mat4
     *
     * @param {mat4} mat mat4 to represent as a string
     *
     * @returns {string} String representation of mat
     */
    mat4.str = function (mat) {
        return '[' + mat[0] + ', ' + mat[1] + ', ' + mat[2] + ', ' + mat[3] +
            ', ' + mat[4] + ', ' + mat[5] + ', ' + mat[6] + ', ' + mat[7] +
            ', ' + mat[8] + ', ' + mat[9] + ', ' + mat[10] + ', ' + mat[11] +
            ', ' + mat[12] + ', ' + mat[13] + ', ' + mat[14] + ', ' + mat[15] + ']';
    };

    /**
     * @class Quaternion
     * @name quat4
     */
    var quat4 = {};

    /**
     * Creates a new instance of a quat4 using the default array type
     * Any javascript array containing at least 4 numeric elements can serve as a quat4
     *
     * @param {quat4} [quat] quat4 containing values to initialize with
     *
     * @returns {quat4} New quat4
     */
    quat4.create = function (quat) {
        var dest = new MatrixArray(4);

        if (quat) {
            dest[0] = quat[0];
            dest[1] = quat[1];
            dest[2] = quat[2];
            dest[3] = quat[3];
        } else {
            dest[0] = dest[1] = dest[2] = dest[3] = 0;
        }

        return dest;
    };

    /**
     * Creates a new instance of a quat4, initializing it with the given arguments
     *
     * @param {number} x X value
     * @param {number} y Y value
     * @param {number} z Z value
     * @param {number} w W value

     * @returns {quat4} New quat4
     */
    quat4.createFrom = function (x, y, z, w) {
        var dest = new MatrixArray(4);

        dest[0] = x;
        dest[1] = y;
        dest[2] = z;
        dest[3] = w;

        return dest;
    };

    /**
     * Copies the values of one quat4 to another
     *
     * @param {quat4} quat quat4 containing values to copy
     * @param {quat4} dest quat4 receiving copied values
     *
     * @returns {quat4} dest
     */
    quat4.set = function (quat, dest) {
        dest[0] = quat[0];
        dest[1] = quat[1];
        dest[2] = quat[2];
        dest[3] = quat[3];

        return dest;
    };

    /**
     * Compares two quaternions for equality within a certain margin of error
     *
     * @param {quat4} a First vector
     * @param {quat4} b Second vector
     *
     * @returns {Boolean} True if a is equivalent to b
     */
    quat4.equal = function (a, b) {
        return a === b || (
            Math.abs(a[0] - b[0]) < FLOAT_EPSILON &&
            Math.abs(a[1] - b[1]) < FLOAT_EPSILON &&
            Math.abs(a[2] - b[2]) < FLOAT_EPSILON &&
            Math.abs(a[3] - b[3]) < FLOAT_EPSILON
        );
    };

    /**
     * Creates a new identity Quat4
     *
     * @param {quat4} [dest] quat4 receiving copied values
     *
     * @returns {quat4} dest is specified, new quat4 otherwise
     */
    quat4.identity = function (dest) {
        if (!dest) { dest = quat4.create(); }
        dest[0] = 0;
        dest[1] = 0;
        dest[2] = 0;
        dest[3] = 1;
        return dest;
    };

    //var identityQuat4 = quat4.identity();

    /**
     * Calculates the W component of a quat4 from the X, Y, and Z components.
     * Assumes that quaternion is 1 unit in length.
     * Any existing W component will be ignored.
     *
     * @param {quat4} quat quat4 to calculate W component of
     * @param {quat4} [dest] quat4 receiving calculated values. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.calculateW = function (quat, dest) {
        var x = quat[0], y = quat[1], z = quat[2];

        if (!dest || quat === dest) {
            quat[3] = -Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
            return quat;
        }
        dest[0] = x;
        dest[1] = y;
        dest[2] = z;
        dest[3] = -Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
        return dest;
    };

    /**
     * Calculates the dot product of two quaternions
     *
     * @param {quat4} quat First operand
     * @param {quat4} quat2 Second operand
     *
     * @return {number} Dot product of quat and quat2
     */
    quat4.dot = function(quat, quat2){
        return quat[0]*quat2[0] + quat[1]*quat2[1] + quat[2]*quat2[2] + quat[3]*quat2[3];
    };

    /**
     * Calculates the inverse of a quat4
     *
     * @param {quat4} quat quat4 to calculate inverse of
     * @param {quat4} [dest] quat4 receiving inverse values. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.inverse = function(quat, dest) {
        var q0 = quat[0], q1 = quat[1], q2 = quat[2], q3 = quat[3],
            dot = q0*q0 + q1*q1 + q2*q2 + q3*q3,
            invDot = dot ? 1.0/dot : 0;
        
        // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0
        
        if(!dest || quat === dest) {
            quat[0] *= -invDot;
            quat[1] *= -invDot;
            quat[2] *= -invDot;
            quat[3] *= invDot;
            return quat;
        }
        dest[0] = -quat[0]*invDot;
        dest[1] = -quat[1]*invDot;
        dest[2] = -quat[2]*invDot;
        dest[3] = quat[3]*invDot;
        return dest;
    };


    /**
     * Calculates the conjugate of a quat4
     * If the quaternion is normalized, this function is faster than quat4.inverse and produces the same result.
     *
     * @param {quat4} quat quat4 to calculate conjugate of
     * @param {quat4} [dest] quat4 receiving conjugate values. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.conjugate = function (quat, dest) {
        if (!dest || quat === dest) {
            quat[0] *= -1;
            quat[1] *= -1;
            quat[2] *= -1;
            return quat;
        }
        dest[0] = -quat[0];
        dest[1] = -quat[1];
        dest[2] = -quat[2];
        dest[3] = quat[3];
        return dest;
    };

    /**
     * Calculates the length of a quat4
     *
     * Params:
     * @param {quat4} quat quat4 to calculate length of
     *
     * @returns Length of quat
     */
    quat4.length = function (quat) {
        var x = quat[0], y = quat[1], z = quat[2], w = quat[3];
        return Math.sqrt(x * x + y * y + z * z + w * w);
    };

    /**
     * Generates a unit quaternion of the same direction as the provided quat4
     * If quaternion length is 0, returns [0, 0, 0, 0]
     *
     * @param {quat4} quat quat4 to normalize
     * @param {quat4} [dest] quat4 receiving operation result. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.normalize = function (quat, dest) {
        if (!dest) { dest = quat; }

        var x = quat[0], y = quat[1], z = quat[2], w = quat[3],
            len = Math.sqrt(x * x + y * y + z * z + w * w);
        if (len === 0) {
            dest[0] = 0;
            dest[1] = 0;
            dest[2] = 0;
            dest[3] = 0;
            return dest;
        }
        len = 1 / len;
        dest[0] = x * len;
        dest[1] = y * len;
        dest[2] = z * len;
        dest[3] = w * len;

        return dest;
    };

    /**
     * Performs quaternion addition
     *
     * @param {quat4} quat First operand
     * @param {quat4} quat2 Second operand
     * @param {quat4} [dest] quat4 receiving operation result. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.add = function (quat, quat2, dest) {
        if(!dest || quat === dest) {
            quat[0] += quat2[0];
            quat[1] += quat2[1];
            quat[2] += quat2[2];
            quat[3] += quat2[3];
            return quat;
        }
        dest[0] = quat[0]+quat2[0];
        dest[1] = quat[1]+quat2[1];
        dest[2] = quat[2]+quat2[2];
        dest[3] = quat[3]+quat2[3];
        return dest;
    };

    /**
     * Performs a quaternion multiplication
     *
     * @param {quat4} quat First operand
     * @param {quat4} quat2 Second operand
     * @param {quat4} [dest] quat4 receiving operation result. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.multiply = function (quat, quat2, dest) {
        if (!dest) { dest = quat; }

        var qax = quat[0], qay = quat[1], qaz = quat[2], qaw = quat[3],
            qbx = quat2[0], qby = quat2[1], qbz = quat2[2], qbw = quat2[3];

        dest[0] = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
        dest[1] = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
        dest[2] = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
        dest[3] = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

        return dest;
    };

    /**
     * Transforms a vec3 with the given quaternion
     *
     * @param {quat4} quat quat4 to transform the vector with
     * @param {vec3} vec vec3 to transform
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns dest if specified, vec otherwise
     */
    quat4.multiplyVec3 = function (quat, vec, dest) {
        if (!dest) { dest = vec; }

        var x = vec[0], y = vec[1], z = vec[2],
            qx = quat[0], qy = quat[1], qz = quat[2], qw = quat[3],

            // calculate quat * vec
            ix = qw * x + qy * z - qz * y,
            iy = qw * y + qz * x - qx * z,
            iz = qw * z + qx * y - qy * x,
            iw = -qx * x - qy * y - qz * z;

        // calculate result * inverse quat
        dest[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
        dest[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
        dest[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;

        return dest;
    };

    /**
     * Multiplies the components of a quaternion by a scalar value
     *
     * @param {quat4} quat to scale
     * @param {number} val Value to scale by
     * @param {quat4} [dest] quat4 receiving operation result. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.scale = function (quat, val, dest) {
        if(!dest || quat === dest) {
            quat[0] *= val;
            quat[1] *= val;
            quat[2] *= val;
            quat[3] *= val;
            return quat;
        }
        dest[0] = quat[0]*val;
        dest[1] = quat[1]*val;
        dest[2] = quat[2]*val;
        dest[3] = quat[3]*val;
        return dest;
    };

    /**
     * Calculates a 4x4 matrix from the given quat4
     *
     * @param {quat4} quat quat4 to create matrix from
     * @param {mat4} [dest] mat4 receiving operation result
     *
     * @returns {mat4} dest if specified, a new mat4 otherwise
     */
    quat4.toMat4 = function (quat, dest) {
        if (!dest) { dest = mat4.create(); }

        var x = quat[0], y = quat[1], z = quat[2], w = quat[3],
            x2 = x + x,
            y2 = y + y,
            z2 = z + z,

            xx = x * x2,
            xy = x * y2,
            xz = x * z2,
            yy = y * y2,
            yz = y * z2,
            zz = z * z2,
            wx = w * x2,
            wy = w * y2,
            wz = w * z2;

        dest[0] = 1 - (yy + zz);
        dest[1] = xy + wz;
        dest[2] = xz - wy;
        dest[3] = 0;

        dest[4] = xy - wz;
        dest[5] = 1 - (xx + zz);
        dest[6] = yz + wx;
        dest[7] = 0;

        dest[8] = xz + wy;
        dest[9] = yz - wx;
        dest[10] = 1 - (xx + yy);
        dest[11] = 0;

        dest[12] = 0;
        dest[13] = 0;
        dest[14] = 0;
        dest[15] = 1;

        return dest;
    };

    /**
     * Performs a spherical linear interpolation between two quat4
     *
     * @param {quat4} quat First quaternion
     * @param {quat4} quat2 Second quaternion
     * @param {number} slerp Interpolation amount between the two inputs
     * @param {quat4} [dest] quat4 receiving operation result. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.slerp = function (quat, quat2, slerp, dest) {
        if (!dest) { dest = quat; }

        var cosHalfTheta = quat[0] * quat2[0] + quat[1] * quat2[1] + quat[2] * quat2[2] + quat[3] * quat2[3],
            halfTheta,
            sinHalfTheta,
            ratioA,
            ratioB;

        if (Math.abs(cosHalfTheta) >= 1.0) {
            if (dest !== quat) {
                dest[0] = quat[0];
                dest[1] = quat[1];
                dest[2] = quat[2];
                dest[3] = quat[3];
            }
            return dest;
        }

        halfTheta = Math.acos(cosHalfTheta);
        sinHalfTheta = Math.sqrt(1.0 - cosHalfTheta * cosHalfTheta);

        if (Math.abs(sinHalfTheta) < 0.001) {
            dest[0] = (quat[0] * 0.5 + quat2[0] * 0.5);
            dest[1] = (quat[1] * 0.5 + quat2[1] * 0.5);
            dest[2] = (quat[2] * 0.5 + quat2[2] * 0.5);
            dest[3] = (quat[3] * 0.5 + quat2[3] * 0.5);
            return dest;
        }

        ratioA = Math.sin((1 - slerp) * halfTheta) / sinHalfTheta;
        ratioB = Math.sin(slerp * halfTheta) / sinHalfTheta;

        dest[0] = (quat[0] * ratioA + quat2[0] * ratioB);
        dest[1] = (quat[1] * ratioA + quat2[1] * ratioB);
        dest[2] = (quat[2] * ratioA + quat2[2] * ratioB);
        dest[3] = (quat[3] * ratioA + quat2[3] * ratioB);

        return dest;
    };

    /**
     * Creates a quaternion from the given 3x3 rotation matrix.
     * If dest is omitted, a new quaternion will be created.
     *
     * @param {mat3}  mat    the rotation matrix
     * @param {quat4} [dest] an optional receiving quaternion
     *
     * @returns {quat4} the quaternion constructed from the rotation matrix
     *
     */
    quat4.fromRotationMatrix = function(mat, dest) {
        if (!dest) dest = quat4.create();
        
        // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
        // article "Quaternion Calculus and Fast Animation".

        var fTrace = mat[0] + mat[4] + mat[8];
        var fRoot;

        if ( fTrace > 0.0 ) {
            // |w| > 1/2, may as well choose w > 1/2
            fRoot = Math.sqrt(fTrace + 1.0);  // 2w
            dest[3] = 0.5 * fRoot;
            fRoot = 0.5/fRoot;  // 1/(4w)
            dest[0] = (mat[7]-mat[5])*fRoot;
            dest[1] = (mat[2]-mat[6])*fRoot;
            dest[2] = (mat[3]-mat[1])*fRoot;
        } else {
            // |w| <= 1/2
            var s_iNext = quat4.fromRotationMatrix.s_iNext = quat4.fromRotationMatrix.s_iNext || [1,2,0];
            var i = 0;
            if ( mat[4] > mat[0] )
              i = 1;
            if ( mat[8] > mat[i*3+i] )
              i = 2;
            var j = s_iNext[i];
            var k = s_iNext[j];
            
            fRoot = Math.sqrt(mat[i*3+i]-mat[j*3+j]-mat[k*3+k] + 1.0);
            dest[i] = 0.5 * fRoot;
            fRoot = 0.5 / fRoot;
            dest[3] = (mat[k*3+j] - mat[j*3+k]) * fRoot;
            dest[j] = (mat[j*3+i] + mat[i*3+j]) * fRoot;
            dest[k] = (mat[k*3+i] + mat[i*3+k]) * fRoot;
        }
        
        return dest;
    };

 
    /**
     * Sets a quat4 to the Identity and returns it.
     *
     * @param {quat4} [dest] quat4 to set. If omitted, a
     * new quat4 will be created.
     *
     * @returns {quat4} dest
     */
    quat4.identity = function(dest) {
        if (!dest) dest = quat4.create();
        dest[0] = 0;
        dest[1] = 0;
        dest[2] = 0;
        dest[3] = 1;
        return dest;
    };

    /**
     * Sets a quat4 from the given angle and rotation axis,
     * then returns it. If dest is not given, a new quat4 is created.
     *
     * @param {Number} angle  the angle in radians
     * @param {vec3}   axis   the axis around which to rotate
     * @param {quat4}  [dest] the optional quat4 to store the result
     *
     * @returns {quat4} dest
     **/
    quat4.fromAngleAxis = function(angle, axis, dest) {
        // The quaternion representing the rotation is
        //   q = cos(A/2)+sin(A/2)*(x*i+y*j+z*k)
        if (!dest) dest = quat4.create();
        
        var half = angle * 0.5;
        var s = Math.sin(half);
        dest[3] = Math.cos(half);
        dest[0] = s * axis[0];
        dest[1] = s * axis[1];
        dest[2] = s * axis[2];
        
        return dest;
    };

    /**
     * Stores the angle and axis in a vec4, where the XYZ components represent
     * the axis and the W (4th) component is the angle in radians.
     *
     * If dest is not given, src will be modified in place and returned, after
     * which it should not be considered not a quaternion (just an axis and angle).
     *
     * @param {quat4} quat   the quaternion whose angle and axis to store
     * @param {vec4}  [dest] the optional vec4 to receive the data
     *
     * @returns {vec4} dest
     */
    quat4.toAngleAxis = function(src, dest) {
        if (!dest) dest = src;
        // The quaternion representing the rotation is
        //   q = cos(A/2)+sin(A/2)*(x*i+y*j+z*k)

        var sqrlen = src[0]*src[0]+src[1]*src[1]+src[2]*src[2];
        if (sqrlen > 0)
        {
            dest[3] = 2 * Math.acos(src[3]);
            var invlen = 1.0 / Math.sqrt(sqrlen);
            dest[0] = src[0]*invlen;
            dest[1] = src[1]*invlen;
            dest[2] = src[2]*invlen;
        } else {
            // angle is 0 (mod 2*pi), so any axis will do
            dest[3] = 0;
            dest[0] = 1;
            dest[1] = 0;
            dest[2] = 0;
        }
        
        return dest;
    };

    /**
     * Returns a string representation of a quaternion
     *
     * @param {quat4} quat quat4 to represent as a string
     *
     * @returns {string} String representation of quat
     */
    quat4.str = function (quat) {
        return '[' + quat[0] + ', ' + quat[1] + ', ' + quat[2] + ', ' + quat[3] + ']';
    };
   

    /*
     * Exports
     */

	window.vec3 = vec3;
	window.mat4 = mat4;
	window.quat4 = quat4;
	
	return mat4;

});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define( 'Frustum',['./glMatrix'], function() {

/**************************************************************************************************************/

/** @constructor
	Plane constructor
 */
var Plane = function()
{
	this.normal = vec3.create( [0.0, 0.0, 0.0] );
	this.d = 0.0;
}

/**************************************************************************************************************/

/**
	Plane init from 3 points
 */
Plane.prototype.init = function( v1, v2, v3 )
{
	var vu = [];
	var vv = [];
	vec3.subtract( v2, v1, vu );
	vec3.subtract( v3, v1, vv );
	vec3.cross( vu, vv, this.normal );
	vec3.normalize( this.normal );
	this.d = - vec3.dot( v1, this.normal );
}


/**************************************************************************************************************/

/**
	Transform the plane with the given matrix
 */
Plane.prototype.transform = function(matrix)
{
	var vec = [ this.normal[0], this.normal[1], this.normal[2], this.d ];
	mat4.multiplyVec4(matrix,vec);
	this.normal[0] = vec[0];
	this.normal[1] = vec[1];
	this.normal[2] = vec[2];
	this.d = vec[3];
}

/**************************************************************************************************************/

/**
 Intersection test between plane and bounding sphere.
           return 1 if the bs is completely above plane,
            return 0 if the bs intersects the plane,
            return -1 if the bs is completely below the plane.
*/
Plane.prototype.intersectSphere = function( center, radius )
{
	var dist = vec3.dot( center, this.normal ) + this.d;
	if 	(dist > radius) return 1;
	else if ( dist < - radius ) return -1;
	else return 0;
}

/**************************************************************************************************************/

/**
	Return the distance between a point and the plane
*/
Plane.prototype.distance = function( point )
{
	return point[0] * this.normal[0] + point[1] * this.normal[1] + point[2] * this.normal[2] +  this.d
}


/**************************************************************************************************************/

/**
 Intersection test between plane and bounding box.
           return 1 if the bbox is completely above plane,
            return 0 if the bbox intersects the plane,
            return -1 if the bbox is completely below the plane.
*/
Plane.prototype.intersectBoundingBox = function( bbox )
{
	var upperBBCorner = (this.normal[0]>=0.0?1:0) |
                             (this.normal[1]>=0.0?2:0) |
                             (this.normal[2]>=0.0?4:0);
							 
	var lowerBBCorner = (~upperBBCorner)&7;

	// if lowest point above plane than all above.
	if ( this.distance(bbox.getCorner(lowerBBCorner)) > 0.0) return 1;

	// if highest point is below plane then all below.
	if ( this.distance(bbox.getCorner(upperBBCorner)) < 0.0) return -1;

	// d_lower<=0.0f && d_upper>=0.0f
	// therefore must be crossing plane.
	return 0;
}

/**************************************************************************************************************/

/** @constructor
	Frustum constructor
 */
var Frustum = function()
{
	// The frustum does not contains near and far plane, because near and far are computed during rendering.
	// Some tests have been done with a near plane but are not really useful
	this.planes = [ new Plane(), new Plane(), new Plane(), new Plane(), new Plane() ];
	//this.planes = [ new Plane(), new Plane(), new Plane(), new Plane() ];
}

/**************************************************************************************************************/

/**
	Compute the frustum from the given projection matrix
 */
Frustum.prototype.compute = function(projectionMatrix)
{
	var inverseProjectionMatrix = mat4.create();
	mat4.inverse( projectionMatrix, inverseProjectionMatrix )
	
	var bottomleft = mat4.project( inverseProjectionMatrix, [-1.0,-1.0,-1.0,1.0] );
	var topleft = mat4.project( inverseProjectionMatrix, [-1.0,1.0,-1.0,1.0] );
	var topright = mat4.project( inverseProjectionMatrix, [1.0,1.0,-1.0,1.0] );
	var bottomright = mat4.project( inverseProjectionMatrix, [1.0,-1.0,-1.0,1.0] );
	
	this.planes[0].init( [0.0,0.0,0.0], bottomleft, topleft );
	this.planes[1].init( [0.0,0.0,0.0], topleft, topright );
	this.planes[2].init( [0.0,0.0,0.0], topright, bottomright );
	this.planes[3].init( [0.0,0.0,0.0], bottomright, bottomleft );
	
	// A plane for near plane if needed
	this.planes[4].init( bottomleft, topleft, topright );
}

/**************************************************************************************************************/

/**
	Transform the frustum with the given matrix
 */
Frustum.prototype.transform = function(frustum,matrix)
{
	var mat = mat4.create();
	mat4.inverse(matrix,mat);
	this.inverseTransform(frustum,mat);
}

/**************************************************************************************************************/

/**
	Inverse transform the frustum with the given matrix
 */
Frustum.prototype.inverseTransform = function(frustum,matrix)
{
	// Optimized implementation
	for ( var i = 0; i < frustum.planes.length; i++ )
	{
		var plane = frustum.planes[i];
		
		var x = plane.normal[0];
		var y = plane.normal[1];
		var z = plane.normal[2];
		var w = plane.d;

		plane = this.planes[i];
		
		plane.normal[0] = matrix[0]*x + matrix[1]*y + matrix[2]*z + matrix[3]*w;
		plane.normal[1] = matrix[4]*x + matrix[5]*y + matrix[6]*z + matrix[7]*w;
		plane.normal[2] = matrix[8]*x + matrix[9]*y + matrix[10]*z + matrix[11]*w;
		plane.d = matrix[12]*x + matrix[13]*y + matrix[14]*z + matrix[15]*w;
	}
}

/**************************************************************************************************************/

/**
	Intersection test between frustum and bounding sphere.
	   return 1 if the bs is completely inside the frustum,
		return 0 if the bs intersects the frustum,
		return -1 if the bs is completely outside the frustum.
 */
Frustum.prototype.containsSphere = function( center, radius )
{
	var flag = 1;
	
	for (var i = 0; i < this.planes.length; i++)
	{
		var pn = this.planes[i].normal;
		
		// Compute distance between center and plane (inline to be more efficient)
		var dist = center[0]*pn[0] + center[1]*pn[1] + center[2]*pn[2] + this.planes[i].d;
		
		if 	(dist <= radius)
		{
			if ( dist < - radius ) 
				return -1;
			else 
				flag = 0;
		}	
	}
	
	return flag;
}

/**************************************************************************************************************/

/**
	Test if the frustum contains the given bounding box
 */
Frustum.prototype.containsBoundingBox = function( bbox )
{
	// Optimized implementation
	for (var i = 0; i < this.planes.length; i++)
	{
		var plane = this.planes[i];
		
		// Get the closest point on the bbox
		var bbx = plane.normal[0]>=0.0 ? bbox.max[0] : bbox.min[0];
		var bby = plane.normal[1]>=0.0 ? bbox.max[1] : bbox.min[1];
		var bbz = plane.normal[2]>=0.0 ? bbox.max[2] : bbox.min[2];
		
		// Compute the distance
		var distance = bbx * plane.normal[0] + bby * plane.normal[1] + bbz * plane.normal[2] +  plane.d

		// if highest point is below plane then all below.
		if ( distance < 0.0) return false;
	}
	
/*	for (var i = 0; i < 4; i++)
	{
		if ( this.planes[i].intersectBoundingBox( bbox ) < 0 )
		{
			return false;
		}
	}*/
	
	return true;
}

/**************************************************************************************************************/

// Export plane
Frustum.Plane = Plane;

return Frustum;

});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/
 
define('RenderContext',[ './Frustum', './glMatrix' ], 
	function( Frustum ) {

/**************************************************************************************************************/

/** 
	@constructor
	Function constructor for RencerContext
*/
var RenderContext = function(options)
{
	/**
	 * Private properties
	 */
	 
	/**
	 * Private method
	 */

	
	/**
	 * Constructor
	 */
	this.activeAnimations = [];
	this.shadersPath = options['shadersPath'] || "../shaders/";
	this.tileErrorTreshold = options['tileErrorTreshold'] || 4;
	this.lighting = options['lighting'] || false;
	this.continuousRendering = options['continuousRendering'] || false;
	this.stats = null;
	this.isActive = true;

	// Init GL
	var canvas = null;
	
	// Check canvas options
	if (!options['canvas'])
		throw "GlobWeb : no canvas in options";
	

	if (typeof options['canvas'] == "string") 
	{
		canvas = document.getElementById(options['canvas']);
	}
	else
	{
		canvas = options['canvas'];
	}
	
	// Check canvas is valid
	if (!canvas instanceof HTMLCanvasElement)
		throw "GlobWeb : invalid canvas";
		
	// Create the webl context
	var names = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"];
	var gl = null;
	for (var ii = 0; ii < names.length && gl == null; ++ii) 
	{
		try 
		{
		  gl = canvas.getContext(names[ii], RenderContext.contextAttributes);
		} 
		catch(e) {}
	}
	
	if ( gl == null )
		throw "GlobWeb : WebGL context cannot be initialized";

	
	if ( options['backgroundColor'] )
	{
		var color = options['backgroundColor'];
		gl.clearColor(color[0],color[1],color[2],color[3]);
	}
	else
	{
		gl.clearColor(0.0, 0.0, 0.0, 1.0);
	}
	
	gl.getExtension('OES_element_index_uint');
	
	gl.pixelStorei( gl['UNPACK_COLORSPACE_CONVERSION_WEBGL'], gl.NONE );
	gl.enable(gl.DEPTH_TEST);
	gl.enable(gl.CULL_FACE);
		
	// Store local variable into static object
	this.viewMatrix = mat4.create();
	this.modelViewMatrix =  mat4.create();
	this.projectionMatrix = mat4.create();
	this.gl = gl;
	this.canvas = canvas;
	this.frustum = new Frustum();
	this.worldFrustum = new Frustum();
	this.localFrustum = new Frustum();
	this.eyePosition = vec3.create();
	this.eyeDirection = vec3.create();
	this.minNear = 0.0001;
	this.minFar = options['minFar'] || 0; // No limit on far
	this.near = RenderContext.minNear;
	this.far = 6.0;
	this.numActiveAttribArray = 0;
	this.frameRequested = false;
	this.fov = 45;
	this.renderers = [];
	
	
	// Initialize the window requestAnimationFrame
	if ( !window.requestAnimationFrame ) 
	{
		window.requestAnimationFrame = ( function() {
			return window.webkitRequestAnimationFrame ||
				 window.mozRequestAnimationFrame ||
				window.oRequestAnimationFrame ||
				window.msRequestAnimationFrame ||
				function( callback, element ) { window.setTimeout( callback, 1000 / 60 );};
			} )();
	}
	
	var self = this;
	this.frameCallback = function() { self.frame(); };
}

/**************************************************************************************************************/

/** 
	The context attributes used when creating WebGL context, see WebGL specification.
	Can be changed by the renderers if needed, or by an external interface.
*/
RenderContext.contextAttributes = {};

/**************************************************************************************************************/

/** 
	Request a frame
*/
RenderContext.prototype.requestFrame = function()
{	
	if (!this.frameRequested)
	{
		window.requestAnimationFrame( this.frameCallback );
		this.frameRequested = true;
	}
}


/**************************************************************************************************************/

/**
 	Deactivate render context
 */
RenderContext.prototype.deactivate = function()
{
	this.isActive = false;
	this.frameRequested = false;
}

/**************************************************************************************************************/

/**
 	Activate render context
 */
RenderContext.prototype.activate = function()
{
	this.isActive = true;
}

/**************************************************************************************************************/

/** 
	A frame of the application
*/
RenderContext.prototype.frame = function() 
{
	if ( this.isActive )
	{
		// Reset frame requested flag first
		this.frameRequested = false;
		
		var stats = this.stats;
		var gl = this.gl;

		if (stats) stats.start("globalRenderTime");
		
		// Update active animations
		if ( this.activeAnimations.length > 0)
		{
			var time = Date.now();
			for (var i = 0; i < this.activeAnimations.length; i++)
			{
				this.activeAnimations[i].update(time);
			}
		}
		
		// Clear the buffer
		if ( RenderContext.contextAttributes.stencil )
		{
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
		}
		else
		{
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
		}
		
		// Check canvas size is valid
		if ( this.canvas.width == 0 || this.canvas.height == 0 )
			return;
			
		gl.viewport(0, 0, this.canvas.width, this.canvas.height);

		// Update view dependent properties to be used during rendering : view matrix, frustum, projection, etc...
		this.updateViewDependentProperties();
				
		// Call render method of all registered renderers
		for ( var i=0; i<this.renderers.length; i++ )
		{
			this.renderers[i].render();
		}
		
		if (stats) stats.end("globalRenderTime");
		
		// Request next frame
		if ( this.continuousRendering )
		{
			this.requestFrame();
		}
		else if ( this.activeAnimations.length > 0 )
		{
			this.requestFrame();
		}
	}	
};

/**************************************************************************************************************/

/** 
	Update properies that depends on the view matrix
*/
RenderContext.prototype.updateViewDependentProperties = function()
{
	var inverseViewMatrix = mat4.create();
	mat4.inverse( this.viewMatrix, inverseViewMatrix );
	
	vec3.set( [ 0.0, 0.0, 0.0 ], this.eyePosition );
	mat4.multiplyVec3( inverseViewMatrix, this.eyePosition );
	
	vec3.set( [ 0.0, 0.0, -1.0 ], this.eyeDirection );
	mat4.rotateVec3( inverseViewMatrix, this.eyeDirection );
	
	// Init projection matrix
	mat4.perspective(this.fov, this.canvas.width / this.canvas.height, this.minNear, this.far, this.projectionMatrix);
	
	// Compute the frustum from the projection matrix
	this.frustum.compute(this.projectionMatrix);
	
	// Compute the world frustum
	this.worldFrustum.inverseTransform( this.frustum, this.viewMatrix );
	
	// Compute the pixel size vector from the current view/projection matrix
	this.pixelSizeVector = this.computePixelSizeVector();
}

/**************************************************************************************************************/

/**
	Get mouse coordinates relative to the canvas element
*/
RenderContext.prototype.getXYRelativeToCanvas = function(event)
{
	// cf. http://stackoverflow.com/questions/55677/how-do-i-get-the-coordinates-of-a-mouse-click-on-a-canvas-element
	var pos = [];
	if (event.pageX || event.pageY)
	{
		pos[0] = event.pageX;
		pos[1] = event.pageY;
	}
	else
	{ 
		pos[0] = event.clientX + document.body.scrollLeft + document.documentElement.scrollLeft; 
		pos[1] = event.clientY + document.body.scrollTop + document.documentElement.scrollTop; 
	}
	
	var element = this.canvas; 
	while (element)
	{
		pos[0] -= element.offsetLeft;
		pos[1] -= element.offsetTop;
		element = element.offsetParent;
	}
        
	return pos;
}


/**************************************************************************************************************/

/** 
	Compute the pixel size vector
*/
RenderContext.prototype.computePixelSizeVector = function( mv )
{
	// pre adjust P00,P20,P23,P33 by multiplying them by the viewport window matrix.
	// here we do it in short hand with the knowledge of how the window matrix is formed
	// note P23,P33 are multiplied by an implicit 1 which would come from the window matrix.
	// Robert Osfield, June 2002.
	
	var width = this.canvas.width;
	var height = this.canvas.height;
	var P = this.projectionMatrix;
	var V = mv || this.viewMatrix;
	
	// scaling for horizontal pixels
	var P00 = P[0]*width*0.5;
	var P20_00 = P[8]*width*0.5 + P[11]*width*0.5;
	var scale_00 = [ V[0]*P00 + V[2]*P20_00,
			V[4]*P00 + V[6]*P20_00,
			V[8]*P00 + V[10]*P20_00 ];

	// scaling for vertical pixels
	var P10 = P[5]*height*0.5;
	var P20_10 = P[9]*height*0.5 + P[11]*height*0.5;
	var scale_10 = [ V[1]*P10 + V[2]*P20_10,
			V[5]*P10 + V[6]*P20_10,
			V[9]*P10 + V[10]*P20_10 ];

	var P23 = P[11];
	var P33 = P[15];
	var pixelSizeVector = [V[2]*P23,
				V[6]*P23,
				V[10]*P23,
				V[14]*P23 + V[15]*P33];

	var scaleRatio  = 0.7071067811 / Math.sqrt( vec3.dot(scale_00,scale_00)+ vec3.dot(scale_10,scale_10) );
	pixelSizeVector[0] *= scaleRatio;
	pixelSizeVector[1] *= scaleRatio;
	pixelSizeVector[2] *= scaleRatio;
	pixelSizeVector[3] *= scaleRatio;

	return pixelSizeVector;
}

/**************************************************************************************************************/

/** 
	Get pixel from 3D
	TODO: move it to Globe/Sky too ?
*/
RenderContext.prototype.getPixelFrom3D = function(x,y,z)
{
	var viewProjectionMatrix = mat4.create();
	mat4.multiply(this.projectionMatrix, this.viewMatrix, viewProjectionMatrix);
	
	// transform world to clipping coordinates
	var point3D = [x,y,z,1];
	mat4.project(viewProjectionMatrix, point3D);
	
	// transform clipping to window coordinates
	var winX = Math.round( ( 1 + point3D[0] ) * 0.5 * this.canvas.width );
	
	// reverse y because (0,0) is top left but opengl's normalized
	// device coordinate (-1,-1) is bottom left
	var winY = Math.round( ( 1 - point3D[1] ) * 0.5 * this.canvas.height );

	return [winX, winY];
}

/**************************************************************************************************************/

/** 
	Create a non power of two texture from an image
*/
RenderContext.prototype.createNonPowerOfTwoTextureFromImage = function(image, invertY)
{	
	var gl = this.gl;
	var tex = gl.createTexture();
	gl.bindTexture(gl.TEXTURE_2D, tex);
	gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, invertY);
	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	// Restore to default
	gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
	return tex;
}

/**************************************************************************************************************/

return RenderContext;

});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define( 'BoundingBox',[],function() {

/**************************************************************************************************************/

/** @constructor
	BoundingBox constructor
 */
var BoundingBox = function(min,max)
{
	if (min)
	{
		this.min = vec3.create( min );
	}
	if (max)
	{
		this.max = vec3.create( max );
	}
}

/**************************************************************************************************************/

/**
	Extent the bounding box with the given point
 */
BoundingBox.prototype.extend = function( x, y, z)
{
	if (!this.min)
	{
		this.min = vec3.create();
		this.max = vec3.create();
		
		this.min[0] = x;
		this.min[1] = y;
		this.min[2] = z;
		this.max[0] = x;
		this.max[1] = y;
		this.max[2] = z;
	}
	else
	{
		if ( x < this.min[0] )
		{
			this.min[0] = x;
		}
		if ( y < this.min[1] )
		{
			this.min[1] = y;
		}
		if ( z < this.min[2] )
		{
			this.min[2] = z;
		}
		if ( x > this.max[0] )
		{
			this.max[0] = x;
		}
		if ( y > this.max[1] )
		{
			this.max[1] = y;
		}
		if ( z > this.max[2] )
		{
			this.max[2] = z;
		}
	}
}
/**************************************************************************************************************/

/**
	Compute the bounding box from an array of vertices
 */
BoundingBox.prototype.compute = function(vertices,length,stride)
{
	if (!this.min)
	{
		this.min = vec3.create();
		this.max = vec3.create();
	}
	
	this.min[0] = vertices[0];
	this.min[1] = vertices[1];
	this.min[2] = vertices[2];
	this.max[0] = vertices[0];
	this.max[1] = vertices[1];
	this.max[2] = vertices[2];
	
	var st = stride || 3;
	var ll = length || vertices.length;
	
	for (var i=st; i < ll; i += st)
	{
		for (var j=0; j < 3; j++)
		{
			if ( vertices[i+j] < this.min[j] )
			{
				this.min[j] = vertices[i+j];
			}
			if ( vertices[i+j] > this.max[j] )
			{
				this.max[j] = vertices[i+j];
			}
		}
	}
}

/**************************************************************************************************************/

/**
	Get the corner of a bounding box
 */
BoundingBox.prototype.getCorner = function(pos)
{
	return [ pos&1 ? this.max[0] : this.min[0],
			pos&2 ? this.max[1] : this.min[1],
			pos&4 ? this.max[2] : this.min[2]	];
}

/**************************************************************************************************************/

/**
	Get the center of a bounding box
 */
BoundingBox.prototype.getCenter = function()
{
	return [ (this.max[0] + this.min[0]) * 0.5,
			(this.max[1] + this.min[1]) * 0.5,
			(this.max[2] + this.min[2]) * 0.5	];
}

/**************************************************************************************************************/

/**
	Get the radius of a bounding box
 */
BoundingBox.prototype.getRadius = function()
{
	var vec = vec3.create();
	vec3.subtract( this.max, this.min, vec)
	return 0.5 * vec3.length(vec);
}

/**************************************************************************************************************/

return BoundingBox;

});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 define('Tile',['./BoundingBox','./glMatrix'], 
	function(BoundingBox) {

/**************************************************************************************************************/

/** @constructor
	Tile constructor
 */
var Tile = function()
{
	// Parent/child relationship
	this.parent = null;
	this.parentIndex = -1;
	this.children = null;
	
	// Graphics data to render the tile
	this.vertices = null;
	this.texture = null;
	this.vertexBuffer = null;
	this.texTransform = [1., 1., 0., 0.];
	
	// Tile spatial data
	this.matrix = null;
	this.inverseMatrix = null;
	this.bbox = new BoundingBox();
	
	// For culling
	this.radius = 0.0;	
	this.distance = 0.0;
	this.closestPointToEye = [ 0.0, 0.0, 0.0 ];
	
	// Specific object to store extension from renderers
	this.extension = {};
	
	// For debug
	//this.color = [ Math.random(), Math.random(), Math.random() ];
	
	this.state = Tile.State.NONE;
	
	// Tile configuration given by tile manager : contains if the tile uses skirt, the tesselation, etc...
	this.config = null;
	this.imageSize = 256;
}

/**************************************************************************************************************/

/**
 *	Tile state enumerations
 */
Tile.State = 
{
	ERROR : -10,
	NONE : 0,
	REQUESTED : 1,
	LOADING : 2,
	LOADED : 3
};


/**************************************************************************************************************/

/**
 * Compute position on the tile using normalized coordinate between [0,size-1]
 */
Tile.prototype.computePosition = function(u,v)
{
	var size = this.config.tesselation;
	u = Math.min( size-1, Math.max( 0, u ) );
	v = Math.min( size-1, Math.max( 0, v ) );
	
	var vFloor = Math.floor( v );
	var vFrac = v - vFloor;
	var uFloor = Math.floor( u );
	var uFrac = u - uFloor;
	var vertexSize = this.config.vertexSize;
	var vertexOffset = vertexSize*( vFloor*size + uFloor );
	var vec = [ 0.0, 0.0, 0.0 ];
	for ( var i=0; i < 3; i++)
	{
		vec[i] = (1.0 - vFrac) * (1.0 - uFrac) * this.vertices[ vertexOffset + i ]
		+ vFrac * (1.0 - uFrac) * this.vertices[ vertexOffset + vertexSize*size + i ]
		+ vFrac * uFrac * this.vertices[ vertexOffset + vertexSize*size + vertexSize + i ]
		+ (1.0 - vFrac) * uFrac * this.vertices[ vertexOffset + vertexSize + i ];
	}
	
	return vec;
}


/**************************************************************************************************************/

/**
 *	Initialize the tile from its parent
 */
Tile.prototype.initFromParent = function(parent,i,j)
{
	this.parent = parent;
	this.parentIndex = j*2 + i;
	this.matrix  = parent.matrix;
	this.inverseMatrix  = parent.inverseMatrix;
	this.texture = parent.texture;
	this.config = parent.config;
	
	this.vertexBuffer = parent.vertexBuffer;
	
	// Recompute the bounding box
	// Very fast and coarse version but it does not work with HEALPix tiling
	//var w = 0.5 * (parent.bbox.max[0] - parent.bbox.min[0]);
	//var h = -0.5 * (parent.bbox.max[1] - parent.bbox.min[1]);
	//var min = [  parent.bbox.min[0] + i * w, parent.bbox.max[1] + (j+1) * h, parent.bbox.min[2] ];
	//var max = [  parent.bbox.min[0] + (i+1) * w, parent.bbox.max[1] + j * h, parent.bbox.max[2] ];
	
	var size = this.config.tesselation;
	var halfTesselation = (size-1)/2;
	for (var n = 0; n <= halfTesselation; n++)
	{
		var offset = this.config.vertexSize * ( (n+j*halfTesselation)*size + i*halfTesselation );
		for (var k = 0; k <= halfTesselation; k++)
		{
			this.bbox.extend( parent.vertices[offset], parent.vertices[offset+1], parent.vertices[offset+2] );
			offset += this.config.vertexSize;
		}
	}
	
	// Compute the bounding box
	this.radius = this.bbox.getRadius();
	
	// Init extension
	for ( var x in parent.extension ) 
	{
		var e = parent.extension[x];
		if ( e.initChild )
		{
			e.initChild(this,i,j);
		}
	}

}

/**************************************************************************************************************/

/**
 *	Test if the tile needs to be refined
 */
Tile.prototype.needsToBeRefined = function(renderContext)
{
	if ( this.distance < this.radius )
		return true;

	// Approximate the radius of one texel : the radius of the tile divided by the image size
	// The radius is taken as the average of the bbox width and length, rather than the actual radius because at the pole, there is a large difference betwen width and length
	// and the radius (ie maximum width/length) is too pessimistic
	var radius = 0.25 * ( (this.bbox.max[0] - this.bbox.min[0]) + (this.bbox.max[1] - this.bbox.min[1]) )  / this.imageSize; 
	
	// Transform the closest point from the eye in world coordinates
	var mat = this.matrix;
	var c = this.closestPointToEye;
	var px = mat[0]*c[0] + mat[4]*c[1] + mat[8]*c[2] + mat[12];
	var py = mat[1]*c[0] + mat[5]*c[1] + mat[9]*c[2] + mat[13];
	var pz = mat[2]*c[0] + mat[6]*c[1] + mat[10]*c[2] + mat[14];
	
	// Compute the pixel size of the radius texel
	var pixelSizeVector = renderContext.pixelSizeVector;
	var pixelSize = radius / ( px * pixelSizeVector[0] + py * pixelSizeVector[1]
						+ pz * pixelSizeVector[2] + pixelSizeVector[3] );
	
	// Check if pixel radius of a texel is superior to the treshold
	// The pixel size can be negative when the closest point is close to the near plane, so take absolute value
	return Math.abs(pixelSize) > renderContext.tileErrorTreshold;
}

/**************************************************************************************************************/

/**
 *	Test if the tile is culled given the current view parameters
 */
Tile.prototype.isCulled = function(renderContext)
{	
	// Compute the eye in tile local space
	var mat = this.inverseMatrix;
	var c = renderContext.eyePosition;
	var ex = mat[0]*c[0] + mat[4]*c[1] + mat[8]*c[2] + mat[12];
	var ey = mat[1]*c[0] + mat[5]*c[1] + mat[9]*c[2] + mat[13];
	var ez = mat[2]*c[0] + mat[6]*c[1] + mat[10]*c[2] + mat[14];
			
	// If the eye is in the radius of the tile, consider the tile is not culled
	this.distance = Math.sqrt( ex * ex + ey * ey + ez * ez );
	if ( this.distance < this.radius )
	{
		this.distance = 0.0;
		return false;
	}
	else
	{
		var pt = this.closestPointToEye;
		
		// Compute closest point to eye with the bbox of the tile
		pt[0] = Math.min( Math.max( ex, this.bbox.min[0] ), this.bbox.max[0] );
		pt[1] = Math.min( Math.max( ey, this.bbox.min[1] ), this.bbox.max[1] );
		pt[2] = Math.min( Math.max( ez, this.bbox.min[2] ), this.bbox.max[2] );
		
		// Compute horizontal culling only if the eye is "behind" the tile
		// and the coordinate system is not a plane(no need to compute horizon culling on plane)
		if ( ez < 0.0 && !this.config.coordinateSystem.isFlat )
		{
			// Compute vertical at the closest point. The earth center is [0, 0, -radius] in tile local space.
			var vx = pt[0];
			var vy = pt[1];
			var vz = pt[2] + this.config.coordinateSystem.radius;
			var vl = Math.sqrt( vx * vx + vy * vy + vz * vz );
			vx /= vl; vy /= vl; vz /= vl;
			
			// Compute eye direction at the closest point (clampled on earth to avoid problem with mountains)
			// The position clamp to earth is Vertical * Radius + EarthCenter. The EarthCenter being 0,0,-radius a lot of simplification is done.
			var edx = ex - vx * this.config.coordinateSystem.radius;
			var edy = ey - vy * this.config.coordinateSystem.radius;
			var edz = ez - (vz - 1.0) * this.config.coordinateSystem.radius;
			
			// Compute dot product between eye direction and the vertical at the point
			var el = Math.sqrt( edx * edx + edy * edy  + edz * edz );
			var eDv = (edx * vx + edy * vy  + edz * vz) / el;
						
			eDv *= this.config.cullSign;
			
			if ( eDv < -0.05 )
			{
				return true;
			}
		}
		
		// Compute local frustum
		var localFrustum = renderContext.localFrustum;
		localFrustum.inverseTransform( renderContext.worldFrustum, this.matrix );
		
		// Check if the tile is inside the frustum
		return !localFrustum.containsBoundingBox(this.bbox);
	}
}

/**************************************************************************************************************/

/**
 *	Dispose the tile
 */
Tile.prototype.dispose = function(renderContext,tilePool)
{		
	// Dispose extension even if tile isn't loaded because it can be culled
	for ( var x in this.extension )
	{
		if ( this.extension[x].dispose )
			this.extension[x].dispose(renderContext,tilePool);
	}

	if ( this.state == Tile.State.LOADED  )
	{
		tilePool.disposeGLBuffer(this.vertexBuffer);
		if (this.texture) tilePool.disposeGLTexture(this.texture);
		
		this.vertexBuffer = null;
		this.texture = null;
		this.parent = null;
		
		this.state = Tile.State.NONE;
	}
}

/**************************************************************************************************************/

/**
 *	Delete the children
 */
Tile.prototype.deleteChildren = function(renderContext,tilePool)
{
	if ( this.children )
	{
		for (var i = 0; i < 4; i++)
		{
			// Recursively delete its children
			this.children[i].deleteChildren(renderContext,tilePool);
			// Dispose its ressources (WebGL)
			this.children[i].dispose(renderContext,tilePool);
		}
		
		// Cleanup the tile
		this.children = null;
	}
}

/**************************************************************************************************************/

/**
 *	Build skirt vertices
 */
Tile.prototype.buildSkirtVertices = function(center,srcOffset,srcStep,dstOffset)
{
	var vertices = this.vertices;
	var skirtHeight = this.radius * 0.05;
	
	var size = this.config.tesselation;
	for ( var i = 0; i < size; i++)
	{
/*		//Not optimized version of skirt computation
		var srcPos = [ vertices[srcOffset], vertices[srcOffset+1], vertices[srcOffset+2] ];
		var dir = vec3.subtract( srcPos, center, vec3.create() );
		vec3.normalize(dir);
		vec3.scale( dir, skirtHeight );
		vec3.subtract( srcPos, dir );*/
		
		// Optimized version of skirt computation
		var x = vertices[srcOffset] - center[0];
		var y = vertices[srcOffset+1] - center[1];
		var z = vertices[srcOffset+2] - center[2];
		var scale = skirtHeight / Math.sqrt( x*x + y*y + z*z );
		x *= scale;
		y *= scale;
		z *= scale;
		
		vertices[ dstOffset ] = vertices[srcOffset] - x;
		vertices[ dstOffset+1 ] = vertices[srcOffset+1] - y;
		vertices[ dstOffset+2 ] = vertices[srcOffset+2] - z;
		
		for (var n = 3; n < this.config.vertexSize; n++)
		{
			vertices[ dstOffset+n ] = vertices[srcOffset+n];
		}
		
		dstOffset += this.config.vertexSize;
		srcOffset += srcStep;
	}	
}

/**************************************************************************************************************/

/**
 *	Generate normals for a tile
 */
Tile.prototype.generateNormals = function()
{	
	var size = this.config.tesselation;
	var vertexSize = this.config.vertexSize;
	var lineSize = vertexSize*size;
	
	var vo = 0;
	for ( var j=0; j < size; j++ )
	{
		var vp1 = j == size-1 ? 0 : lineSize;
		var vm1 = j == 0 ? 0 : -lineSize;
		for ( var i=0; i < size; i++ )
		{
			var up1 = i == size-1 ? 0 : vertexSize;
			var um1 = i == 0 ? 0 : -vertexSize;
			var u = [
				this.vertices[vo+up1] - this.vertices[vo+um1],
				this.vertices[vo+up1+1] - this.vertices[vo+um1+1],
				this.vertices[vo+up1+2] - this.vertices[vo+um1+2],
			];
			var v = [
				this.vertices[vo+vp1] - this.vertices[vo+vm1],
				this.vertices[vo+vp1+1] - this.vertices[vo+vm1+1],
				this.vertices[vo+vp1+2] - this.vertices[vo+vm1+2],
			];
			
			var normal = vec3.cross( u, v, [] );
			vec3.normalize(normal);
			this.vertices[vo+3] = normal[0];
			this.vertices[vo+4] = normal[1];
			this.vertices[vo+5] = normal[2];
			
			vo += vertexSize;
		}
	}
}

/**************************************************************************************************************/

/**
 *	Generate the tile
 */
Tile.prototype.generate = function(tilePool,image,elevations)
{
	// Generate the vertices
	this.vertices = this.generateVertices(elevations);
		
	// Compute the bounding box
	var size = this.config.tesselation;
	var vertexSize = this.config.vertexSize;
	this.bbox.compute(this.vertices,vertexSize*size*size,vertexSize);
	this.radius = this.bbox.getRadius();
	
	// Compute normals if needed
	if (this.config.normals)
	{
		this.generateNormals();
	}
		
	// Compute skirt from vertices
	if (this.config.skirt)
	{
		// Compute local earth center, used to generate skirts
		var localEarthCenter = [ 0.0, 0.0, 0.0 ];
		mat4.multiplyVec3( this.inverseMatrix, localEarthCenter );
		
		// Skirts
		var dstOffset = vertexSize * (size * size); // TOP
		this.buildSkirtVertices( localEarthCenter, 0, vertexSize, dstOffset );
		dstOffset += vertexSize * size; // BOTTOM
		this.buildSkirtVertices( localEarthCenter, vertexSize * (size * (size-1)), vertexSize, dstOffset );
		dstOffset += vertexSize * size; // LEFT
		this.buildSkirtVertices( localEarthCenter, 0, vertexSize * size, dstOffset );
		dstOffset += vertexSize * size; // RIGHT
		this.buildSkirtVertices( localEarthCenter, vertexSize * (size-1), vertexSize * size, dstOffset );
		
		// These skirts are only used by children tile
		dstOffset += vertexSize * size; // CENTER
		this.buildSkirtVertices( localEarthCenter, vertexSize * ( size * (size-1)/2 ), vertexSize, dstOffset );
		dstOffset += vertexSize * size; // MIDDLE
		this.buildSkirtVertices( localEarthCenter, vertexSize * ( (size-1)/2 ), vertexSize * size, dstOffset );
	}	
	
	// Avoid double creation of vertex buffer for level0Tiles generation
	if (this.vertexBuffer != null && this.parent == null)
	{
		tilePool.disposeGLBuffer(this.vertexBuffer);
	}
	this.vertexBuffer = tilePool.createGLBuffer(this.vertices);

	// Create texture
	if (image)
	{
		this.texture = tilePool.createGLTexture(image);
		this.imageSize = this.config.imageSize;
	}
	
	this.state = Tile.State.LOADED;
}

/**************************************************************************************************************/

return Tile;

});
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/
 
 define ( 'Utils',[],function() {
 
 var Utils = {};
 
 /** 
  * Inherits from an object
  */
Utils.inherits = function(base, sub) 
{
	function tempCtor() {}
	tempCtor.prototype = base.prototype;
	sub.prototype = new tempCtor();
	sub.prototype.constructor = sub;
}

return Utils;

});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 define( 'GeoBound',[],function() {
 
/**************************************************************************************************************/

/** @constructor
	@export
	GeoBound constructor
 */
var GeoBound = function( w, s, e, n )
{
	this.south = s;
	this.west = w;
	this.north = n;
	this.east = e;
}

/**************************************************************************************************************/

/**
	Get geo center
 */
GeoBound.prototype.getCenter = function()
{
	return [ (this.east+this.west)*0.5, (this.south+this.north)*0.5, 0.0 ];
}

/**************************************************************************************************************/

/**	@export
	Get north
 */
GeoBound.prototype.getNorth = function()
{
	return this.north;
}

/**************************************************************************************************************/

/**	@export
	Get south
 */
GeoBound.prototype.getSouth = function()
{
	return this.south;
}

/**************************************************************************************************************/

/**	@export
	Get west
 */
GeoBound.prototype.getWest = function()
{
	return this.west;
}

/**************************************************************************************************************/

/**	@export
	Get east
 */
GeoBound.prototype.getEast = function()
{
	return this.east;
}

/**************************************************************************************************************/

/**
	Compute the geo bound from coordinates
 */
GeoBound.prototype.computeFromCoordinates = function( coordinates, checkDateLine )
{
	this.west = coordinates[0][0];
	this.east = coordinates[0][0];
	this.south = coordinates[0][1];
	this.north = coordinates[0][1];
	
	for ( var i = 1; i < coordinates.length; i++ )
	{
		this.west = Math.min( this.west, coordinates[i][0] );
		this.east = Math.max( this.east, coordinates[i][0] );
		this.south = Math.min( this.south, coordinates[i][1] );
		this.north = Math.max( this.north, coordinates[i][1] );

		// HACK: If coordinates crosses dateline take all the globe
		// Only used within intersectGeometry method to render properly crossing dateline polygon for now
		if ( checkDateLine && Math.abs(coordinates[i-1][0] - coordinates[i][0]) > 180 ) {
			this.west = -180;
			this.east = 180;
		}
	}
}

/**************************************************************************************************************/

/**
	Intersects this geo bound with another one
 */
GeoBound.prototype.intersects = function( geoBound )
{
	if ( this.west >= geoBound.east || this.east <= geoBound.west )
		return false;
		
	if ( this.south >= geoBound.north || this.north <= geoBound.south )
		return false;
		
	return true;
}

/**************************************************************************************************************/

/**
 	Intersects this geo bound with GeoJSON geometry
 */
GeoBound.prototype.intersectsGeometry = function( geometry )
{
	var isIntersected = false;
	var geoBound = new GeoBound();
	var coords = geometry['coordinates'];
	switch (geometry['type'])
	{
		case "LineString":
			geoBound.computeFromCoordinates( coords );
			isIntersected |= this.intersects(geoBound);
			break;
		case "Polygon":
			// Don't take care about holes
			for ( var i = 0; i < coords.length && !isIntersected; i++ )
			{
				geoBound.computeFromCoordinates( coords[i], true );
				isIntersected |= this.intersects(geoBound);
			}
			break;
		case "MultiLineString":
			for ( var i = 0; i < coords.length && !isIntersected; i++ )
			{
				geoBound.computeFromCoordinates( coords[i] );
				isIntersected |= this.intersects(geoBound);
			}
			break;
		case "MultiPolygon":
			for ( var i = 0; i < coords.length && !isIntersected; i++ )
			{
				for ( var j = 0; j < coords[i].length && !isIntersected; j++ )
				{
					geoBound.computeFromCoordinates( coords[i][j] );
					isIntersected |= this.intersects(geoBound);
				}
			}
			break;
	}
	return isIntersected;
}

/**************************************************************************************************************/

return GeoBound;

});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 define('GeoTiling',['./Utils','./Tile','./GeoBound'], function(Utils,Tile,GeoBound) {
 
/**************************************************************************************************************/

/** @constructor
	GeoTiling constructor
 */
var GeoTiling = function(nx,ny)
{
	this.level0NumTilesX = nx;
	this.level0NumTilesY = ny;
}

/**************************************************************************************************************/

/** 
	Generate the tiles for level zero
 */
GeoTiling.prototype.generateLevelZeroTiles = function(config)
{	
	config.skirt = 1;
	config.cullSign = 1;
	config.srs = 'EPSG:4326';

	var level0Tiles = [];
	
	var latStep = 180 / this.level0NumTilesY;
	var lonStep = 360 / this.level0NumTilesX;
	
	for (var j = 0; j < this.level0NumTilesY; j++)
	{
		for (var i = 0; i < this.level0NumTilesX; i++)
		{
			var geoBound = new GeoBound( -180 + i * lonStep, 90 - (j+1) * latStep, -180 + (i+1) * lonStep, 90 - j * latStep  );
			var tile = new GeoTile(geoBound, 0, i, j)
			tile.config = config;
			level0Tiles.push( tile );
		}
	}

	return level0Tiles;
}


/**
 * Compute the bbox of a feature
 */
var _getBBox = function(geometry) {

	// Get the coordinates
	var coords;
	var checkDateLine = true;
	switch (geometry.type) {
		case "Point":
			coords = geometry.coordinates;
			return [ coords[0], coords[1], coords[0], coords[1] ];
		case "MultiPoint":
			coords = geometry.coordinates;
			checkDateLine = false;
			break;
		case "Polygon":
			coords = geometry.coordinates[0];
			break;
		case "MultiPolygon":
			coords = geometry.coordinates[0][0];
			break;
		case "LineString":
			coords = geometry.coordinates;
			break;
		case "MultiLineString":
			coords = geometry.coordinates[0];
			break;
	}
	
	if (!coords || coords.length == 0)
		return;

	var minX = coords[0][0];
	var minY = coords[0][1];
	var maxX =  coords[0][0];
	var maxY =  coords[0][1];
	
	var numOuterRings = (geometry.type == "MultiPolygon" || geometry.type == "MultiLineString" ? geometry.coordinates.length : 1);
	for ( var j = 0; j < numOuterRings; j++ ) {
		switch (geometry.type) {
			case "MultiPolygon":
				coords = geometry.coordinates[j][0];
				break;
			case "MultiLineString":
				coords = geometry.coordinates[j];
				break;
		}

		for ( var i = 0;  i < coords.length; i++ )	{
			minX = Math.min( minX, coords[i][0] );	
			minY = Math.min( minY, coords[i][1] );	
			maxX = Math.max( maxX, coords[i][0] );	
			maxY = Math.max( maxY, coords[i][1] );	
			
			// Check if the coordinates cross dateline
			if ( checkDateLine && i > 0 && Math.abs(coords[i-1][0] - coords[i][0]) > 180 ) {
				minX = -180;
				maxX = 180;
			}
		}
	}
	
	return [ minX, minY, maxX, maxY ];
};

/**************************************************************************************************************/

/** 
	Locate a level zero tile
 */
GeoTiling.prototype._lon2LevelZeroIndex = function(lon)
{	
	var levelZeroIndex = Math.floor( (lon + 180) * this.level0NumTilesX / 360 );

    // Clamp between 0 and level0NumTilesX (can occure when lon isn't normalized)
    if ( levelZeroIndex > this.level0NumTilesX-1 )
        return this.level0NumTilesX-1;
    if ( levelZeroIndex < 0 )
        return 0;

    return levelZeroIndex;
}

/**************************************************************************************************************/

/** 
	Locate a level zero tile
 */
GeoTiling.prototype._lat2LevelZeroIndex = function(lat)
{	
	return Math.min(  this.level0NumTilesY-1, Math.floor( (90 - lat) * this.level0NumTilesY / 180 ) );
}
/**************************************************************************************************************/

/** 
	Locate a level zero tile
 */
GeoTiling.prototype.lonlat2LevelZeroIndex = function(lon,lat)
{	
	return this._lat2LevelZeroIndex(lat) * this.level0NumTilesX + this._lon2LevelZeroIndex(lon);
}


/**************************************************************************************************************/

/** 
	Get the overlapped tile by the given geometry
 */
GeoTiling.prototype.getOverlappedLevelZeroTiles = function(geometry)
{
	var tileIndices = [];
	
	var bbox = _getBBox(geometry);
	if (bbox)
	{
		var i1 = this._lon2LevelZeroIndex(bbox[0]);
		var j1 = this._lat2LevelZeroIndex(bbox[3]);
		var i2 = this._lon2LevelZeroIndex(bbox[2]);
		var j2 = this._lat2LevelZeroIndex(bbox[1]);
		
		
		for ( var j = j1; j <= j2; j++ ) {
			for ( var i = i1; i <= i2; i++ ) {
				tileIndices.push( j * this.level0NumTilesX + i );
			}
		}
	}

	return tileIndices;
}

/**************************************************************************************************************/

/** @constructor
	Tile constructor
 */
var GeoTile = function( geoBound, level, x, y )
{
    // Call ancestor constructor
    Tile.prototype.constructor.call(this);
	
	this.bound = this.geoBound = geoBound;
	this.level = level;
	this.x = x;
	this.y = y;
}

/**************************************************************************************************************/

/** inherits from Tile */
GeoTile.prototype = new Tile;

/**************************************************************************************************************/

/** @export
  Get elevation at a geo position
*/
GeoTile.prototype.getElevation = function(lon,lat)
{
	// Get the lon/lat in coordinates between [0,1] in the tile
	var u = (lon - this.geoBound.west) / (this.geoBound.east - this.geoBound.west);
 	var v = (lat - this.geoBound.north) / (this.geoBound.south - this.geoBound.north);

	// Quick fix when lat is on the border of the tile
	var childIndex = (v >= 1 ? 1 : Math.floor(2*v) )*2 + Math.floor(2*u);
	if ( this.children && this.children[childIndex].state == Tile.State.LOADED )
		return this.children[childIndex].getElevation(lon,lat);
	
	var tess = this.config.tesselation;
	var i = Math.floor( u * tess );
	var j = Math.floor( v * tess );
	
	var vo = this.config.vertexSize * (j * tess + i);
	var vertex = [ this.vertices[vo], this.vertices[vo+1], this.vertices[vo+2] ];
	mat4.multiplyVec3( this.matrix, vertex );
	var geo = this.config.coordinateSystem.from3DToGeo(vertex);
	return geo[2];
}

/**************************************************************************************************************/

/**
	Create the children
 */
GeoTile.prototype.createChildren = function()
{
	// Create the children
	var lonCenter = ( this.geoBound.east + this.geoBound.west ) * 0.5;
	var latCenter = ( this.geoBound.north + this.geoBound.south ) * 0.5;
	
	var level = this.level+1;
	
	var tile00 = new GeoTile( new GeoBound( this.geoBound.west, latCenter, lonCenter, this.geoBound.north), level, 2*this.x, 2*this.y );
	var tile10 = new GeoTile( new GeoBound( lonCenter, latCenter,  this.geoBound.east, this.geoBound.north), level, 2*this.x+1, 2*this.y );
	var tile01 = new GeoTile( new GeoBound( this.geoBound.west, this.geoBound.south, lonCenter, latCenter), level, 2*this.x, 2*this.y+1 );
	var tile11 = new GeoTile( new GeoBound( lonCenter, this.geoBound.south, this.geoBound.east, latCenter), level, 2*this.x+1, 2*this.y+1  );
	
	tile00.initFromParent( this, 0, 0 );
	tile10.initFromParent( this, 1, 0 );
	tile01.initFromParent( this, 0, 1 );
	tile11.initFromParent( this, 1, 1 );
	
	this.children = [ tile00, tile10, tile01, tile11 ];	
}

/**************************************************************************************************************/

/**
	Convert coordinates in longitude,latitude to coordinate in "tile space"
	Tile space means coordinates are between [0,tesselation-1] if inside the tile
	Used by renderers algorithm to clamp coordinates on the tile
 */
GeoTile.prototype.lonlat2tile = function(coordinates)
{
	var ul = this.geoBound.east - this.geoBound.west;
	var vl = this.geoBound.south - this.geoBound.north;
	var factor = this.config.tesselation-1;
	
	var tileCoords = [];
	for ( var i = 0; i < coordinates.length; i++ )
	{
		var u = factor * (coordinates[i][0] - this.geoBound.west) / ul;
		var v = factor * (coordinates[i][1] - this.geoBound.north) / vl;
		tileCoords.push( [ u, v ] );	
	}
	
	return tileCoords;
}

/**************************************************************************************************************/

/**
	Generate vertices for tile
 */
GeoTile.prototype.generateVertices = function(elevations)
{	
	// Compute tile matrix
	this.matrix = this.config.coordinateSystem.getLHVTransform( this.geoBound.getCenter() );
	var invMatrix = mat4.create();
	mat4.inverse( this.matrix, invMatrix );
	this.inverseMatrix = invMatrix;
	
	// Build the vertices
	var vertexSize = this.config.vertexSize;
	var size = this.config.tesselation;
	var vertices = new Float32Array( vertexSize*size*(size+6) );
	var lonStep = (this.geoBound.east - this.geoBound.west) / (size-1);
	var latStep = (this.geoBound.south - this.geoBound.north) / (size-1);
	var radius = this.config.coordinateSystem.radius;
	var scale = this.config.coordinateSystem.heightScale;
	var offset = 0;
	
	// Optimized build for sphere coordinates : uncomment if needed
	var lat = this.geoBound.north /* * Math.PI / 180.0*/;
	// latStep = latStep * Math.PI / 180.0;
	// lonStep = lonStep * Math.PI / 180.0;
	var pos3d = [ 0.0, 0.0, 0.0 ];
	for ( var j=0; j < size; j++)
	{
		//var cosLat = Math.cos( lat );
		//var sinLat = Math.sin( lat );
		
		var lon = this.geoBound.west /* * Math.PI / 180.0*/;
				
		for ( var i=0; i < size; i++)
		{
			// var height = elevations ? scale * elevations[ offset ] : 0.0;
			// var x = (radius + height) * Math.cos( lon ) * cosLat;
			// var y = (radius + height) * Math.sin( lon ) * cosLat;
			// var z = (radius + height) * sinLat;

			var height = elevations ? elevations[ offset ] : 0.0;
			this.config.coordinateSystem.fromGeoTo3D( [lon, lat, height], pos3d );
			var x = pos3d[0];
			var y = pos3d[1];
			var z = pos3d[2];

			var vi = offset * vertexSize;
			vertices[vi] = invMatrix[0]*x + invMatrix[4]*y + invMatrix[8]*z + invMatrix[12];
			vertices[vi+1] = invMatrix[1]*x + invMatrix[5]*y + invMatrix[9]*z + invMatrix[13];
			vertices[vi+2] = invMatrix[2]*x + invMatrix[6]*y + invMatrix[10]*z + invMatrix[14];
						
			offset++;
			lon += lonStep;
		}
		
		lat += latStep;
	}
	
	return vertices;
}

/**************************************************************************************************************/

return GeoTiling;

});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 define('TilePool',[],function() {

/**************************************************************************************************************/

/** 
	@constructor
	TilePool constructor
 */
var TilePool = function(rc)
{
	// Private properties
	var gl = rc.gl;
	var glTexturePools = {};
	var glBuffers = [];
	var self = this;

	// Choose floating point texture filtering depending on extension support
	var float_linear_ext = gl.getExtension("OES_texture_float_linear");
	var float_filtering = float_linear_ext ? gl.LINEAR : gl.NEAREST;
	
	// Public properties
	this.numCreatedTextures = 0;
	this.numReusedTextures = 0;
	
	// Private methods

	/**************************************************************************************************************/

	/**
		Create a new GL texture
	 */
	var createNewGLTexture = function(image,texturePool)
	{
		var glTexture = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, glTexture);
		if ( image.dataType == "byte" )
		{
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
			gl.generateMipmap(gl.TEXTURE_2D);
		}
		else
		{
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE, image.width, image.height, 0, gl.LUMINANCE, gl.FLOAT, image.typedArray);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, float_filtering);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, float_filtering);
		}

		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		glTexture.pool = texturePool;
		self.numCreatedTextures++;
		
		return glTexture;
	}

	/**************************************************************************************************************/

	/**
		Reuse a GL texture
	 */
	var reuseGLTexture = function(image,texturePool)
	{
		var glTexture = texturePool.pop();
		gl.bindTexture(gl.TEXTURE_2D, glTexture);

		if ( image.dataType == "byte" )
		{
			//gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, image);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
			gl.generateMipmap(gl.TEXTURE_2D);
		}
		else
		{
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE, image.width, image.height, 0, gl.LUMINANCE, gl.FLOAT, image.typedArray);
		}

		self.numReusedTextures++;
		
		return glTexture;
	};
	
	/**
	 * Get or create a texture pool for the given image
	 */
	var getOrCreateTexturePool = function(image) 
	{
		var key = image.dataType + image.width;
		if (!glTexturePools[key])
		{
			glTexturePools[key] = [];
		}
		return glTexturePools[key];
	};
		
	// Public methods
	
	/**************************************************************************************************************/

	/**
		Create a GL texture to be used by a tile
	 */
	this.createGLTexture = function(image)
	{
		var texturePool = getOrCreateTexturePool(image);

		if ( texturePool.length > 0 )
		{
			return reuseGLTexture(image,texturePool);
		}
		else
		{
			return createNewGLTexture(image,texturePool);
		}
	};

	/**************************************************************************************************************/

	/**
		Create a GL texture to be used by a tile
	 */
	this.createGLBuffer = function(vertices)
	{
		var vb;
		if ( glBuffers.length > 0 )
		{
			vb = glBuffers.pop();
		}
		else
		{
			vb = gl.createBuffer();
		}
		gl.bindBuffer(gl.ARRAY_BUFFER, vb);
		gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
		
		return vb;
	};

	/**************************************************************************************************************/

	/**
		Dispose a texture
	 */
	this.disposeGLTexture = function(texture)
	{
		texture.pool.push(texture);
	}

	/**************************************************************************************************************/

	/**
		Dispose a texture
	 */
	this.disposeGLBuffer = function(buffer)
	{
		glBuffers.push(buffer);
	}

	/**************************************************************************************************************/

	/**
		Dispose all
	 */
	this.disposeAll = function()
	{
		for ( var key in glTexturePools )
		{
			if ( glTexturePools.hasOwnProperty(key) )
			{
				var glTextures = glTexturePools[key];
				for ( var i = 0;  i < glTextures.length; i++ ) 
				{
					gl.deleteTexture( glTextures[i] );
				}
			}
		}
		glTexturePools = {};
		
		for ( var i = 0;  i < glBuffers.length; i++ )
		{
			gl.deleteBuffer( glBuffers[i] );
		}
		glBuffers.length = 0;
	}

	/**************************************************************************************************************/	
};

return TilePool;

});


/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('ImageRequest',[], function(){

/** 
 *	@constructor
 *	ImageRequest constructor
 */
var ImageRequest = function(options)
{
	this.successCallback = options.successCallback;
	this.failCallback = options.failCallback;
	this.abortCallback = options.abortCallback;
	this.image = null;
}

/**************************************************************************************************************/

/**
 *	Send image request
 */
ImageRequest.prototype.send = function(url,crossOrigin)
{
	this.image = new Image();
	this.image.crossOrigin = crossOrigin;
	this.image.dataType = "byte";

	var self = this;
	this.image.onload = function(){
		var isComplete = self.image.naturalWidth != 0 && self.image.complete;
		if ( isComplete )
		{
			self.successCallback.call(self);
		}
	} 
	this.image.onerror = this.failCallback.bind(this);
	this.image.src = url;
}

/**************************************************************************************************************/

/**
 *	Abort image request
 */
ImageRequest.prototype.abort = function()
{
	if ( this.abortCallback )
	{
		this.abortCallback(this);
	}
	this.image.src = '';
}

/**************************************************************************************************************/

return ImageRequest;

});
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 define('TileRequest',['./Tile', './ImageRequest'], function(Tile, ImageRequest) {
 
/**************************************************************************************************************/

/** @constructor
	TileRequest constructor
 */
var TileRequest = function(tileManager)
{
	// Private variables
	var _imageLoaded = false;
	var _elevationLoaded = true;
	var _xhr = new XMLHttpRequest();
	var _imageRequest;

	// Public variables
	this.tile = null;
	this.elevations = null;
	this.image = null;

	var self = this;
	
	// Setup the XHR callback
	_xhr.onreadystatechange = function(e)
	{
		if ( _xhr.readyState == 4 )
		{
			if ( _xhr.status == 200 )
			{
				_handleLoadedElevation();
			}
			else
			{
				_handleErrorElevation();
			}
		}
	};
	

	/**************************************************************************************************************/

	/**
		Handle when image is loaded
	 */
	var _handleLoadedImage = function() 
	{
		// The method can be called twice when the image is in the cache (see launch())
		if (!_imageLoaded)
		{
			_imageLoaded = true;
			if ( _elevationLoaded )
			{
				// Call post-process function if defined
				if ( tileManager.imageryProvider && tileManager.imageryProvider.handleImage )
					tileManager.imageryProvider.handleImage(_imageRequest);

				tileManager.pendingRequests.splice(tileManager.pendingRequests.indexOf(self), 1);
				tileManager.completedRequests.push(self);
				tileManager.renderContext.requestFrame();
			}
			self.image = _imageRequest.image;
		}
	};

	/**************************************************************************************************************/

	/**
		Handle when loading image failed
	 */
	var _handleErrorImage = function() 
	{
		self.tile.state = Tile.State.ERROR;
		tileManager.pendingRequests.splice(tileManager.pendingRequests.indexOf(self), 1);
		tileManager.availableRequests.push(self);
	}

	/**************************************************************************************************************/

	/**
		Abort request
	 */
	var _handleAbort = function() 
	{
		self.tile.state = Tile.State.NONE;
		tileManager.pendingRequests.splice(tileManager.pendingRequests.indexOf(self), 1);
		tileManager.availableRequests.push(self);
	}

	/**************************************************************************************************************/

	/**
		Handle when elevation is loaded
	 */
	var _handleLoadedElevation = function() 
	{
		self.elevations = tileManager.elevationProvider.parseElevations(_xhr.responseText);	
		_elevationLoaded = true;
		
		if ( _imageLoaded )
		{
			tileManager.pendingRequests.splice(tileManager.pendingRequests.indexOf(self), 1);
			tileManager.completedRequests.push(self);
			tileManager.renderContext.requestFrame();
		}
	}

	/**************************************************************************************************************/

	/**
		Handle when loading elevation failed
	 */
	var _handleErrorElevation = function() 
	{
		self.elevations = null;
		_elevationLoaded = true;
		
		if ( _imageLoaded )
		{
			tileManager.pendingRequests.splice(tileManager.pendingRequests.indexOf(self), 1);
			tileManager.completedRequests.push(self);
			tileManager.renderContext.requestFrame();
		}
	}

	/**************************************************************************************************************/

	/**
		Launch the HTTP request for a tile
	 */
	this.launch = function(tile)
	{
		tile.state = Tile.State.LOADING;
		this.tile = tile;
		tileManager.pendingRequests.push(this);
		
		this.image = null;
		this.elevations = null;
		
		// Request the elevation if needed
		if ( tileManager.elevationProvider )
		{
			// TODO : handle the elevations coming from cache
			_elevationLoaded = false;
			_xhr.open("GET", tileManager.elevationProvider.getUrl(tile) );

			// Set withCredentials property after "open": http://stackoverflow.com/questions/19666809/cors-withcredentials-support-limited?answertab=votes#tab-top
			var useCredentials = tileManager.elevationProvider.crossOrigin == 'use-credentials';
			_xhr.withCredentials = useCredentials;

			_xhr.send();
		}
		else
		{
			_elevationLoaded = true;
		}
		
		if ( tileManager.imageryProvider )
		{
			if (!_imageRequest)
			{
				_imageRequest = new ImageRequest({
					successCallback: function() {
						_handleLoadedImage();
						if ( tileManager.imageryProvider.cache )
						{
							tileManager.imageryProvider.cache.storeInCache( self );
						}
					},
					failCallback: _handleErrorImage,
					abortCallback: _handleAbort
				});
			}
			
			// Check if the image isn't already loaded in cache
			var cachedTileRequest;
			if ( tileManager.imageryProvider.cache )
			{
				cachedTileRequest = cachedTileRequest = tileManager.imageryProvider.cache.getFromCache(tile);
			}
			
			_imageLoaded = false;
			if ( cachedTileRequest )
			{
				_imageRequest.image = cachedTileRequest.image;
				_handleLoadedImage();
			}
			else
			{
				// Tile not found in cache or cache isn't activated, send the request
				_imageRequest.send( tileManager.imageryProvider.getUrl(tile), tileManager.imageryProvider.crossOrigin );
			}

		}
		else
		{
			_imageLoaded = true;
		}
		
		// Check if there is nothing to load
		if ( !tileManager.imageryProvider && !tileManager.elevationProvider )
		{
			tileManager.pendingRequests.splice(tileManager.pendingRequests.indexOf(this), 1);
			tileManager.completedRequests.push(this);
		}
	};

	/**************************************************************************************************************/

	/**
	 *	Abort launched request
	 */
	this.abort = function() {
		if (_imageRequest) {
			_imageRequest.abort();
		}
	}
	
};

/**************************************************************************************************************/

return TileRequest;

});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 define('TileIndexBuffer',[],function() {
 
/**************************************************************************************************************/

/** 
	@constructor TileIndexBuffer
	TileIndexBuffer
 */
var TileIndexBuffer = function( renderContext, config )
{
	this.renderContext = renderContext;
	this.config = config;
	this.solidIndexBuffer = null;
	this.subSolidIndexBuffer = [ null, null, null, null ];
	this.subIndices = [ null, null, null, null ];
}

/**************************************************************************************************************/

/**  
 * Reset the index buffers.
 */
TileIndexBuffer.prototype.reset = function()
{	
	var gl = this.renderContext.gl;
	for ( var i=0; i < 4; i++ )
	{
		if ( this.subSolidIndexBuffer[i] )
		{
			gl.deleteBuffer( this.subSolidIndexBuffer[i] );
			this.subSolidIndexBuffer[i] = null;
		}
	}
	if ( this.solidIndexBuffer )
	{
		gl.deleteBuffer( this.solidIndexBuffer );
		this.solidIndexBuffer = null;
	}
}

/**************************************************************************************************************/

/**
 *	Get index buffer for sub solid
 */
TileIndexBuffer.prototype.getSubSolid = function(ii)
{
	if ( this.subSolidIndexBuffer[ii] == null )
	{
		var i = ii % 2;
		var j = Math.floor( ii / 2 );
		
		var size = this.config.tesselation;
		var halfTesselation = (size-1) / 2;
		
		// Build the sub grid for 'inside' tile
		var indices = [];
		for ( var n=halfTesselation*j; n < halfTesselation*(j+1); n++)
		{
			for ( var k=halfTesselation*i; k < halfTesselation*(i+1); k++)
			{
				indices.push( n * size + k );
				indices.push( (n+1) * size + k );
				indices.push( n * size + k + 1 );
				
				indices.push( n * size + k + 1 );
				indices.push( (n+1) * size + k );
				indices.push( (n+1) * size + k + 1 );
			}
		}
		
		this.subIndices[ii] = indices;

		if (this.config.skirt)
		{
			// Build skirts
			// Top skirt
			var start = (j == 0) ? size * size : size * size + 4 * size;
			var src = (j == 0) ? 0 : halfTesselation * size;
			for ( var n = halfTesselation*i; n < halfTesselation*(i+1); n++)
			{
				indices.push( start + n );
				indices.push( src + n );
				indices.push( start + n + 1 );
				
				indices.push( start + n + 1 );
				indices.push( src + n );
				indices.push( src + n + 1 );
			}
		
			// Bottom skirt
			start = (j == 0) ? size * size + 4 * size : size * size + size;
			src = (j == 0) ? halfTesselation * size : (size-1) * size;
			for ( var n = halfTesselation*i; n < halfTesselation*(i+1); n++)
			{
				indices.push( src + n );
				indices.push( start + n );
				indices.push( src + n + 1 );
				
				indices.push( src + n + 1 );
				indices.push( start + n );
				indices.push( start + n + 1 );
			}
				
			// Left skirt
			start = (i == 0) ? size * size + 2 * size : size * size + 5 * size;
			src = (i == 0) ? 0 : halfTesselation;
			for ( var k=halfTesselation*j; k < halfTesselation*(j+1); k++)
			{
				indices.push( start + k );
				indices.push( start + k + 1 );
				indices.push( src + k * size );
				
				indices.push( src + k * size );
				indices.push( start + k + 1);
				indices.push( src + (k+1) * size );
			}
			
			// Right skirt
			start = (i == 0) ? size * size + 5 * size : size * size + 3 * size;
			src = (i == 0) ? halfTesselation : size - 1;
			for ( var k=halfTesselation*j; k < halfTesselation*(j+1); k++)
			{
				indices.push( k * size + src );
				indices.push( (k+1) * size + src );
				indices.push( start + k );
				
				indices.push( start + k );
				indices.push( (k+1) * size + src );
				indices.push( start + k + 1 );
			}
		}
		
		var gl = this.renderContext.gl;
		var ib = gl.createBuffer();
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ib);
		gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
		ib.numIndices = indices.length;
		this.subSolidIndexBuffer[ii] = ib;
	}
	
	return this.subSolidIndexBuffer[ii];
}

/**************************************************************************************************************/

/*
	Build index buffer
 */
TileIndexBuffer.prototype.getSolid = function()
{
	if ( this.solidIndexBuffer == null )
	{
		var size = this.config.tesselation;
		var indices = [];
		// Build the grid
		for ( var j=0; j < size-1; j++)
		{
			for ( var i=0; i < size-1; i++)
			{
				indices.push( j * size + i );
				indices.push( (j+1) * size + i );
				indices.push( j * size + i + 1 );
				
				indices.push( j * size + i + 1 );
				indices.push( (j+1) * size + i );
				indices.push( (j+1) * size + i + 1 );
			}
		}
		
		if (this.config.skirt)
		{
			// Top skirt
			var start = size * size;
			for ( var i = 0; i < size-1; i++)
			{
				indices.push( start + i );
				indices.push( i );
				indices.push( start + i + 1 );
				
				indices.push( start + i + 1 );
				indices.push( i );
				indices.push( i + 1 );
			}
			
			// Bottom skirt
			start += size;
			for ( var i=0; i < size-1; i++)
			{
				indices.push( (size-1) * size + i );
				indices.push( start + i );
				indices.push( (size-1) * size + i + 1 );
				
				indices.push( (size-1) * size + i + 1 );
				indices.push( start + i );
				indices.push( start + i + 1 );
			}
				
			// Left skirt
			start += size;
			for ( var j=0; j < size-1; j++)
			{
				indices.push( start + j );
				indices.push( start + j + 1 );
				indices.push( j * size );
				
				indices.push( j * size );
				indices.push( start + j + 1);
				indices.push( (j+1) * size );
			}

			// Right skirt
			start += size;
			for ( var j=0; j < size-1; j++)
			{
				indices.push( j * size + size - 1 );
				indices.push( (j+1) * size + size - 1 );
				indices.push( start + j );
				
				indices.push( start + j );
				indices.push( (j+1) * size + size - 1 );
				indices.push( start + j + 1 );
			}
		}
		
		var gl = this.renderContext.gl;
		var ib = gl.createBuffer();
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ib);
		gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
		this.numIndices = indices.length;
		
		this.solidIndexBuffer = ib;
		this.solidIndexBuffer.numIndices = indices.length;
	}
	
	return this.solidIndexBuffer;
}

/**************************************************************************************************************/

return TileIndexBuffer;

});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 define('Program',[],function() {

/**************************************************************************************************************/

/** @constructor
	Program constructor
 */
var Program = function(renderContext)
{
	this.renderContext = renderContext;
    this.glProgram = null;
    this.attributes = {};
    this.uniforms = {};
	this.numActiveAttribArray = 0;
}

/**************************************************************************************************************/

/**
  Creates a shader of the given type from the given source string
*/
Program.prototype.createShader = function(type, source)
{
	var gl = this.renderContext.gl;
    var shader = gl.createShader(type);
    gl.shaderSource(shader, source);
	gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))
    {
		console.log("Shader compilation error: " + gl.getShaderInfoLog(shader));
		console.log(source);
		gl.deleteShader(shader);
        return null;
    }

    return shader;
}

/**************************************************************************************************************/

/**
	Create the program from source shaders
 */
Program.prototype.createFromSource = function(vertexSource, fragmentSource)
{
	var gl = this.renderContext.gl;
	
    //  Create the gl shaders from the source
    var vertexShader = this.createShader(gl.VERTEX_SHADER, vertexSource);
    var fragmentShader = this.createShader(gl.FRAGMENT_SHADER, fragmentSource);
    if (vertexShader == null || fragmentShader == null)
    {
		return false;
    }
	
	// Create the program and attach the shaderss
	this.glProgram = gl.createProgram();
	gl.attachShader(this.glProgram, vertexShader);
	gl.attachShader(this.glProgram, fragmentShader);

	// Link and test the program is ok
	gl.linkProgram(this.glProgram);
    if (!gl.getProgramParameter(this.glProgram, gl.LINK_STATUS)) 
    {
        console.log("Program link error: " + gl.getProgramInfoLog(this.glProgram));
		gl.deleteShader(vertexShader);
		gl.deleteShader(fragmentShader);
		gl.deleteProgram(this.glProgram);
		this.glProgram = null;
        return false;
    }

    // Get vertex attributes used in the program, stored them in an attributes object
    var attributeCount = gl.getProgramParameter(this.glProgram, gl.ACTIVE_ATTRIBUTES);
	this.numActiveAttribArray = 0;
    for (var i = 0; i < attributeCount; ++i)
    {
        var attribute = gl.getActiveAttrib(this.glProgram, i);
		var loc = gl.getAttribLocation(this.glProgram,attribute.name);
        this.attributes[attribute.name] = loc;
		
		if ( loc + 1 > this.numActiveAttribArray )
		{
			this.numActiveAttribArray = loc + 1;
		}
    }

    // Get uniforms used in the program, stored them in an uniforms object
    var uniformCount = gl.getProgramParameter(this.glProgram, gl.ACTIVE_UNIFORMS);
    for (var i = 0; i < uniformCount; ++i)
    {
        var uniform = gl.getActiveUniform(this.glProgram, i);
        this.uniforms[uniform.name] = gl.getUniformLocation(this.glProgram,uniform.name);
    }

    return true;
}

/**************************************************************************************************************/

/*
	Load from file (must be located on the server)
 */
Program.prototype.loadFromFile = function(vertexFile, fragmentFile)
{
    var xhr = new XMLHttpRequest;
	xhr.open("get", this.renderContext.shadersPath + vertexFile, false);
	xhr.send(null);
    var vertexSource = xhr.responseText;
	xhr.open("get", this.renderContext.shadersPath +  fragmentFile, false);
	xhr.send(null);
    var fragmentSource = xhr.responseText;
    
    return this.createFromSource(vertexSource, fragmentSource);
}

/**************************************************************************************************************/

/*
	Apply the programs
 */
Program.prototype.apply = function()
{
	var rc = this.renderContext;
	var gl =  rc.gl;
	
    // Bind program
	gl.useProgram(this.glProgram);
    
	for ( var i = rc.numActiveAttribArray;
		i < this.numActiveAttribArray; i++ )
	{
		gl.enableVertexAttribArray(i);
	}
	for ( var i = this.numActiveAttribArray;
		i < rc.numActiveAttribArray; i++ )
	{
		gl.disableVertexAttribArray(i);
	}
	rc.numActiveAttribArray = this.numActiveAttribArray;
}

/**************************************************************************************************************/

/**
	Dispose the program
 */
Program.prototype.dispose = function()
{
	this.renderContext.gl.deleteProgram(this.glProgram);
}

/**************************************************************************************************************/

/*
	Load shader using Http request
 */
// Program.prototype.loadShader = function (shader, type, callback) 
// {
//     function onreadystatechange() {
//         var xhr = this;
//         if (xhr.readyState == 4) {
//             shader =  gl.createShader(type);
//              gl.shaderSource(shader, xhr.responseText);
//              gl.compileShader(shader);
//             if (! gl.getShaderParameter(shader,  gl.COMPILE_STATUS))
//                 throw  gl.getShaderInfoLog(shader)
//             ;
//             !--length && typeof callback == "function" && callback(shader);
//         }
//     }
	
// 	var asynchronous = !!callback;
// 	xhr = new XMLHttpRequest;
// 	xhr.open("get", shader, asynchronous);
// 	if (asynchronous) 
// 	{
// 		xhr.onreadystatechange = onreadystatechange;
// 	}
// 	xhr.send(null);
// 	onreadystatechange.call(xhr);
		
//     return shader;
// }

/**************************************************************************************************************/


/*
	Get the shader using defined in HTML
 */
// Program.prototype.getShader = function(id)
//  {
// 	var shaderScript = document.getElementById(id);
// 	if (!shaderScript) {
// 		return null;
// 	}

// 	var str = "";
// 	var k = shaderScript.firstChild;
// 	while (k) {
// 		if (k.nodeType == 3) {
// 			str += k.textContent;
// 		}
// 		k = k.nextSibling;
// 	}

// 	var shader;
// 	if (shaderScript.type == "x-shader/x-fragment") {
// 		shader = RenderContext.gl.createShader(RenderContext.gl.FRAGMENT_SHADER);
// 	} else if (shaderScript.type == "x-shader/x-vertex") {
// 		shader = RenderContext.gl.createShader(RenderContext.gl.VERTEX_SHADER);
// 	} else {
// 		return null;
// 	}

// 	RenderContext.gl.shaderSource(shader, str);
// 	RenderContext.gl.compileShader(shader);

// 	if (!RenderContext.gl.getShaderParameter(shader, RenderContext.gl.COMPILE_STATUS)) {
// 		alert(RenderContext.gl.getShaderInfoLog(shader));
// 		return null;
// 	}

// 	return shader;
// }

/**************************************************************************************************************/

return Program;

});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('TileManager',['./Tile', './GeoTiling','./TilePool', './TileRequest', './TileIndexBuffer', './Program'],
	function (Tile, GeoTiling, TilePool, TileRequest, TileIndexBuffer, Program) {

/** @constructor
	TileManager constructor
	
	Take in parameters its parent : can be a globe or a sky
 */
var TileManager = function( parent, options )
{
	this.parent = parent;
	this.renderContext = this.parent.renderContext;
	// Create a new tile pool or use the one from the parent
	this.tilePool = parent.tilePool || new TilePool(this.renderContext);
	this.tiling = new GeoTiling( 4, 2 ); // Use geo tiling by default

	this.imageryProvider = null;
	this.elevationProvider = null;
	this.tilesToRender = [];
	this.visibleTiles = [];
	this.tilesToRequest = [];
	this.postRenderers = [];

	// Init default texture
	var gl = this.renderContext.gl;
	this.defaultTexture = gl.createTexture();
	gl.bindTexture(gl.TEXTURE_2D, this.defaultTexture);
	var defaultColor = options.defaultColor ? options.defaultColor : [200,200,200,255];
	var pixel = new Uint8Array(defaultColor);
	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, 
	              gl.RGBA, gl.UNSIGNED_BYTE, pixel);
	
	// Tile requests : limit to 4 at a given time
	this.maxRequests = 4;
	this.availableRequests = [];
	for ( var i=0; i < this.maxRequests; i++ )
	{
		this.availableRequests[i] = new TileRequest(this);
	}
	this.pendingRequests = [];
	this.completedRequests = [];
				
	this.level0TilesLoaded = false;
	
	// Configuration for tile
	this.tileConfig = {
		tesselation: 9,
		skirt: true,
		cullSign: 1.0,
		imageSize: 256,
		vertexSize: this.renderContext.lighting ? 6 : 3, 
		normals: this.renderContext.lighting,
		coordinateSystem: this.parent.coordinateSystem
	};
	this.level0Tiles = this.tiling.generateLevelZeroTiles(this.tileConfig,this.tilePool);
		
	// Shared index and texture coordinate buffer : all tiles uses the same
	this.tcoordBuffer = null;
	this.tileIndexBuffer = new TileIndexBuffer(this.renderContext,this.tileConfig);

	// HACK : to fix sky rendering
	this.renderTileWithoutTexture = options.hasOwnProperty('renderTileWithoutTexture') ? options.renderTileWithoutTexture : true;

	// For debug
	this.freeze = false;

	// Stats
	this.numTilesGenerated = 0;
	this.frameNumber = 0;

	this.vertexShader = "\
	attribute vec3 vertex;\n\
	attribute vec2 tcoord;\n\
	uniform mat4 modelViewMatrix;\n\
	uniform mat4 projectionMatrix;\n\
	varying vec2 texCoord;\n";
	if ( this.renderContext.lighting )
		this.vertexShader += "attribute vec3 normal;\nvarying vec3 color;\n";
	this.vertexShader += "\
	void main(void) \n\
	{\n\
		gl_Position = projectionMatrix * modelViewMatrix * vec4(vertex, 1.0);\n";
	if ( this.renderContext.lighting )
		this.vertexShader += "vec4 vn = modelViewMatrix * vec4(normal,0);\ncolor = max( vec3(-vn[2],-vn[2],-vn[2]), 0.0 );\n";
	this.vertexShader += "\
		texCoord = tcoord;\n\
	}\n\
	";

	this.fragmentShader = "\
	precision lowp float; \n\
	varying vec2 texCoord;\n";
	if ( this.renderContext.lighting )
		this.fragmentShader += "varying vec3 color;\n";
	this.fragmentShader += "\
	uniform sampler2D colorTexture;\n\
	void main(void)\n\
	{\n\
		gl_FragColor.rgb = texture2D(colorTexture, texCoord).rgb;\n";
	if ( this.renderContext.lighting )
		this.fragmentShader += "gl_FragColor.rgb *= color;\n";
	this.fragmentShader += "\
		gl_FragColor.a = 1.0;\n\
	}\n\
	";
	
	this.program = new Program(this.renderContext);
	this.program.createFromSource( this.vertexShader, this.fragmentShader );
}

/**************************************************************************************************************/

/** 
	Add post renderer
 */
TileManager.prototype.addPostRenderer = function(renderer)
{	
	this.postRenderers.push( renderer );
	
	this.postRenderers.sort( function(r1,r2) {
		var z1 = r1.zIndex | 0;
		var z2 = r2.zIndex | 0;
		return z1 - z2;
	});
	
	if ( renderer.generate )
	{
		this.visitTiles( function(tile) {
		
			renderer.generate(tile);
		} );
	}
}

/**************************************************************************************************************/

/** 
	Remove a post renderer
 */
TileManager.prototype.removePostRenderer = function(renderer)
{
	var rendererIndex = this.postRenderers.indexOf(renderer);
	if ( rendererIndex != -1 )
	{
		// Remove the renderer from all the tiles if it has a cleanupTile method
		if ( renderer.cleanupTile )
			this.visitTiles( function(tile) { renderer.cleanupTile(tile); } );
			
		// Remove renderer from the list
		this.postRenderers.splice( rendererIndex, 1 );
	}
}

/**************************************************************************************************************/

/** 
	Set the imagery provider to be used
 */
TileManager.prototype.setImageryProvider = function(ip)
{
	this.reset();
	this.imageryProvider = ip;
	
	if (ip)
	{
		// Clean tile pool
		this.tilePool.disposeAll();
		
		this.tiling = ip.tiling;

		// Rebuild level zero tiles
		this.tileConfig.imageSize = ip.tilePixelSize;
		this.level0Tiles = this.tiling.generateLevelZeroTiles(this.tileConfig,this.tilePool);

		// Update program
		if ( ip.customShader )
		{
			this.program.dispose();
			this.program = new Program(this.renderContext);

			// Memorize current fragment shader
			this.currentFragmentShader = ip.customShader.fragmentCode ? ip.customShader.fragmentCode : this.fragmentShader;
			this.program.createFromSource( ip.customShader.vertexCode ? ip.customShader.vertexCode : this.vertexShader,
											this.currentFragmentShader );
		}
		else
		{	
			// Revert to default if needed
			if ( this.currentFragmentShader != null )
			{
				this.program.dispose();
				this.program = new Program(this.renderContext);
				this.program.createFromSource( this.vertexShader, this.fragmentShader );
				this.currentFragmentShader = null;
			}
		}
	}
}

/**************************************************************************************************************/

/** 
	Set the elevation provider to be used
 */
TileManager.prototype.setElevationProvider = function(tp)
{	
	this.reset();
	this.elevationProvider = tp;
	
	var newTesselation = tp ? tp.tilePixelSize : 9;
	if ( newTesselation != this.tileConfig.tesselation )
	{
		this.tileConfig.tesselation = newTesselation;
		
		// Reset the shared buffers : texture coordinate and indices
		var gl = this.renderContext.gl;
		this.tileIndexBuffer.reset();
		gl.deleteBuffer( this.tcoordBuffer );
		this.tcoordBuffer = null;
	}
}

/**************************************************************************************************************/

/**
	Reset the tile manager : unload all tiles
 */
TileManager.prototype.reset = function()
{
	// Abort all pending requests
	this.abortRequests();

	// Reset all level zero tiles : destroy render data, and reset state to NONE
	for (var i = 0; i < this.level0Tiles.length; i++)
	{
		this.level0Tiles[i].deleteChildren(this.renderContext,this.tilePool);
		this.level0Tiles[i].dispose(this.renderContext,this.tilePool);
	}
	
	this.level0TilesLoaded = false;
}

/**************************************************************************************************************/

/**
 *	Abort all pending requests
 */
TileManager.prototype.abortRequests = function()
{
	for ( var i=this.pendingRequests.length-1; i>=0; i-- )
	{
		this.pendingRequests[i].abort();
	}
}

/**************************************************************************************************************/

/** 
	Tile visitor
 */
TileManager.prototype.visitTiles = function( callback )
{
	// Store the tiles to process in an array, first copy level0 tiles
	var tilesToProcess = this.level0Tiles.concat([]);
	
	while( tilesToProcess.length > 0 )
	{
		// Retreive the first tile and remove it from the array
		var tile = tilesToProcess.shift();
		
		callback( tile );
		
		// Add tile children to array to be processed later
		if ( tile.children )
		{
			tilesToProcess.push( tile.children[0] );
			tilesToProcess.push( tile.children[1] );
			tilesToProcess.push( tile.children[2] );
			tilesToProcess.push( tile.children[3] );
		}
	}
}

/**************************************************************************************************************/

/**
	Traverse tiless tiles
 */
 TileManager.prototype.traverseTiles = function()
 {		
	this.tilesToRender.length = 0;
	this.visibleTiles.length = 0;
	this.tilesToRequest.length = 0;
	this.numTraversedTiles = 0;
	
	// First load level 0 tiles if needed
	if ( !this.level0TilesLoaded )
	{
		this.level0TilesLoaded = true;
		for ( var i = 0; i < this.level0Tiles.length; i++ )
		{
			var tile = this.level0Tiles[i];

			var tileIsLoaded = tile.state == Tile.State.LOADED;
			
			// Update frame number
			tile.frameNumber = this.frameNumber;
			
			this.level0TilesLoaded = this.level0TilesLoaded && tileIsLoaded;
			if ( !tileIsLoaded )
			{		
				// Request tile if necessary
				if ( tile.state == Tile.State.NONE )
				{
					tile.state = Tile.State.REQUESTED;
					this.tilesToRequest.push(tile);
				}
				else if ( tile.state == Tile.State.ERROR && this.imageryProvider )
				{
					this.parent.publish("baseLayersError", this.imageryProvider);
				}
			}
		}
		if ( this.level0TilesLoaded && this.imageryProvider  )
		{
			this.parent.publish("baseLayersReady");
		}
	}
	
	// Traverse tiles
	if ( this.level0TilesLoaded )
	{
		// Normal traversal, iterate through level zero tiles and process them recursively
		for ( var i = 0; i < this.level0Tiles.length; i++ )
		{
			var tile = this.level0Tiles[i];
			if ( !tile.isCulled(this.renderContext) )
			{
				this.processTile(tile,0);
			}
			else 
			{
				// Delete its children
				tile.deleteChildren(this.renderContext,this.tilePool);
			}
		}
	}
}

/**************************************************************************************************************/

/**
	Process a tile
 */
TileManager.prototype.processTile = function(tile,level)
{
	this.numTraversedTiles++;
	
	// Update frame number
	tile.frameNumber = this.frameNumber;
	
	var isLeaf = true;

	// Request the tile if needed
	if ( tile.state == Tile.State.NONE )
	{
		tile.state = Tile.State.REQUESTED;
		
		// Add it to the request
		this.tilesToRequest.push(tile);
	}
		
	// Check if the tiles needs to be refined
	// We only refine loaded tile
	if ( tile.state == Tile.State.LOADED  )
	{
		if ( this.imageryProvider )
		{
			isLeaf = level >= this.imageryProvider.numberOfLevels;
		}
		else
		{
			isLeaf = false;
		}
		
		isLeaf |= !tile.needsToBeRefined( this.renderContext );
	}
	
	if ( isLeaf )
	{
		// Push the tiles to render only if the texture is valid or there is no imagery provider defined
		if ( tile.texture || this.renderTileWithoutTexture )
		{
			this.tilesToRender.push( tile );
		}
		this.visibleTiles.push( tile );
	}
	else
	{
		// Create the children if needed
		if ( tile.children == null )
		{
			tile.createChildren();
		}
		
		for ( var i = 0; i < 4; i++ )
		{
			if (!tile.children[i].isCulled(this.renderContext))
			{
				this.processTile(tile.children[i],level+1);
			}
			else
			{
				tile.children[i].deleteChildren(this.renderContext,this.tilePool);
			}
		}
	}
	
	// Traverse extension
	for ( var x in tile.extension ) 
	{
		var e = tile.extension[x];
		if ( e.traverse ) e.traverse(tile,isLeaf);
	}
}

/**************************************************************************************************************/

/**
 	Generate tile
 */
TileManager.prototype.generateTile = function(tile, tileRequest)
{
	// Generate the tile using data from tileRequest if defined
	tile.generate( this.tilePool, tileRequest.image, tileRequest.elevations );

	// Now post renderers can generate their data on the new tile
	for (var i=0; i < this.postRenderers.length; i++ )
	{
		if ( this.postRenderers[i].generate )
			this.postRenderers[i].generate( tile );
	}
	
	this.numTilesGenerated++;
	this.renderContext.requestFrame();
}

/**************************************************************************************************************/

/**
	Generate tiles
 */
 TileManager.prototype.generateReceivedTiles = function()
 {
	while ( this.completedRequests.length > 0 )
	{
		var tileRequest = this.completedRequests.pop();
		var tile = tileRequest.tile;
		if ( tile.frameNumber == this.frameNumber )
		{
			this.generateTile( tile, tileRequest );
		}
		else
		{
			tile.state = Tile.State.NONE;			
		}
		this.availableRequests.push(tileRequest);
	}
	
	// All requests have been processed, send endBackgroundLoad event
	if ( this.availableRequests.length == this.maxRequests && this.imageryProvider )
		this.parent.publish("endBackgroundLoad");

}

/**************************************************************************************************************/

/**
	Render tiles
 */
 TileManager.prototype.renderTiles = function()
 {
	var rc = this.renderContext;
	var gl = rc.gl;
	
	// Compute near/far from tiles
	var nr;
	var fr;
	if ( this.tileConfig.cullSign < 0 )
	{
		// When in "Astro" mode, do not compute near/far from tiles not really needed
		// And the code used for "Earth" does not works really well, when the earth is seen from inside...
		nr = 0.2 * this.tileConfig.coordinateSystem.radius;
		fr = 1.1 * this.tileConfig.coordinateSystem.radius;
	}
	else
	{
		nr = 1e9;
		fr = 0.0;
		for ( var i = 0; i < this.visibleTiles.length; i++ )
		{
			var tile = this.visibleTiles[i];
			// Update near/far to take into account the tile
			nr = Math.min( nr, tile.distance - 1.5 * tile.radius );
			fr = Math.max( fr, tile.distance + 1.5 * tile.radius );
		}
	}
	rc.near = Math.max( rc.minNear, nr );
	rc.far = Math.max( rc.minFar, fr );

	if ( this.tilesToRender.length != 0 )
	{
		// Set state (depends if geo or astro)
		if ( this.tileConfig.cullSign < 0 )
		{
			gl.depthMask(false);
			gl.disable(gl.DEPTH_TEST);
			gl.disable(gl.CULL_FACE);
		}
		else
		{
			gl.enable(gl.POLYGON_OFFSET_FILL);
			gl.polygonOffset(0,4);
		}
		
		// Check if the program of imagery provider changed
		// Only for fragment shader for now
		if ( this.currentFragmentShader && this.currentFragmentShader != this.imageryProvider.customShader.fragmentCode )
		{
			this.program.dispose();
			this.program = new Program(this.renderContext);

			if ( this.imageryProvider && this.imageryProvider.customShader )
			{
				this.currentFragmentShader = this.imageryProvider.customShader.fragmentCode ? this.imageryProvider.customShader.fragmentCode : this.fragmentShader;
				this.program.createFromSource( this.imageryProvider.customShader.vertexShader ? this.imageryProvider.customShader.vertexShader : this.vertexShader,
											   this.currentFragmentShader );
			}
		}

		// Setup program
		this.program.apply();
		
		var attributes = this.program.attributes;
			
		// Update projection matrix with new near and far values
		mat4.perspective(rc.fov, rc.canvas.width / rc.canvas.height, rc.near, rc.far, rc.projectionMatrix);

		// Update uniforms if needed
		if ( this.imageryProvider && this.imageryProvider.customShader )
			this.imageryProvider.customShader.updateUniforms(gl, this.program);

		// Setup state
		gl.activeTexture(gl.TEXTURE0);
		gl.uniformMatrix4fv(this.program.uniforms["projectionMatrix"], false, rc.projectionMatrix);
		gl.uniform1i(this.program.uniforms["colorTexture"], 0);
		
		// Bind the texture coordinate buffer (shared between all tiles
		if ( !this.tcoordBuffer )
			this.buildSharedTexCoordBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, this.tcoordBuffer);
		gl.vertexAttribPointer(attributes['tcoord'], 2, gl.FLOAT, false, 0, 0);
		
		var currentIB = null;
		
		for ( var i = 0; i < this.tilesToRender.length; i++ )
		{
			var tile = this.tilesToRender[i];
			
			var isLoaded = ( tile.state == Tile.State.LOADED );
			var isLevelZero = ( tile.parentIndex == -1 );
			
			// Bind tile texture if defined, the default texture otherwise
			if ( tile.texture )
			{
				gl.bindTexture(gl.TEXTURE_2D, tile.texture);
			}
			else
			{
				gl.bindTexture(gl.TEXTURE_2D, this.defaultTexture);
			}

			// Update uniforms for modelview matrix
			mat4.multiply( rc.viewMatrix, tile.matrix, rc.modelViewMatrix );
			gl.uniformMatrix4fv(this.program.uniforms["modelViewMatrix"], false, rc.modelViewMatrix);
		
			// Bind the vertex buffer
			gl.bindBuffer(gl.ARRAY_BUFFER, tile.vertexBuffer);
			gl.vertexAttribPointer(attributes['vertex'], 3, gl.FLOAT, false, 4*this.tileConfig.vertexSize, 0);
			if (this.tileConfig.normals)
				gl.vertexAttribPointer(attributes['normal'], 3, gl.FLOAT, false, 4*this.tileConfig.vertexSize, 12);
					
			var indexBuffer = ( isLoaded || isLevelZero ) ? this.tileIndexBuffer.getSolid() : this.tileIndexBuffer.getSubSolid(tile.parentIndex);
			// Bind the index buffer only if different (index buffer is shared between tiles)
			if ( currentIB != indexBuffer )
			{	
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
				currentIB = indexBuffer;
			}
			
			// Finally draw the tiles
			gl.drawElements(gl.TRIANGLES, currentIB.numIndices, gl.UNSIGNED_SHORT, 0);
		}
		
		if ( this.tileConfig.cullSign < 0 )
		{
			gl.depthMask(true);
			gl.enable(gl.DEPTH_TEST);
		}
		else		
		{
			gl.disable(gl.POLYGON_OFFSET_FILL);
		}
	}
	
	for (var i=0; i < this.postRenderers.length; i++ )
	{
		this.postRenderers[i].render( this.visibleTiles );
	}
}

// Internal function to sort tiles
var _sortTilesByDistance = function(t1,t2)
{
	return t1.distance - t2.distance;
};

/**************************************************************************************************************/

/**
	Request tiles
 */
 TileManager.prototype.launchRequests = function()
 {
	// Process request
	this.tilesToRequest.sort( _sortTilesByDistance );
	
	var trl = this.tilesToRequest.length; 
	for ( var i = 0; i < trl; i++ )
	{
		var tile = this.tilesToRequest[i];
		if ( this.availableRequests.length > 0 ) // Check to limit the number of requests done per frame
		{
			// First launch request, send an event
			if ( this.availableRequests.length == this.maxRequests && this.imageryProvider )
				this.parent.publish("startBackgroundLoad");
			
			var tileRequest = this.availableRequests.pop();
			tileRequest.launch( tile );
		}
		else
		{
			tile.state = Tile.State.NONE;
		}
	}
}

/**************************************************************************************************************/

/**
	Render the tiles
 */
TileManager.prototype.render = function()
{
	if ( this.imageryProvider && !this.imageryProvider._ready )
	{
		return;
	}
	
	// Specific case when the image provider has a level zero image : generate the texture for each level zero tile
	if ( !this.level0TilesLoaded && this.imageryProvider && this.imageryProvider.levelZeroImage )
	{
		this.imageryProvider.generateLevel0Textures( this.level0Tiles, this.tilePool );
		
		for (var n = 0; n < this.level0Tiles.length; n++ )
		{
			var tile = this.level0Tiles[n];
			// Generate the tile without tile request
			this.generateTile( tile, {} );
		}

		this.level0TilesLoaded = true;

		this.parent.publish("baseLayersReady");
	}

	var stats = this.renderContext.stats;
	
	if (!this.freeze)
	{
		if (stats) stats.start("traverseTime");
		this.traverseTiles();
		if (stats) stats.end("traverseTime");
	}

	if ( this.level0TilesLoaded || !this.imageryProvider )
	{
		if (stats) stats.start("renderTime");
		this.renderTiles();
		if (stats) stats.end("renderTime");
	}
	
	if (stats) stats.start("generateTime");
	this.generateReceivedTiles();
	if (stats) stats.end("generateTime");
	
	if (stats) stats.start("requestTime");
	this.launchRequests();
	if (stats) stats.end("requestTime");
		
	this.frameNumber++;
}

/**************************************************************************************************************/

/**
	Returns visible tile for given longitude/latitude, null otherwise
 */
TileManager.prototype.getVisibleTile = function(lon, lat)
{
	return this.tiling.findInsideTile(lon, lat, this.visibleTiles);
}

/**************************************************************************************************************/

/**
	Build shared texture coordinate buffer
 */
TileManager.prototype.buildSharedTexCoordBuffer = function()
{
	var size = this.tileConfig.tesselation;
	var skirt = this.tileConfig.skirt;
	var bufferSize = 2*size*size;
	if (skirt)
		bufferSize += 2*size*6;

	var tcoords = new Float32Array( bufferSize );

	var step = 1.0 / (size-1);
	
	var offset = 0;
	var v = 0.0;
	for ( var j=0; j < size; j++)
	{
		var u = 0.0;
		for ( var i=0; i < size; i++)
		{
			tcoords[offset] = u;
			tcoords[offset+1] = v;

			offset += 2;
			u += step;
		}
		
		v += step;
	}
	
	if ( skirt )
	{
		// Top skirt
		u = 0.0;
		v = 0.0;
		for ( var i=0; i < size; i++)
		{
			tcoords[offset] = u;
			tcoords[offset+1] = v;
			u += step;
			offset += 2;
		}
		// Bottom skirt
		u = 0.0;
		v = 1.0;
		for ( var i=0; i < size; i++)
		{
			tcoords[offset] = u;
			tcoords[offset+1] = v;
			u += step;
			offset += 2;
		}
		// Left skirt
		u = 0.0;
		v = 0.0;
		for ( var i=0; i < size; i++)
		{
			tcoords[offset] = u;
			tcoords[offset+1] = v;
			v += step;
			offset += 2;
		}
		// Right skirt
		u = 1.0;
		v = 0.0;
		for ( var i=0; i < size; i++)
		{
			tcoords[offset] = u;
			tcoords[offset+1] = v;
			v += step;
			offset += 2;
		}
		
		// Center skirt
		u = 0.0;
		v = 0.5;
		for ( var i=0; i < size; i++)
		{
			tcoords[offset] = u;
			tcoords[offset+1] = v;
			u += step;
			offset += 2;
		}
		
		// Middle skirt
		u = 0.5;
		v = 0.0;
		for ( var i=0; i < size; i++)
		{
			tcoords[offset] = u;
			tcoords[offset+1] = v;
			v += step;
			offset += 2;
		}
	}
	
	var gl = this.renderContext.gl;
	var tcb = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, tcb);
	gl.bufferData(gl.ARRAY_BUFFER, tcoords, gl.STATIC_DRAW);
	
	this.tcoordBuffer = tcb;
}

/**************************************************************************************************************/

return TileManager;

});
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define( 'VectorRendererManager',[],function() {

/**************************************************************************************************************/

/** @constructor
	VectorRenderererManager constructor
 */
var VectorRendererManager = function(globe)
{
	// Create the registered renderers
	this.renderers = [];
	for ( var i = 0; i < VectorRendererManager.factory.length; i++ )
	{
		this.renderers.push( VectorRendererManager.factory[i](globe) );
	}
	
	// The array of renderables used during rendering
	this.renderables = [];
	
	// To uniquely identify buckets created by the renderers
	this.bucketId = 0;
}

/**************************************************************************************************************/

/**
	The factory for renderers
 */
VectorRendererManager.factory = [];

/**************************************************************************************************************/

/**
	Get a renderer
 */
VectorRendererManager.prototype.getRenderer = function(geometry,style)
{
	for ( var i = 0; i < this.renderers.length; i++ )
	{
		if ( this.renderers[i].canApply(geometry.type,style) )
		{
			return this.renderers[i];
		}
	}
	
	return null;
}

/**************************************************************************************************************/

/**
 *	Generate the tile data
 */
VectorRendererManager.prototype.generate = function(tile)
{
	if ( !tile.parent )
	{
		for ( var i=0; i < this.renderers.length; i++ )
		{
			this.renderers[i].generateLevelZero(tile);
		}
	}
	else
	{
		var tileData = tile.parent.extension.renderer;
		if ( tileData )
		{
			// delete renderer created at init time
			delete tile.extension.renderer;
			
			// Now generate renderables
			for ( var i = 0; i < tileData.renderables.length; i++ )
			{
				var renderable = tileData.renderables[i];
				if ( renderable.generateChild )
				{
					renderable.generateChild( tile );
				}
			}
		}
	}
}

/**************************************************************************************************************/

/**
 	Add a geometry to the renderer
 */
VectorRendererManager.prototype.addGeometry = function(layer, geometry, style)
{
	var renderer = this.getRenderer(geometry,style);
	renderer.addGeometry(layer, geometry, style);
}

/**************************************************************************************************************/

/**
 	Remove a geometry from the renderer
 */
VectorRendererManager.prototype.removeGeometry = function(geometry,layer)
{
	var bucket = geometry._bucket;
	if ( bucket && bucket.layer == layer )
	{
		bucket.renderer.removeGeometry(geometry);
		return true;
	}
	return false;
}

/**************************************************************************************************************/

/**
	Add a geometry to a tile
 */
VectorRendererManager.prototype.addGeometryToTile = function(layer, geometry, style, tile)
{
	var renderer = this.getRenderer(geometry,style);
	renderer.addGeometryToTile(layer, geometry, style, tile);
}
	

/**************************************************************************************************************/

/**
	Remove a geometry from a tile
 */
VectorRendererManager.prototype.removeGeometryFromTile = function(geometry,tile)
{
	var bucket = geometry._bucket;
	bucket.renderer.removeGeometryFromTile(geometry,tile);
}


/**************************************************************************************************************/

/**
	Function to sort with zIndex, then bucket
 */
var renderableSort = function(r1,r2)
{
	var zdiff = r1.bucket.style.zIndex - r2.bucket.style.zIndex;
	if ( zdiff == 0 )
		return r1.bucket.id - r2.bucket.id;
	else
		return zdiff;
};

/**************************************************************************************************************/

/**
	Render all
 */
VectorRendererManager.prototype.render = function()
{
	// Add main renderables
	for ( var j = 0; j < this.renderers.length; j++ )
	{
		var buckets = this.renderers[j].buckets;
		for ( var i = 0; i < buckets.length; i++ )
		{
			if ( buckets[i].layer._visible && buckets[i].mainRenderable )
			{
				this.renderables.push( buckets[i].mainRenderable );
			}
		}
	}
	
	// Renderable sort
	this.renderables.sort( renderableSort );
	
	//var renderCall = 0;
	
	var i = 0;
	while ( i < this.renderables.length )
	{
		var j = i + 1;
		
		var currentRenderer = this.renderables[i].bucket.renderer;
		while ( j < this.renderables.length && this.renderables[j].bucket.renderer == currentRenderer )
		{
			j++;
		}
		currentRenderer.render( this.renderables, i, j );
		//renderCall++;
		
		i = j;
	}
	
	//console.log( "# of render calls "  + renderCall );
	
	this.renderables.length = 0;
}

/**************************************************************************************************************/

return VectorRendererManager;

});
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 define( 'Ray',['./glMatrix'], function() {
 
/**************************************************************************************************************/

/**
 * Ray constructor
 */
var Ray = function(orig,dir)
{
	this.orig = orig;
	this.dir = dir;
}

/**************************************************************************************************************/

 /**
  * Create a ray from a pixel
  */
Ray.createFromPixel = function( renderContext, x, y )
{
	// reverse y because (0,0) is top left but opengl's normalized
	// device coordinate (-1,-1) is bottom left
	var nx = ((x / renderContext.canvas.width) * 2.0) - 1.0;
	var ny = -(((y / renderContext.canvas.height) * 2.0) - 1.0);
	
	var tmpMat = mat4.create();
	mat4.multiply(renderContext.projectionMatrix, renderContext.viewMatrix, tmpMat);
	mat4.inverse(tmpMat);
	// Transform pos to world using inverse viewProjection matrix
	var pos3D = mat4.multiplyVec4(tmpMat, [ nx, ny, -1, 1]);
	pos3D[0] /= pos3D[3];
	pos3D[1] /= pos3D[3];
	pos3D[2] /= pos3D[3];
	
//	console.log('Old EP ' + renderContext.eyePosition );
	var inverseViewMatrix = mat4.create();
	mat4.inverse( renderContext.viewMatrix, inverseViewMatrix );
	vec3.set( [ 0.0, 0.0, 0.0 ], renderContext.eyePosition );
	mat4.multiplyVec3( inverseViewMatrix, renderContext.eyePosition );
//	console.log('New EP ' + renderContext.eyePosition );

	
	var orig = vec3.create( renderContext.eyePosition );
	var dir = vec3.subtract( pos3D, renderContext.eyePosition, vec3.create() );
	vec3.normalize(dir);
	
	return new Ray(orig,dir);
};

/**************************************************************************************************************/

 /**
  * Create a ray from an event
  */
Ray.createFromEvent = function( renderContext, event )
{
	var pos = renderContext.getXYRelativeToCanvas(event);
	return Ray.createFromPixel( pos[0], pos[1] );
};

/**************************************************************************************************************/

/**
 * Intersection object returned
 */
Ray.Intersection = function( t )
{
	this.t = t;
	this.geometry = null;
};

/**************************************************************************************************************/

 /**
  * Compute a point on the ray given its t parameter
  */
Ray.prototype.computePoint = function( t )
{
	var pt = vec3.create();
	vec3.scale( this.dir, t, pt );
	vec3.add( pt, this.orig );
	return pt;
};

/**************************************************************************************************************/

 /**
  *	Compute intersection between a plan and ray
  * @return the nearest intersection, < 0 if no intersection
  */
Ray.prototype.planeIntersect = function( pt, normal )
{
    // Assuming vectors are all normalized
    var denom = vec3.dot(normal, this.dir);
	var epsilon = 1e-6;
    if (Math.abs(denom) > epsilon) {
        var p0l0 = vec3.create();
        vec3.subtract(pt, this.orig, p0l0);
        var t = vec3.dot(p0l0, normal) / denom;
        return t;
    }
    return -1;
}

/**************************************************************************************************************/

 /**
  * Compute intersection between a sphere and ray
  * @return the nearest intersection, < 0 if no intersection
  */
Ray.prototype.sphereIntersect = function( center, radius )
{
    // cf. http://wiki.cgsociety.org/index.php/Ray_Sphere_Intersection

    var rs = vec3.subtract( this.orig, center, vec3.create() );
    // rayDirection is normalized so a = 1
    // var a = vec3.dot(rayDirection, rayDirection);
    var b = 2.0 * vec3.dot(this.dir, rs);
    var c = vec3.dot(rs, rs) - radius*radius;

    // as a == 1, discriminant = b^2 - (4*c)
    // var discr = (b*b) - (4*a*c);
    var discr = (b*b) - (4*c);
    if (discr < 0)
        return -1;

    // t0 = (-b - sqrt(discr)) / 2a, t1 = (-b + sqrt(discr)) / 2a, a == 1
    discr = Math.sqrt(discr);
    var tNear = (-b - discr) / 2;
    var tFar  = (-b + discr) / 2;
    if (tNear > tFar) // Swap t values
    {
        var tmp = tNear;
        tNear = tFar;
        tFar = tmp;
    }

    if (tFar < 0) // Hit is beyond ray origin
        return -1;
    
    return tNear < 0 ? tFar : tNear;
};

var EPS = 1e-6;

/**************************************************************************************************************/
	
 /**
  * Ray triangle intersection optimized
  */
Ray.prototype.triangleIntersectOptimized = function( verts, i0, i1, i2 )
{
	var e1x = verts[i1] - verts[i0];
	var e1y = verts[i1+1] - verts[i0+1];
	var e1z = verts[i1+2] - verts[i0+2];
	
	var e2x = verts[i2] - verts[i0];
	var e2y = verts[i2+1] - verts[i0+1];
	var e2z = verts[i2+2] - verts[i0+2];

    var px = this.dir[1] * e2z - this.dir[2] * e2y;
	var py = this.dir[2] * e2x - this.dir[0] * e2z;
    var pz = this.dir[0] * e2y - this.dir[1] * e2x;
	
	var det = e1x * px + e1y * py + e1z * pz;
	
	if ( det > -EPS && det < EPS )
		return null;
		
	var inv_det = 1.0 / det;
	
	var tx =  this.orig[0] - verts[i0];
	var ty = this.orig[1] - verts[i0+1];
	var tz = this.orig[2] - verts[i0+2];
	
	var u = (tx * px + ty * py + tz * pz) * inv_det;
	if ( u < 0.0 ||u > 1.0 )
		return null;
		
    var qx = ty * e1z - tz * e1y;
	var qy = tz * e1x - tx * e1z;
    var qz = tx * e1y - ty * e1x;
		
	var v = (this.dir[0] * qx + this.dir[1] * qy + this.dir[2]  * qz) * inv_det;
	if ( v < 0.0 || u+v > 1.0 )
		return null;
		
	var t = (e2x * qx + e2y * qy + e2z * qz) * inv_det;
	if ( t >= 0 )
		return new Ray.Intersection(t);
	else
		return null;
}

/**************************************************************************************************************/
	
 /**
  * Ray triangle intersection
  */
/*Ray.prototype.triangleIntersect = function( vert0, vert1, vert2 )
{
	var edge1 = vec3.subtract( vert1, vert0, vec3.create() );
	var edge2 = vec3.subtract( vert2, vert0, vec3.create() );
	
	var pvec = vec3.cross( this.dir, edge2, vec3.create() );
	
	var det = vec3.dot( edge1, pvec );
	
	if ( det > -EPS && det < EPS )
		return null;
		
	var inv_det = 1.0 / det;
	
	var tvec = vec3.subtract( this.orig, vert0, vec3.create() );
	
	var u = vec3.dot( tvec, pvec ) * inv_det;
	if ( u < 0.0 || u > 1.0 )
		return null;
		
	var qvec = vec3.cross( tvec, edge1, vec3.create() );
	
	var v = vec3.dot( this.dir, qvec ) * inv_det;
	if ( v < 0.0 || u+v > 1.0 )
		return null;
		
	var t = vec3.dot( edge2, qvec ) * inv_det;
	
	return new Ray.Intersection(t);
	
};*/

/**************************************************************************************************************/

return Ray;

});
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 define( 'Event',[],function() {

/**************************************************************************************************************/

/** 
	@name Event
	@class
	A light-weight event object.
 */
var Event = function()
{	
	// Event callbacks
	this.callbacks = {};
}

/**************************************************************************************************************/

/** 
	Subscribe to an event
	
	@param name Event name
		<ul>
			<li>startNavigation : called when navigation is started (by the user or through animation)</li>
			<li>endNavigation : called when navigation is ended (by the user or through animation)t</li>
			<li>baseLayersReady : called when the base layers are ready to be displayed</li>
			<li>baseLayersError : called when the base layers are not valid, or not accessible, in that case nothing is displayed so this event is useful to provide an error message to the user</li>
			<li>startBackgroundLoad : called when background layers (imagery and/or elevation) start to be loaded</li>
			<li>endBackgroundLoad : called when background layers (imagery and/or elevation) end loading</li>
			<li>startLoad : called when a layer start to be loaded</li>
			<li>endLoad : called whena layer end loading</li>
		</ul>
	@param callback Callback function
*/
Event.prototype.subscribe = function(name,callback)
{
	if ( !this.callbacks[name] ) {
		this.callbacks[name] = [ callback ];
	} else {
		this.callbacks[name].push( callback );
	}
}

/**************************************************************************************************************/

/** 
	Unsubscribe to an event 
	
	@param name Event name {@link Globe#subscribe}
	@param callback Callback function
*/
Event.prototype.unsubscribe = function(name,callback)
{
	if( this.callbacks[name] ) {
		var i = this.callbacks[name].indexOf( callback );
		if ( i != -1 ) {
			this.callbacks[name].splice(i,1);
		}
	}
}

/**************************************************************************************************************/

/**
	Publish an event
	
	@param name Event name
	@param context Context
	
	@private
*/
Event.prototype.publish = function(name,context)
{
	if ( this.callbacks[name] ) {
		var cbs = this.callbacks[name];
		for ( var i = 0; i < cbs.length; i++ ) {
			cbs[i](context);
		}
	}
}

/**************************************************************************************************************/

return Event;

});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 define('Globe',['./CoordinateSystem', './RenderContext', './TileManager', './Tile', './VectorRendererManager', './Ray', './GeoBound', './Event', './Utils' ], 
	function(CoordinateSystem, RenderContext, TileManager, Tile, VectorRendererManager, Ray, GeoBound, Event, Utils) {

/**************************************************************************************************************/

/** 
	@name Globe
	@class
	Create a virtual globe in a HTML canvas element, passed in options parameter.
	The virtual globe data is set using setBaseImage/addLayer methods.
	
	@param options Configuration properties for the Globe :
		<ul>
			<li>canvas : the canvas for WebGL, can be string (id) or a canvas element</li>
			<li>renderContext : <RenderContext> object to use the existing render context</li>
			<li>backgroundColor : the background color of the canvas (an array of 4 floats)</li>
			<li>shadersPath : the path to shaders file</li>
			<li>continuousRendering: if true rendering is done continuously, otherwise it is done only if needed</li>
			<li>defaultColor : Texture color without imagery provider</li>
		</ul>
	
 */
var Globe = function(options)
{
	Event.prototype.constructor.call( this );
	
	if ( options.coordinateSystem )
	{
		this.coordinateSystem = options.coordinateSystem;
	}
	else
	{
		this.coordinateSystem = new CoordinateSystem();
	}

	if ( !options.renderContext )
	{
		this.renderContext = new RenderContext(options);
	}
	else
	{
		this.renderContext = options.renderContext;
	}
	this.tileManager = new TileManager( this, options );
	this.vectorRendererManager = new VectorRendererManager( this );
	this.attributionHandler = null;
	this.baseImagery = null;
	this.preRenderers = [];
	this.nbCreatedLayers = 0;
	
	this.tileManager.addPostRenderer( this.vectorRendererManager );

	this.renderContext.renderers.push(this);
	this.renderContext.requestFrame();
}

/**************************************************************************************************************/

Utils.inherits( Event, Globe );

/**************************************************************************************************************/

/** 
	Dispose the globe and all its ressources
 */
Globe.prototype.dispose = function()
{	
	this.tileManager.tilePool.disposeAll();
	this.tileManager.reset();
}

/**************************************************************************************************************/

/**
 	Destroy globe
 */
 Globe.prototype.destroy = function()
 {
 	this.dispose();
 	this.tileManager.removePostRenderer( this.vectorRendererManager );
 	this.renderContext.renderers.splice( this.renderContext.renderers.indexOf(this.globe), 1 );
 }


/**************************************************************************************************************/

/** 
  Refresh rendering, must be called when canvas size is modified
 */
Globe.prototype.refresh = function()
{
	this.renderContext.requestFrame();
}

/**************************************************************************************************************/

/** 
  Set the base imagery layer for the globe
  
  @param {RasterLayer} layer the layer to use, must be an imagery RasterLayer
*/
Globe.prototype.setBaseImagery = function(layer)
{
	if ( this.baseImagery == layer )
		return;

	if ( this.baseImagery )
	{
		this.removeLayer( this.baseImagery );
		this.baseImagery = null;
	}
	// Attach the layer to the globe 
	if ( layer )
	{
		layer._overlay = false;
		this.addLayer(layer);
		this.baseImagery = layer;
	}
	// Modify the tile manager after the layer has been attached
	this.tileManager.setImageryProvider(layer);
}

/**************************************************************************************************************/

/** 
  Set the base elevation layer for the globe
  
  @param {RasterLayer} layer the layer to use, must be an elevation RasterLayer
*/
Globe.prototype.setBaseElevation = function(layer)
{
	if ( this.tileManager.elevationProvider )
	{
		this.removeLayer( this.tileManager.elevationProvider );
	}
	this.tileManager.setElevationProvider(layer);
	if ( layer )
	{
		layer._overlay = false;
		this.addLayer(layer);
	}
}


/**************************************************************************************************************/

/** 
  Add a layer to the globe.
  A layer must be added to be visualized on the globe.
  
  @param layer the layer to add
*/
Globe.prototype.addLayer = function(layer)
{
	layer.id = this.nbCreatedLayers;
	layer._attach(this);
	this.renderContext.requestFrame();
	this.nbCreatedLayers++;
}

/**************************************************************************************************************/

/** 
  Remove a layer
  
  @param layer the layer to remove
*/
Globe.prototype.removeLayer = function(layer)
{
	layer._detach();
	this.renderContext.requestFrame();
}

/**************************************************************************************************************/

/** 
  Add an animation
  
  @param anim the animation to add
*/
Globe.prototype.addAnimation = function(anim)
{
	anim.renderContext = this.renderContext;
}

/**************************************************************************************************************/

/** 
  Remove an animation
  
  @param anim the animation to remove
*/
Globe.prototype.removeAnimation = function(anim)
{
	anim.renderContext = null;
}

/**************************************************************************************************************/

/** 
  Get the elevation at a geo position
  
  @param lon the longitude in degree
  @param lat  the latitude in degree
  @return the elevation in meter at the position [lon,lat]
*/
Globe.prototype.getElevation = function(lon,lat)
{
	// Use imagery provider tiling if defined, otherwise use globe default one
	var tiling = this.tileManager.tiling;
	if ( this.baseImagery ) {
		var tiling = this.baseImagery.tiling;
	}
	var levelZeroTile = this.tileManager.level0Tiles[ tiling.lonlat2LevelZeroIndex(lon,lat) ];
	if ( levelZeroTile.state == Tile.State.LOADED )
		return levelZeroTile.getElevation(lon,lat);
	else
		return 0.0;
}

/**************************************************************************************************************/

/** 
	Get the viewport geo bound

	@param transformCallback
		Callback transforming the frustum/globe intersection coordinates if needed

    @return the geo bound of the viewport
*/
Globe.prototype.getViewportGeoBound = function(transformCallback)
{
	var rc = this.renderContext;
	var tmpMat = mat4.create();
	
	// Compute eye in world space
	mat4.inverse(rc.viewMatrix, tmpMat);
	var eye = [tmpMat[12], tmpMat[13], tmpMat[14]];
	
	// Compute the inverse of view/proj matrix
	mat4.multiply(rc.projectionMatrix, rc.viewMatrix, tmpMat);
	mat4.inverse(tmpMat);
	
	// Transform the four corners of the frustum into world space
	// and then for each corner compute the intersection of ray starting from the eye with the earth
	var points = [ [ -1, -1, 1, 1 ], [ 1, -1, 1, 1 ], [ -1, 1, 1, 1 ], [ 1, 1, 1, 1 ] ];
	var earthCenter = [ 0, 0, 0 ];
	for ( var i = 0; i < 4; i++ )
	{
		mat4.multiplyVec4( tmpMat, points[i] );
		vec3.scale( points[i], 1.0 / points[i][3] );
		vec3.subtract(points[i], eye, points[i]);
		vec3.normalize( points[i] );

		var ray = new Ray( eye, points[i] );
		var t = ray.sphereIntersect( earthCenter, this.coordinateSystem.radius );
		if ( t < 0.0 )
			return null;
		var pos3d = ray.computePoint(t);
		points[i] = this.coordinateSystem.from3DToGeo( pos3d );
		if (transformCallback) 
		{
			points[i] = transformCallback(points[i]);
		}
	}

	var geoBound = new GeoBound();
	geoBound.computeFromCoordinates( points );

	return geoBound;
}

/**************************************************************************************************************/

/** 
	Get the lon-lat from a pixel.
	The pixel is expressed in the canvas frame, i.e. (0,0) corresponds to the lower-left corner of the pixel
	
	@param 	x the pixel x coordinate
	@param 	y the pixel y coordinate
	@return	an array of two numbers [lon,lat] or null if the pixel is not on the globe
 */
Globe.prototype.getLonLatFromPixel = function(x,y)
{	
	var ray = Ray.createFromPixel(this.renderContext, x, y);
	var intersection;
	if ( this.coordinateSystem.isFlat )
	{
		intersection =  ray.planeIntersect( [0,0,0], [0,0,1] );
	}
	else
	{
		intersection = ray.sphereIntersect( [0,0,0], this.coordinateSystem.radius );
	}
	
	if ( intersection >= 0 )
	{
		return this.coordinateSystem.from3DToGeo( ray.computePoint(intersection) );
	}
	else
	{
		return null;
	}
}

/**************************************************************************************************************/

/** 
	Get pixel from lon-lat
	The pixel is expressed in the canvas frame, i.e. (0,0) corresponds to the lower-left corner of the pixel
	
	@param lon	the longitude
	@param lat	the latitude
	@return	an array of two numbers [x,y] or null if the pixel is not on the globe
 */
Globe.prototype.getPixelFromLonLat = function(lon,lat)
{	
	var pos3d = vec3.create();
	this.coordinateSystem.fromGeoTo3D([lon,lat], pos3d);
	var pixel = this.renderContext.getPixelFrom3D(pos3d[0],pos3d[1],pos3d[2]);
	return pixel
}

/**************************************************************************************************************/

/**
	Render the globe
	TODO : private for now because it is automatically called in requestAnimationFrame.
	@private
 */
Globe.prototype.render = function()
{
	// Call pre-renderers
	for ( var i = 0 ; i < this.preRenderers.length; i++ )
		this.preRenderers[i].preRender();
		
	// Render tiles
	this.tileManager.render();
}

/**************************************************************************************************************/

/**
	Set coordinate system
 */
Globe.prototype.setCoordinateSystem = function(coordinateSystem)
{
	this.coordinateSystem = coordinateSystem;
	this.tileManager.tileConfig.coordinateSystem = coordinateSystem;
	this.dispose();
	this.tileManager.level0Tiles = this.tileManager.tiling.generateLevelZeroTiles(this.tileManager.tileConfig,this.tileManager.tilePool);
}

/**************************************************************************************************************/

/**
	Display some render statistics
	@private
 */
Globe.prototype.getRenderStats = function()
{
	return "# rendered tiles : " + this.tileManager.tilesToRender.length;
}

/**************************************************************************************************************/

return Globe;

});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *  Ported from HEALPix Java code supported by the Gaia project.
 * 	Copyright (C) 2006-2011 Gaia Data Processing and Analysis Consortium
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('AstroCoordTransform',[],function() {

/**************************************************************************************************************/

/** The Constant twoPi. */
var twoPi=2.*Math.PI;

/** The Constant fourPi. */
var fourPi=4.*Math.PI;

/** The Constant degToRad. */
var degToRad=180.0/Math.PI;

/** The Constant psi. */
var psi = [
	[0.57595865315,4.92619181360,0.00000000000,0.00000000000,0.11129056012,4.70053728340],
	[0.57477043300,4.93682924650,0.00000000000,0.00000000000,0.11142137093,4.71279419371]
];

/** The Constant stheta. */
var stheta = [
	[0.88781538514,-0.88781538514, 0.39788119938,-0.39788119938, 0.86766174755,-0.86766174755],
	[0.88998808748,-0.88998808748, 0.39777715593,-0.39777715593, 0.86766622025,-0.86766622025]
];

/** The Constant ctheta. */
var ctheta = [
	[0.46019978478,0.46019978478,0.91743694670,0.91743694670,0.49715499774,0.49715499774],
	[0.45598377618,0.45598377618,0.91748206207,0.91748206207,0.49714719172,0.49714719172]
];

/** The Constant phi. */
var phi = [
	[4.92619181360,0.57595865315,0.00000000000,0.00000000000,4.70053728340,0.11129056012],
	[4.93682924650,0.57477043300,0.00000000000,0.00000000000,4.71279419371,0.11142137093]
];

var AstroCoordTransform = {

	/**Transforms an angular position in radians in a given coordinate system to a position
	   in an other coordinate system, also in radians. RA-Dec position are intended in 
	   Equinox J2000
	   
	   @param {Float[]} pos Angular position [phi, theta]
	   @param trType Transform type
	 */
    transform: function(pos, trType) 
	{
		var ao,bo,a,b,sb,cb,cbsa;
		var J2000 = 1;
		//by setting J2000 = 0, RA-Dec are intended in Equinox 1950.

		a= pos[0] - phi[J2000][trType];
		b= pos[1];
		sb=Math.sin(b);
		cb=Math.cos(b);
		cbsa=cb*Math.sin(a);
		b=-stheta[J2000][trType] * cbsa + ctheta[J2000][trType]*sb;
		b=Math.max(-1.0,Math.min(b,1.0));
		bo=Math.asin(b);
		
		a=Math.atan2(ctheta[J2000][trType] * cbsa+ stheta[J2000][trType]*sb,cb*Math.cos(a));
		ao=(a+psi[J2000][trType]+fourPi)%twoPi;

		return [ao, bo]; // phi, theta
    },

    /**Transforms an angular position in degrees in a given coordinate system to a position
       in an other coordinate systems, also in degrees. RA-Dec position are intended in 
       Equinox J2000

       @param {Float[]} pos Angular position [phi, theta]
       @param trType Transform type
       */
    transformInDeg: function(pos, trType) 
	{
		var ao,bo,a,b,sb,cb,cbsa;
		var J2000 = 1;
		//by setting J2000 = 0, RA-Dec are intended in Equinox 1950.

		a= pos[0]/degToRad - phi[J2000][trType];
		b= pos[1]/degToRad;
		sb=Math.sin(b);
		cb=Math.cos(b);
		cbsa=cb*Math.sin(a);
		b=-stheta[J2000][trType] * cbsa + ctheta[J2000][trType]*sb;
		b=Math.max(-1.0,Math.min(b,1.0));
		bo=Math.asin(b)*degToRad;
		
		a=Math.atan2(ctheta[J2000][trType] * cbsa+ stheta[J2000][trType]*sb,cb*Math.cos(a));
		ao= ((a+psi[J2000][trType]+fourPi)%twoPi)*degToRad;

		return [ao, bo];		      
    }
};

/**
 *	Transform type enumerations
 */
AstroCoordTransform.Type = 
{
	EQ2GAL: 0,		//RA-Dec (2000) -> Galactic
	GAL2EQ: 1,		//Galactic      -> RA-Dec
	EQ2ECL: 2,		//RA-Dec        -> Ecliptic
	ECL2EQ: 3,		//Ecliptic      -> RA-Dec
	ECL2GAL: 4,		//Ecliptic      -> Galactic
	GAL2ECL: 5 		//Galactic      -> Ecliptic
};

/**************************************************************************************************************/

return AstroCoordTransform;

});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define( 'EquatorialCoordinateSystem',['./CoordinateSystem', './Utils', './Numeric', './AstroCoordTransform', './glMatrix'], function(CoordinateSystem, Utils, Numeric, AstroCoordTransform) {

/**************************************************************************************************************/

var EquatorialCoordinateSystem = function(options)
{
	CoordinateSystem.prototype.constructor.call( this, options );
	// Default coordinate system: ("EQ" or "GAL")
	this.type = "EQ";
};

/**************************************************************************************************************/

Utils.inherits( CoordinateSystem, EquatorialCoordinateSystem );

/**************************************************************************************************************/

/**
*	Convert a 3D position to equatorial coordinates
*/
EquatorialCoordinateSystem.prototype.from3DToEquatorial = function(position3d, dest, inSexagesimal){
	
	dest = dest || new Array(3);
	if( typeof(inSexagesimal) == 'undefined' ) {
		inSexagesimal = true;	
	}
	
	var geo = [];

	this.from3DToGeo(position3d, geo);
	this.fromGeoToEquatorial(geo, dest, inSexagesimal);
	
	return dest;
};

/**************************************************************************************************************/

/**
*	Converts an equatorial position to 3D
*/
EquatorialCoordinateSystem.prototype.fromEquatorialTo3D = function(equatorial, dest, inSexagesimal){
	
	dest = dest || new Array(3);
	if( typeof(inSexagesimal) == 'undefined' ) {
		inSexagesimal = true;	
	}
	var geo = [];
	
	this.fromEquatorialToGeo(equatorial, geo, inSexagesimal);
	this.fromGeoTo3D(geo,dest);
	
	return dest;	
};

/**************************************************************************************************************/

/**
*	Convert an equatorial position to geographic
*	@param {String[]} equatorial Array of two numbers or strings corresponding to Right Ascension and Declination
*	@param {Float[]} dest Destination array of two floats corresponding to Longitude and Latitude		  
*	@param {Boolean} inSexagesimal, by default true. When inSexagesimal is true, the equatorial parameter is processed as a sexagesimal expression
*                                       specified by: 'hours+"h" minuts+"m" seconds+"s"' and 'degrees+"" minuts+"\'" seconds+"""'
*/
EquatorialCoordinateSystem.prototype.fromEquatorialToGeo = function(equatorial, dest, inSexagesimal){
	
	dest = dest || [];
	if( typeof(inSexagesimal) == 'undefined' ) {
		inSexagesimal = true;	
	}

	if (inSexagesimal) {	
		// we use string because : parseFloat("-0") returns 0..
		function sign(stringDegree){
			return ((stringDegree[0] == "-") ? -1 : 1);
		}

		var RA = equatorial[0].split(" ");
		// long
		var deg = parseFloat(RA[0]);
		var min = parseFloat(RA[1]);
		var sec = parseFloat(RA[2]);
	
		dest[0] = (deg + min/60 + sec/3600) * 15.;
	
		var Decl = equatorial[1].split(" ");
		// lat
		deg = parseFloat(Decl[0]);
		min = parseFloat(Decl[1]);
		sec = parseFloat(Decl[2]);
	
		dest[1] = sign(Decl[0]) * (Math.abs(deg) + min/60 + sec/3600);
	} else {
		dest[0] = equatorial[0];
		dest[1] = equatorial[1];
	}
	if(dest[0] > 180) {
		dest[0] -= 360;
	}	
	return dest;

};

/**************************************************************************************************************/

/**
*	Convert a geographic position to equatorial
*	@param {Float[]} geo Array of two floats corresponding to Longitude and Latitude
*	@param {String[]} dest Destination array of two numbers or two strings in sexagesimal, respectively the Right Ascension and Declination
*			  the Right ascension is in [0..360], the declination [-90..90]			  
*	@param {Boolean} inSexagesimal, by default true. When inSexagesimal is true, the dest parameter is transformed in sexagesimal
*                                       specified by: 'hours+"h" minuts+"m" seconds+"s"' and 'degrees+"" minuts+"\'" seconds+"""'
* 	@see <CoordinateSystem.fromDegreesToDMS>
* * 	@see <CoordinateSystem.fromDegreesToHMS>
*/
EquatorialCoordinateSystem.prototype.fromGeoToEquatorial = function(geo, dest, inSexagesimal){
	
	dest = dest || [];
	if( typeof(inSexagesimal) == 'undefined' ) {
		inSexagesimal = true;	
	}
	 
	var deg = geo[0];
	// RA
	if(deg < 0){
		deg += 360;
	}

	if (inSexagesimal) {
		dest[0] = this.fromDegreesToHMS( deg );
		dest[1] = this.fromDegreesToDMS(geo[1]);
	} else {
		dest[0] = deg;
		dest[1] = geo[1];
	}
	
	return dest;
};


/**************************************************************************************************************/

/**
 *	Function converting degrees to DMS("degrees minuts seconds")
 * 
 *	@param {Float} degree The degree
 */

EquatorialCoordinateSystem.prototype.fromDegreesToDMS = function(degree)
{
	function stringSign(val)
	{
		return (val>=0 ? "+": "-");
	}
	
	var absLat = Math.abs(degree);
	var deg = Math.floor(absLat);
	var decimal = (absLat - deg) * 60;
	var min = Math.floor(decimal);
	var sec = (decimal - min) * 60;
	
	return stringSign(degree) + deg + String.fromCharCode(176) +" "+ min +"' "+ Numeric.roundNumber(sec, 2)+"\"";
	
};

/**************************************************************************************************************/

/**
 *	Function converting degrees to HMS("hours minuts seconds")
 *
 *	@param {Float} degree The degree > 0
 */

EquatorialCoordinateSystem.prototype.fromDegreesToHMS = function(degree)
{
	var degree = degree/15;
	
	var absLon = Math.abs(degree);
	var hours = Math.floor(absLon);
	var decimal = (absLon - hours) * 60;
	var min = Math.floor(decimal);
	var sec = (decimal - min) * 60;
	
	return hours+"h "+min+"m "+ Numeric.roundNumber(sec, 2) +"s";
};

/**************************************************************************************************************/

/**
 *	Conversion between coordinate systems("EQ" or "GAL")
 *
 *	@param {Float[]} geo Geographic coordinates
 *	@param from Type of source coordinate system
 *	@param to Type of destination coordinate system
 */
EquatorialCoordinateSystem.prototype.convert = function(geo, from, to)
{
	// No conversion needed
	if ( from == to ) {
		return geo;
	}

	var convertedGeo = null;
	var convertType = null;
	switch ( from+"2"+to ) {
		case "GAL2EQ" :
			convertType = AstroCoordTransform.Type.GAL2EQ;
			convertedGeo = AstroCoordTransform.transformInDeg( geo, convertType );
			break;
		case "EQ2GAL" :
			convertType = AstroCoordTransform.Type.EQ2GAL;
			convertedGeo = AstroCoordTransform.transformInDeg( geo, convertType );
			if (convertedGeo[0] < 0) {
				// TODO : Check if convertedGeo can be negative
				console.warn("EQ2GAL transformation returned negative value");
				convertedGeo[0]+=360;
			}
			break;
		default:
			console.error("Not implemented");
	}
	
	return convertedGeo;
};

/**************************************************************************************************************/

/**
 *	Transfrom 3D vector from galactic coordinate system to equatorial
 */
EquatorialCoordinateSystem.prototype.transformVec = function( vec )
{
	var transformMatrix = this.computeTransformMatrix();
	var res = [];
	mat4.multiplyVec3( transformMatrix, vec, res );
	return res;
};

/**************************************************************************************************************/

/**
 *	Compute transform matrix from GAL to EQ in 3D coordinates
 */
EquatorialCoordinateSystem.prototype.computeTransformMatrix = function()
{
	var transformMatrix = [];

	var galNorth = this.convert([0,90], 'GAL', 'EQ');
	var gal3DNorth = this.fromGeoTo3D(galNorth);

	var galCenter = this.convert([0, 0], 'GAL', 'EQ');
	var gal3DCenter = this.fromGeoTo3D(galCenter);

	var galEast = this.convert([90, 0], 'GAL', 'EQ');
	var gal3DEast = this.fromGeoTo3D(galEast);

	transformMatrix[0] = gal3DCenter[0];
	transformMatrix[1] = gal3DCenter[1];
	transformMatrix[2] = gal3DCenter[2];
	transformMatrix[3] = 0.;
	transformMatrix[4] = gal3DEast[0];
	transformMatrix[5] = gal3DEast[1];
	transformMatrix[6] = gal3DEast[2];
	transformMatrix[7] = 0.;
	transformMatrix[8] = gal3DNorth[0];
	transformMatrix[9] = gal3DNorth[1];
	transformMatrix[10] = gal3DNorth[2];
	transformMatrix[11] = 0.;
	transformMatrix[12] = 0.;
	transformMatrix[13] = 0.;
	transformMatrix[14] = 0.;
	transformMatrix[15] = 1.;

	return transformMatrix;
};

/**************************************************************************************************************/

return EquatorialCoordinateSystem;

});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 define('Sky',['./Globe', './EquatorialCoordinateSystem', './TileManager', './TilePool', './Utils' ], 
	function(Globe, EquatorialCoordinateSystem, TileManager, TilePool, Utils) {

/**************************************************************************************************************/

/** 
	@name Sky
	@class
	Create a virtual sky in a HTML canvas element, passed in options parameter.
	The virtual sky data is set using setBaseImage/addLayer methods.
	
	@param options Configuration properties for the Sky :
		<ul>
			<li>canvas : the canvas for WebGL, can be string (id) or a canvas element</li>
			<li>renderContext : <RenderContext> object to use the existing render context</li>
			<li>backgroundColor : the background color of the canvas (an array of 4 floats)</li>
			<li>shadersPath : the path to shaders file</li>
			<li>continuousRendering: if true rendering is done continuously, otherwise it is done only if needed</li>
		</ul>
	
 */
var Sky = function(options)
{
	options.coordinateSystem = new EquatorialCoordinateSystem(options);
	Globe.prototype.constructor.call( this, options );

	this.isSky = true;
	this.tilePool =  new TilePool(this.renderContext);
	this.tileManagers = {
		'EQ': this.tileManager,
		'GAL': new TileManager( this, options )
	};

	this.renderContext.requestFrame();
}

/**************************************************************************************************************/

Utils.inherits( Globe, Sky );

/**************************************************************************************************************/

/** 
	Dispose the sky and all its ressources
 */
Sky.prototype.dispose = function()
{	
	for ( var x in this.tileManagers )
	{
		this.tileManagers[x].tilePool.disposeAll();	
		this.tileManagers[x].reset();
	}
}

/**************************************************************************************************************/

/** 
  Set the base imagery layer for the sky
  
  @param {RasterLayer} layer the layer to use, must be an imagery RasterLayer
*/
Sky.prototype.setBaseImagery = function(layer)
{
	if ( this.baseImagery == layer )
		return;
		
	if ( this.baseImagery ) 
	{
		this.removeLayer( this.baseImagery );	
		this.tileManagers[ this.baseImagery.coordSystem ].setImageryProvider(null);
		this.baseImagery = null;		
	}
	
	// Attach the layer to the globe 
	if ( layer )
	{
		layer._overlay = false;
		this.addLayer(layer);
		
		// Modify the tile manager after the layer has been attached
		//this.tileManager = this.tileManagers[layer.coordSystem];
		this.tileManagers[ layer.coordSystem ].setImageryProvider( layer );
		this.baseImagery = layer;
	}
	
}

/**************************************************************************************************************/

/**
	Render the globe
	TODO : private for now because it is automatically called in requestAnimationFrame.
	@private
 */
Sky.prototype.render = function()
{		
	// Render tiles manager
	this.tileManagers['GAL'].render();
	this.tileManagers['EQ'].render();
}

/**************************************************************************************************************/

return Sky;

});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define( 'KeyboardNavigationHandler',[],function() {

/**************************************************************************************************************/

/** @export
	@constructor
	KeyboardNavigationHandler constructor
	@param options Configuration properties for the KeyboardNavigationHandler :
			<ul>
				<li>panFactor  : Factor for panning within the scene</li>
				<li>zoomFactor : Factor for zooming into the scene</li>
				<li>installOnDocument : True to install the event listener on the document and not on the canvas</li>
			</ul>
 */
var KeyboardNavigationHandler = function(options){
	
	/**************************************************************************************************************/
	
	/**
 	 * Private variables
	 */
	var _navigation = null;
	var self = this;
	
	/**
	 * Public variables
	 */
	this.panFactor = 10.;
	this.zoomFactor = 1.;
	
	// Setup options
	if ( options )
	{
		if ( options['panFactor'] && typeof options['panFactor'] == 'number' )
			this.panFactor = options['panFactor'];
		if ( options['zoomFactor'] && typeof options['zoomFactor'] == 'number' )
			this.zoomFactor = options['zoomFactor'];
	}
	
	/**************************************************************************************************************/
	
	/**
 	 * Private methods
	 */

	/**
	 * Set focus
	 */
	var _setFocus = function(event)
	{
		this.focus();
		return false;
	};
	  
	/**
	 *	Event handler for key down
	 */
	var _handleKeyDown = function(event)
	{
		switch( event.keyCode ){
			case 32 :
				// space bar
				// Stop all animations when an event is received
				_navigation.stopAnimations();
				break;
			case 187 :
				// + on Safari
			case 61 :
				// +(=) on Firefox and Opera
			case 107 :
				// + on other
				_navigation.zoom(-self.zoomFactor);
				break;
			case 189 :
				// - on Safari
			case 54 :
				// -(6) on Firefox and Opera
			case 109 :
				// - on other
				_navigation.zoom(self.zoomFactor);
				break;
			case 81 :
				// q
			case 37 :
				// Left arrow
				if ( event.shiftKey )
				{
					_navigation.rotate( self.panFactor, 0 );
				}
				else
				{
					_navigation.pan( self.panFactor, 0 );
				}
				break;
			case 90 :
				// z
			case 38 :
				// Up arrow
				if ( event.shiftKey )
				{
					_navigation.rotate( 0, self.panFactor );
				}
				else
				{

					_navigation.pan( 0, self.panFactor );
				}
				break;
			case 68 :
				// d
			case 39 :
				// Right arrow
				if ( event.shiftKey )
				{
					_navigation.rotate( -self.panFactor, 0 );
				}
				else
				{
					_navigation.pan( -self.panFactor, 0 );
				}
				break;
			case 83 :
				// s
			case 40 :
				// Down arrow
				if ( event.shiftKey )
				{
					_navigation.rotate( 0, -self.panFactor );
				}
				else
				{

					_navigation.pan( 0, -self.panFactor );
				}
				break;
		}
	};

	/**************************************************************************************************************/
	
	 /**
	  * Public methods
	  */

	/** 
		Setup the default event handlers for the navigation
	 */
	this.install = function(navigation)
	{
		// Setup the keyboard event handlers
		_navigation = navigation;
		
		if ( options && options.installOnDocument )
		{
			document.addEventListener("keydown", _handleKeyDown);
		}
		else
		{
			var canvas = _navigation.renderContext.canvas;
			canvas.addEventListener("keydown", _handleKeyDown);
			// Setup focus handling to receive keyboard event on canvas
			canvas.tabIndex = "0";
			canvas.addEventListener("mousedown", _setFocus);
		}
	};

	/** 
		Remove the default event handlers for the navigation
	 */
	this.uninstall = function()
	{	
		if ( options && options.installOnDocument )
		{
			document.removeEventListener("keydown", _handleKeyDown);
		}
		else
		{
			var canvas = _navigation.renderContext.canvas;
			canvas.removeEventListener("keydown", _handleKeyDown);
			canvas.removeEventListener("mousedown", _setFocus);
		}
	};
	
};

return KeyboardNavigationHandler;

});


/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define( 'MouseNavigationHandler',[],function() {

/**************************************************************************************************************/

/** @export
	@constructor
	Mouse_navigationHandler constructor
	@param options Configuration properties for the Mouse_navigationHandler :
			<ul>
				<li>zoomOnDblClick : if true defines animation on double click</li>
			</ul>
 */
var MouseNavigationHandler = function(options){
	
	/**************************************************************************************************************/
	
	/**
 	 * Private variables
	 */
	 
	var _navigation = null;
	var _pressedButton = -1;
	var _lastMouseX = -1;
	var _lastMouseY = -1;
	var _dx = 0;
	var _dy = 0;
	var _panButton = (options && options.panButton) || 0;
	var _rotateButton = (options && options.rotateButton) || 1;

	/**************************************************************************************************************/
	
	/**
 	 * Private methods
	 */

	/**
		Event handler for mouse wheel
	 */
	var _handleMouseWheel = function(event)
	{	
		var factor;

		// Check differences between firefox and the rest of the world
		if ( event.wheelDelta === undefined)
		{
			factor = event.detail;
		}
		else
		{
			factor = -event.wheelDelta / 120.0;	
		}
		_navigation.zoom(factor);
		
		// Stop all animations when an event is received
		_navigation.stopAnimations();
		
		// Launch inertia if needed
		if ( _navigation.inertia )
		{
			_navigation.inertia.launch("zoom", factor < 0 ? -1 : 1 );
		}

		// Stop mouse wheel to be propagated, because default is to scroll the page
		// This is need when using Firefox event listener on DOMMouseScroll
		if ( event.preventDefault )
		{
			event.preventDefault();
		}
		event.returnValue = false;
					
		// Return false to stop mouse wheel to be propagated when using onmousewheel
		return false;
	};

	/**
	 * Event handler for mouse down
	 */
	var _handleMouseDown = function(event)
	{
		document.addEventListener("mouseup", _handleMouseUp);
		_pressedButton = event.button;
		
		// Stop all animations when an event is received
		_navigation.stopAnimations();

		if ( event.button == _panButton || event.button == _rotateButton )
		{		
			_lastMouseX = event.clientX;
			_lastMouseY = event.clientY;
			_dx = 0;
			_dy = 0;
						
			// Return false to stop mouse down to be propagated when using onmousedown
			return false;
		}
		
		return true;
	};

	/**
	 * Event handler for mouse up
	 */
	var _handleMouseUp = function(event)
	{
		// No button pressed anymore
		_pressedButton = -1;
		document.removeEventListener("mouseup", _handleMouseUp);

		if ( _navigation.inertia && (_dx != 0 || _dy != 0)  )
		{	
			if ( event.button == _panButton )
			{
				_navigation.inertia.launch("pan", _dx, _dy );
			
			}
			if ( event.button == _rotateButton )
			{
				_navigation.inertia.launch("rotate", _dx, _dy );
			}
		}

		if ( event.button == _panButton || event.button == _rotateButton )
		{
			event.preventDefault();
			
			// Stop mouse up event
			return false;
		}

		return true;
	};

	/**
		Event handler for mouse move
	*/
	var _handleMouseMove = function(event)
	{
		// No button pressed
		if (_pressedButton < 0)
			return;
		
		_dx = (event.clientX - _lastMouseX);
		_dy = (event.clientY - _lastMouseY);
		
		if ( _dx == 0 && _dy == 0 )
			return;
		
		var ret = false;
		// Pan
		if ( _pressedButton == _panButton )
		{
			_navigation.pan( _dx, _dy );
			ret = true;
		}
		// Rotate
		else if ( _pressedButton == _rotateButton )
		{
			_navigation.rotate(_dx,_dy);
			ret = true;
		}
		
		_lastMouseX = event.clientX;
		_lastMouseY = event.clientY;
		
		return ret;
	};

	/**
		Event handler for mouse double click
	 */
	var _handleMouseDblClick = function(event)
	{
		if (event.button == 0)
		{
			var pos = _navigation.globe.renderContext.getXYRelativeToCanvas(event);
			var geo = _navigation.globe.getLonLatFromPixel( pos[0], pos[1] );
		
			if (geo)
			{
				_navigation.zoomTo(geo);
			}
		}
	};

	/**************************************************************************************************************/
	
	 /**
	  * Public methods
	  */
			
	/** 
	 *	Setup the default event handlers for the _navigation
	 */
	this.install = function(nav)
	{
		_navigation = nav;
		
		var canvas = _navigation.renderContext.canvas;
		
		// Setup the mouse event handlers
		canvas.addEventListener("mousedown", _handleMouseDown);
		canvas.addEventListener("mousemove", _handleMouseMove);
		
		if ( options && options.zoomOnDblClick )
			canvas.addEventListener("dblclick", _handleMouseDblClick);
			
		// For Firefox
		canvas.addEventListener("DOMMouseScroll", _handleMouseWheel);
		canvas.addEventListener("mousewheel", _handleMouseWheel);
		
		// Fix for Google Chrome : avoid dragging
		// TODO : a hack, should be more robust (restore on uninstall?)
		canvas.addEventListener("dragstart", function(event){event.preventDefault(); return false;});

		if ( _rotateButton == 2 ) 
		{
			canvas.addEventListener("contextmenu", function(e) { e.preventDefault(); return false; }, false);
		}
	};

	/** 
	 *	Remove the default event handlers for the _navigation
	 */
	this.uninstall = function()
	{
		// Setup the mouse event handlers
		var canvas = _navigation.renderContext.canvas;

		canvas.removeEventListener("mousedown", _handleMouseDown);
		canvas.removeEventListener("mousemove", _handleMouseMove);
		
		if ( options && options.zoomOnDblClick )
			canvas.removeEventListener("dblclick", _handleMouseDblClick);
			
		// For Firefox
		canvas.removeEventListener("DOMMouseScroll", _handleMouseWheel);
		canvas.removeEventListener("mousewheel", _handleMouseWheel);
	};
};

return MouseNavigationHandler;

});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 define( 'BaseLayer',["./Event", "./Utils"], function(Event, Utils) {
 
/**************************************************************************************************************/


/** @name BaseLayer
	@class
	Base class for layer.
	@param options Configuration properties for a BaseLayer:
		<ul>
			<li>name : the layer name</li>
			<li>description :  its description</li>
			<li>attribution : its attribution</li>
			<li>icon : an icon to represent the layer</li>
			<li>visible : a boolean flag to set the layer visible, default is true </li>
			<li>opacity : an opacity value, default is 1.0</li>
		</ul>
 */
var BaseLayer = function(options)
{
	Event.prototype.constructor.call( this, options );

	this.globe = null;
	this.name = options && options.hasOwnProperty('name') ? options['name'] : "";
	this.attribution = options && options.hasOwnProperty('attribution') ? options['attribution'] : "";
	this.icon = options && options.hasOwnProperty('icon') ? options['icon'] : "";
	this.description = options && options.hasOwnProperty('description') ? options['description'] : "";
	this._visible = options && options.hasOwnProperty('visible') ? options['visible'] : true;
	this._opacity = options && options.hasOwnProperty('opacity') ? options['opacity'] : 1.0;
}

/**************************************************************************************************************/

Utils.inherits( Event,BaseLayer );

/**************************************************************************************************************/

/** 
  Attach the raster layer to the globe
 */
BaseLayer.prototype._attach = function( g )
{
	this.globe = g;
	if ( this.attribution && this.globe.attributionHandler && this._visible )
	{
		this.globe.attributionHandler.addAttribution(this);
	}
}

/**************************************************************************************************************/

/** 
  Detach the vector layer from the globe
 */
BaseLayer.prototype._detach = function()
{
	if ( this.attribution && this.globe.attributionHandler )
	{
		this.globe.attributionHandler.removeAttribution(this);
	}
	
	this.globe = null;
}

/**************************************************************************************************************/

/**
  Get/Set the layer visible
 */
BaseLayer.prototype.visible = function( arg )
{
	if ( typeof arg == "boolean" )
	{
		if (  this._visible != arg && this.attribution && this.globe.attributionHandler )
		{
			this.globe.attributionHandler.toggleAttribution(this);
		}

		this._visible = arg;
		if ( this.globe ) this.globe.renderContext.requestFrame();
		this.publish("visibility:changed", this);
	}
	return this._visible;
}

/**************************************************************************************************************/

/**
  Get/Set the opacity of the layer
 */
BaseLayer.prototype.opacity = function( arg )
{
	if ( typeof arg == "number" )
	{
		this._opacity = arg;
		if ( this.globe ) this.globe.renderContext.requestFrame();
		this.publish("opacity:changed");
	}
	return this._opacity;
}

return BaseLayer;

});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 define( 'FeatureStyle',[],function() {
 
 
// Simple colors
var simple_colors = {
   aliceblue: 'f0f8ff',
   antiquewhite: 'faebd7',
   aqua: '00ffff',
   aquamarine: '7fffd4',
   azure: 'f0ffff',
   beige: 'f5f5dc',
   bisque: 'ffe4c4',
   black: '000000',
   blanchedalmond: 'ffebcd',
   blue: '0000ff',
   blueviolet: '8a2be2',
   brown: 'a52a2a',
   burlywood: 'deb887',
   cadetblue: '5f9ea0',
   chartreuse: '7fff00',
   chocolate: 'd2691e',
   coral: 'ff7f50',
   cornflowerblue: '6495ed',
   cornsilk: 'fff8dc',
   crimson: 'dc143c',
   cyan: '00ffff',
   darkblue: '00008b',
   darkcyan: '008b8b',
   darkgoldenrod: 'b8860b',
   darkgray: 'a9a9a9',
   darkgreen: '006400',
   darkkhaki: 'bdb76b',
   darkmagenta: '8b008b',
   darkolivegreen: '556b2f',
   darkorange: 'ff8c00',
   darkorchid: '9932cc',
   darkred: '8b0000',
   darksalmon: 'e9967a',
   darkseagreen: '8fbc8f',
   darkslateblue: '483d8b',
   darkslategray: '2f4f4f',
   darkturquoise: '00ced1',
   darkviolet: '9400d3',
   deeppink: 'ff1493',
   deepskyblue: '00bfff',
   dimgray: '696969',
   dodgerblue: '1e90ff',
   feldspar: 'd19275',
   firebrick: 'b22222',
   floralwhite: 'fffaf0',
   forestgreen: '228b22',
   fuchsia: 'ff00ff',
   gainsboro: 'dcdcdc',
   ghostwhite: 'f8f8ff',
   gold: 'ffd700',
   goldenrod: 'daa520',
   gray: '808080',
   green: '008000',
   greenyellow: 'adff2f',
   honeydew: 'f0fff0',
   hotpink: 'ff69b4',
   indianred : 'cd5c5c',
   indigo : '4b0082',
   ivory: 'fffff0',
   khaki: 'f0e68c',
   lavender: 'e6e6fa',
   lavenderblush: 'fff0f5',
   lawngreen: '7cfc00',
   lemonchiffon: 'fffacd',
   lightblue: 'add8e6',
   lightcoral: 'f08080',
   lightcyan: 'e0ffff',
   lightgoldenrodyellow: 'fafad2',
   lightgrey: 'd3d3d3',
   lightgreen: '90ee90',
   lightpink: 'ffb6c1',
   lightsalmon: 'ffa07a',
   lightseagreen: '20b2aa',
   lightskyblue: '87cefa',
   lightslateblue: '8470ff',
   lightslategray: '778899',
   lightsteelblue: 'b0c4de',
   lightyellow: 'ffffe0',
   lime: '00ff00',
   limegreen: '32cd32',
   linen: 'faf0e6',
   magenta: 'ff00ff',
   maroon: '800000',
   mediumaquamarine: '66cdaa',
   mediumblue: '0000cd',
   mediumorchid: 'ba55d3',
   mediumpurple: '9370d8',
   mediumseagreen: '3cb371',
   mediumslateblue: '7b68ee',
   mediumspringgreen: '00fa9a',
   mediumturquoise: '48d1cc',
   mediumvioletred: 'c71585',
   midnightblue: '191970',
   mintcream: 'f5fffa',
   mistyrose: 'ffe4e1',
   moccasin: 'ffe4b5',
   navajowhite: 'ffdead',
   navy: '000080',
   oldlace: 'fdf5e6',
   olive: '808000',
   olivedrab: '6b8e23',
   orange: 'ffa500',
   orangered: 'ff4500',
   orchid: 'da70d6',
   palegoldenrod: 'eee8aa',
   palegreen: '98fb98',
   paleturquoise: 'afeeee',
   palevioletred: 'd87093',
   papayawhip: 'ffefd5',
   peachpuff: 'ffdab9',
   peru: 'cd853f',
   pink: 'ffc0cb',
   plum: 'dda0dd',
   powderblue: 'b0e0e6',
   purple: '800080',
   red: 'ff0000',
   rosybrown: 'bc8f8f',
   royalblue: '4169e1',
   saddlebrown: '8b4513',
   salmon: 'fa8072',
   sandybrown: 'f4a460',
   seagreen: '2e8b57',
   seashell: 'fff5ee',
   sienna: 'a0522d',
   silver: 'c0c0c0',
   skyblue: '87ceeb',
   slateblue: '6a5acd',
   slategray: '708090',
   snow: 'fffafa',
   springgreen: '00ff7f',
   steelblue: '4682b4',
   tan: 'd2b48c',
   teal: '008080',
   thistle: 'd8bfd8',
   tomato: 'ff6347',
   turquoise: '40e0d0',
   violet: 'ee82ee',
   violetred: 'd02090',
   wheat: 'f5deb3',
   white: 'ffffff',
   whitesmoke: 'f5f5f5',
   yellow: 'ffff00',
   yellowgreen: '9acd32'
};

var parseHex = /^(\w{2})(\w{2})(\w{2})$/;
var parseRgb = /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/;
var parseRgba = /^rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3},\s*(\d{1,3}))\)$/;


/**************************************************************************************************************/

/** @name FeatureStyle
	@class
	The style to display a Feature
	@param style an object containing the following style properties
		<ul>
			<li>strokeColor : the color for line, or polygon outline</li>
			<li>strokeWidth : the width of a line</li>
			<li>fillColor : the color for solid polygon or point</li>
			<li>fillTextureUrl : the texture for solid polygon</li>
			<li>iconUrl : the icon to be used for point</li>
			<li>pointMaxSize : maximum size (in meter) for a point</li>
			<li>extrusionScale : extrusion scale (in meter)</li>
		</ul>
 */
var FeatureStyle = function(style)
{
	// Color used for lines or polygon outline
	this.strokeColor = [1.0, 0.0, 0.0, 1.0];
	// Color used to full polygon
	this.fillColor = [1.0, 0.0, 0.0, 1.0];
	this.fillTextureUrl = null;
    this.fillTexture = null;
    this.fillShader = null;
	this.strokeWidth = 1;
	this.iconUrl = null;
	this.icon = null;
	this.label = null;
	this.textColor = [1.0, 1.0, 1.0, 1.0];
	this.fill = false;
	this.pointMaxSize = 40;
	this.opacity = 1.;
	this.zIndex = 0;
	this.extrusionScale = 1.;

	if ( style )
	{
		for ( var s in style )
		{
			this[s] = style[s];
		}
	}
}


/**************************************************************************************************************/

/**
 * Convert a color from a string to RGB
 */
FeatureStyle.fromStringToColor = function(color_string)
{
	var r = 0, g = 0, b = 0, a = 255;
	var match;
	
	color_string = color_string.trim();
	color_string = color_string.toLowerCase();
	// strip any leading #
	if (color_string.charAt(0) == '#') { // remove # if any
	   color_string = color_string.substr(1,6);
	}
	
	// Convert a litteral color to rgb string
	if ( simple_colors.hasOwnProperty(color_string) )
	{
		color_string = simple_colors[color_string];
	}
	
	match = parseHex.exec(color_string);
	if ( match )
	{
		r = parseInt(match[1],16);
		g = parseInt(match[2],16);
		b = parseInt(match[3],16);
	}
	
	match = parseRgb.exec(color_string);
	if ( match )
	{
		r = parseInt(match[1]);
		g = parseInt(match[2]);
		b = parseInt(match[3]);
	}
	
	match = parseRgba.exec(color_string);
	if ( match )
	{
		r = parseInt(match[1]);
		g = parseInt(match[2]);
		b = parseInt(match[3]);
		a = parseInt(match[4]);
	}

	// validate/cleanup values
	r = (r < 0) ? 0 : ((r > 255) ? 255 : r);
	g = (g < 0) ? 0 : ((g > 255) ? 255 : g);
	b = (b < 0) ? 0 : ((b > 255) ? 255 : b);
	a = (a < 0) ? 0 : ((a > 255) ? 255 : a);

	return [r / 255.0, g / 255.0, b / 255.0, a / 255.0];
}

/**************************************************************************************************************/

/** 
 * Convert an internal color to a string based color representation
 */
FeatureStyle.fromColorToString = function(color)
{		
   var hashColor = '#';
   for ( var i=0; i<3; i++ )
   {
      var component = parseInt( color[i] * 255.0 ).toString(16)
      hashColor += (component < 10) ? '0'+component : component;
   }

	return hashColor;
}

/**************************************************************************************************************/

return FeatureStyle;

});


/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/
 
define('VectorLayer',['./Utils', './BaseLayer', './FeatureStyle'], 
	function(Utils, BaseLayer, FeatureStyle) {

/**************************************************************************************************************/

/** @name VectorLayer
	@class
	Create a layer to display vector data in GeoJSON format.
	@augments BaseLayer
	@param options Configuration properties for VectorLayer. See {@link BaseLayer} for base properties :
		<ul>
			<li>style : the style to use. See {@link FeatureStyle}</li>
			<li>minLevel : minimum rendering level depending on tile level</li>
			<li>maxLevel : maximum rendering level depending on tile level</li>
		</ul>
 */
var VectorLayer = function( options )
{
	BaseLayer.prototype.constructor.call( this, options );
	
	// Set style
	if ( options && options['style'] )
		this.style = options['style'];
	else
		this.style = new FeatureStyle();
	
	this.minLevel = options && options.hasOwnProperty('minLevel') ? options['minLevel'] : 0.0;
	this.maxLevel = options && options.hasOwnProperty('maxLevel') ? options['maxLevel'] : 15.0;

	this.features = [];
}

/**************************************************************************************************************/

Utils.inherits( BaseLayer,VectorLayer );

/**************************************************************************************************************/

/** 
  Attach the vector layer to the globe
 */
VectorLayer.prototype._attach = function( g )
{
	BaseLayer.prototype._attach.call( this, g );
	
	// Add the feature to renderers
	for ( var i=0; i < this.features.length; i++ )
	{
		this._addFeatureToRenderers( this.features[i] );
	}
}

/**************************************************************************************************************/

/** 
  Detach the vector layer from the globe
 */
VectorLayer.prototype._detach = function()
{
	// Remove feature from renderers
	for ( var i=0; i < this.features.length; i++ )
	{
		this._removeFeatureFromRenderers( this.features[i] );
	}
	
	BaseLayer.prototype._detach.call(this);
}

/**************************************************************************************************************/

/** @export
  Adds a feature collection, in GeoJSON format
 */
VectorLayer.prototype.addFeatureCollection = function( featureCollection )
{
	// Note : use property defined as ['']  to avoid renaming when compiled in advanced mode with the closure compiler
	var features = featureCollection['features'];
	if ( features )
	{
		for ( var i = 0; i < features.length; i++)
		{
			this.addFeature( features[i] );
		}
	}
}

/**************************************************************************************************************/

/** @export
  Removes a feature collection, in GeoJSON format
*/
VectorLayer.prototype.removeFeatureCollection = function( featureCollection )
{
	// Note : use property defined as ['']  to avoid renaming when compiled in advanced mode with the closure compiler
	var features = featureCollection['features'];
	if ( features )
	{
		for ( var i = 0; i < features.length; i++)
		{
			this.removeFeature( features[i] );
		}
	}
}

/**************************************************************************************************************/

/** 
  Add a feature to renderers
*/
VectorLayer.prototype._addFeatureToRenderers = function( feature )
{
	var geometry = feature['geometry']
	
	// Manage style, if undefined try with properties, otherwise use defaultStyle
	var style = this.style;
	var props = feature['properties'];
	if ( props && props['style'] )
	{
		style = props['style'];
	}

	// Manage geometry collection
	if ( geometry.type == "GeometryCollection" )
	{
		var geoms = geometry["geometries"];
		for ( var i = 0; i < geoms.length; i++ )
		{
			this.globe.vectorRendererManager.addGeometry( this, geoms[i], style );
		}
	}
	else
	{
		// Add geometry to renderers
		this.globe.vectorRendererManager.addGeometry( this, geometry, style );
	}
}

/**************************************************************************************************************/

/** 
  Remove a feature from renderers
*/
VectorLayer.prototype._removeFeatureFromRenderers = function( feature )
{
	var geometry = feature['geometry']
	
	// Manage geometry collection
	if ( geometry.type == "GeometryCollection" )
	{
		var geoms = geometry["geometries"];
		var res = false;
		for ( var i = 0; i < geoms.length; i++ )
		{
			res = this.globe.vectorRendererManager.removeGeometry( geoms[i], this );
		}
		return res;
	}
	else
	{
		return this.globe.vectorRendererManager.removeGeometry( geometry, this );
	}
}

/**************************************************************************************************************/

/** @export
  Add a feature to the layer
*/
VectorLayer.prototype.addFeature = function( feature )
{
	// Check feature geometry : only add valid feature
	var geometry = feature['geometry'];
	if ( !geometry || !geometry.type )
		return;
	this.features.push( feature );
	
	// Add features to renderer if layer is attached to globe
	if ( this.globe )
	{			
		this._addFeatureToRenderers(feature);
		if (this._visible) this.globe.renderContext.requestFrame();
	}
}

/**************************************************************************************************************/

/** @export
  Remove a feature from the layer
*/
VectorLayer.prototype.removeFeature = function( feature )
{
	var index = this.features.indexOf( feature );
	this.features.splice( index, 1 );
	if ( this.globe )
	{
		this._removeFeatureFromRenderers( feature );
		if (this._visible) this.globe.renderContext.requestFrame();
	}
}

/**************************************************************************************************************/

/** @export
  Remove all feature from the layer
*/
VectorLayer.prototype.removeAllFeatures = function()
{
	// Remove feature from renderers
	if ( this.globe )
	{
		for ( var i = 0; i < this.features.length; i++ )
		{
			this._removeFeatureFromRenderers( this.features[i] );
		}
	}
	this.features.length = 0;
	
	// Refresh rendering if needed
	if ( this.globe && this._visible )
	{
		this.globe.renderContext.requestFrame();
	}
}

/**************************************************************************************************************/

/** @export
  Modify feature style
*/
VectorLayer.prototype.modifyFeatureStyle = function( feature, style )
{
	if ( this._removeFeatureFromRenderers( feature ) ) {
		feature.properties.style = style;
		this._addFeatureToRenderers( feature );
	}
}

/**************************************************************************************************************/

/** @export
  Modify the vector layer style
*/
VectorLayer.prototype.modifyStyle = function(style)
{
	for ( var i=0; i<this.features.length; i++ )
	{
		this._removeFeatureFromRenderers( this.features[i] );
	}
	
	this.style = style;
	
	for ( var i=0; i<this.features.length; i++ )
	{
		this._addFeatureToRenderers( this.features[i] );
	}
}

/**************************************************************************************************************/

return VectorLayer;

});


/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

/** 
 *	Module with constants
 */
define('HEALPixTables',[],function() {

/**************************************************************************************************************/

var HealPixTables = {
	ctab : [
	  0,1,256,257,2,3,258,259,512,513,768,769,514,515,770,771,4,5,260,261,6,7,262,
	  263,516,517,772,773,518,519,774,775,1024,1025,1280,1281,1026,1027,1282,1283,
	  1536,1537,1792,1793,1538,1539,1794,1795,1028,1029,1284,1285,1030,1031,1286,
	  1287,1540,1541,1796,1797,1542,1543,1798,1799,8,9,264,265,10,11,266,267,520,
	  521,776,777,522,523,778,779,12,13,268,269,14,15,270,271,524,525,780,781,526,
	  527,782,783,1032,1033,1288,1289,1034,1035,1290,1291,1544,1545,1800,1801,1546,
	  1547,1802,1803,1036,1037,1292,1293,1038,1039,1294,1295,1548,1549,1804,1805,
	  1550,1551,1806,1807,2048,2049,2304,2305,2050,2051,2306,2307,2560,2561,2816,
	  2817,2562,2563,2818,2819,2052,2053,2308,2309,2054,2055,2310,2311,2564,2565,
	  2820,2821,2566,2567,2822,2823,3072,3073,3328,3329,3074,3075,3330,3331,3584,
	  3585,3840,3841,3586,3587,3842,3843,3076,3077,3332,3333,3078,3079,3334,3335,
	  3588,3589,3844,3845,3590,3591,3846,3847,2056,2057,2312,2313,2058,2059,2314,
	  2315,2568,2569,2824,2825,2570,2571,2826,2827,2060,2061,2316,2317,2062,2063,
	  2318,2319,2572,2573,2828,2829,2574,2575,2830,2831,3080,3081,3336,3337,3082,
	  3083,3338,3339,3592,3593,3848,3849,3594,3595,3850,3851,3084,3085,3340,3341,
	  3086,3087,3342,3343,3596,3597,3852,3853,3598,3599,3854,3855 ],
	utab : [
	  0,1,4,5,16,17,20,21,64,65,68,69,80,81,84,85,256,257,260,261,272,273,276,277,
	  320,321,324,325,336,337,340,341,1024,1025,1028,1029,1040,1041,1044,1045,1088,
	  1089,1092,1093,1104,1105,1108,1109,1280,1281,1284,1285,1296,1297,1300,1301,
	  1344,1345,1348,1349,1360,1361,1364,1365,4096,4097,4100,4101,4112,4113,4116,
	  4117,4160,4161,4164,4165,4176,4177,4180,4181,4352,4353,4356,4357,4368,4369,
	  4372,4373,4416,4417,4420,4421,4432,4433,4436,4437,5120,5121,5124,5125,5136,
	  5137,5140,5141,5184,5185,5188,5189,5200,5201,5204,5205,5376,5377,5380,5381,
	  5392,5393,5396,5397,5440,5441,5444,5445,5456,5457,5460,5461,16384,16385,16388,
	  16389,16400,16401,16404,16405,16448,16449,16452,16453,16464,16465,16468,16469,
	  16640,16641,16644,16645,16656,16657,16660,16661,16704,16705,16708,16709,16720,
	  16721,16724,16725,17408,17409,17412,17413,17424,17425,17428,17429,17472,17473,
	  17476,17477,17488,17489,17492,17493,17664,17665,17668,17669,17680,17681,17684,
	  17685,17728,17729,17732,17733,17744,17745,17748,17749,20480,20481,20484,20485,
	  20496,20497,20500,20501,20544,20545,20548,20549,20560,20561,20564,20565,20736,
	  20737,20740,20741,20752,20753,20756,20757,20800,20801,20804,20805,20816,20817,
	  20820,20821,21504,21505,21508,21509,21520,21521,21524,21525,21568,21569,21572,
	  21573,21584,21585,21588,21589,21760,21761,21764,21765,21776,21777,21780,21781,
	  21824,21825,21828,21829,21840,21841,21844,21845 ],

	  // coordinate of the lowest corner of each face
	  jrll : [ 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4 ],
	  jpll : [ 1, 3, 5, 7, 0, 2, 4, 6, 1, 3, 5, 7 ],

	  xoffset : [ -1,-1, 0, 1, 1, 1, 0,-1 ],
	  yoffset : [  0, 1, 1, 1, 0,-1,-1,-1 ],
	  facearray :
			[ [  8, 9,10,11,-1,-1,-1,-1,10,11, 8, 9 ],   // S
			  [  5, 6, 7, 4, 8, 9,10,11, 9,10,11, 8 ],   // SE
			  [ -1,-1,-1,-1, 5, 6, 7, 4,-1,-1,-1,-1 ],   // E
			  [  4, 5, 6, 7,11, 8, 9,10,11, 8, 9,10 ],   // SW
			  [  0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11 ],   // center
			  [  1, 2, 3, 0, 0, 1, 2, 3, 5, 6, 7, 4 ],   // NE
			  [ -1,-1,-1,-1, 7, 4, 5, 6,-1,-1,-1,-1 ],   // W
			  [  3, 0, 1, 2, 3, 0, 1, 2, 4, 5, 6, 7 ],   // NW
			  [  2, 3, 0, 1,-1,-1,-1,-1, 0, 1, 2, 3 ] ], // N
	  swaparray :
			[ [ 0,0,3 ],   // S
			  [ 0,0,6 ],   // SE
			  [ 0,0,0 ],   // E
			  [ 0,0,5 ],   // SW
			  [ 0,0,0 ],   // center
			  [ 5,0,0 ],   // NE
			  [ 0,0,0 ],   // W
			  [ 6,0,0 ],   // NW
			  [ 3,0,0 ] ], // N

	  swap_cycle : [
		[],
		[0,1,8,12,16,21,40],
		[0,1,2,40,114],
		[0,4,160,263],
		[0,4,30,49,51,87,526,1027,1105,1387,1807,2637],
		[0,8,10,18,39,74,146,307,452,4737],
		[0,1,2,7,9,17,80,410,1526,1921,32859,33566,38931],
		[0,5,6,10,12,24,27,95,372,494,924,1409,3492,4248,9137,66043,103369,156899],
		[0,1,2,3,4,45,125,351,697,24337,102940,266194,341855,419857],
		[0,1,2,3,9,16,1705,2082,2126,8177,12753,15410,52642,80493,83235,88387,99444,
		 1675361,2495125],
		[0,2,6,8,9,11,20,50,93,152,183,2137,13671,44794,486954,741908,4803258,
		  5692573],
		[0,1,5,6,44,53,470,2847,3433,4906,13654,14710,400447,1797382,2744492,
		  18775974,23541521],
		[0,4,9,10,16,33,83,117,318,451,5759,10015,128975,171834,211256,347608,
		  1278690,2154097,2590798,3427694,5581717,21012301,27023976,72522811,
		  95032729,139166747,171822389],
		[0,5,10,267,344,363,2968,3159,9083,18437,76602,147614,1246902,1593138,
		  2035574,6529391,9511830,11340287,29565945,281666026,677946848] ]
};

return HealPixTables;

});
/***************************************
 * Copyright 2009 The Closure Library Authors. All Rights Reserved. (Apache License, Version 2.0)
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Long',[],function() {


/**************************************************************************************************************/

/**
*	@constructor Long
*	Long class for only unsigned integers
*/

/**
 * Constructs a 64-bit two's-complement integer, given its low and high 32-bit
 * values as *signed* integers.  See the from* functions below for more
 * convenient ways of constructing Longs.
 *
 * The internal representation of a long is the two given signed, 32-bit values.
 * We use 32-bit pieces because these are the size of integers on which
 * Javascript performs bit-operations.  For operations like addition and
 * multiplication, we split each number into 16-bit pieces, which can easily be
 * multiplied within Javascript's floating-point representation without overflow
 * or change in sign.
 *
 * In the algorithms below, we frequently reduce the negative case to the
 * positive case by negating the input(s) and then post-processing the result.
 * Note that we must ALWAYS check specially whether those values are MIN_VALUE
 * (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
 * a positive number, it overflows back into a negative).  Not handling this
 * case would often result in infinite recursion.
 *
 * @param {number} low  The low (signed) 32 bits of the long.
 * @param {number} high  The high (signed) 32 bits of the long.
 * @constructor
 */
var Long = function(low, high) {
  /**
   * @type {number}
   * @private
   */
  this.low_ = low | 0;  // force into 32 signed bits.

  /**
   * @type {number}
   * @private
   */
  this.high_ = high | 0;  // force into 32 signed bits.
};

/**
 * A cache of the Long representations of small integer values.
 * @type {!Object}
 * @private
 */
Long.IntCache_ = {};

/**
 * Returns a Long representing the given (32-bit) integer value.
 * @param {number} value The 32-bit integer in question.
 * @return {!Long} The corresponding Long value.
 */
Long.fromInt = function(value) {
  if (-128 <= value && value < 128) {
    var cachedObj = Long.IntCache_[value];
    if (cachedObj) {
      return cachedObj;
    }
  }

  var obj = new Long(value | 0, value < 0 ? -1 : 0);
  if (-128 <= value && value < 128) {
    Long.IntCache_[value] = obj;
  }
  return obj;
};

/**
 * Returns a Long representing the given value, provided that it is a finite
 * number.  Otherwise, zero is returned.
 * @param {number} value The number in question.
 * @return {!Long} The corresponding Long value.
 */
Long.fromNumber = function(value) {
  if (isNaN(value) || !isFinite(value)) {
    return Long.ZERO;
  } else if (value <= -Long.TWO_PWR_63_DBL_) {
    return Long.MIN_VALUE;
  } else if (value + 1 >= Long.TWO_PWR_63_DBL_) {
    return Long.MAX_VALUE;
  } else if (value < 0) {
    return Long.fromNumber(-value).negate();
  } else {
    return new Long(
        (value % Long.TWO_PWR_32_DBL_) | 0,
        (value / Long.TWO_PWR_32_DBL_) | 0);
  }
};

/**
 * Returns a Long representing the 64-bit integer that comes by concatenating
 * the given high and low bits.  Each is assumed to use 32 bits.
 * @param {number} lowBits The low 32-bits.
 * @param {number} highBits The high 32-bits.
 * @return {!Long} The corresponding Long value.
 */
Long.fromBits = function(lowBits, highBits) {
  return new Long(lowBits, highBits);
};

/**
 * Number used repeated below in calculations.  This must appear before the
 * first call to any from* function below.
 * @type {number}
 * @private
 */
Long.TWO_PWR_16_DBL_ = 1 << 16;


/**
 * @type {number}
 * @private
 */
Long.TWO_PWR_24_DBL_ = 1 << 24;


/**
 * @type {number}
 * @private
 */
Long.TWO_PWR_32_DBL_ =
    Long.TWO_PWR_16_DBL_ * Long.TWO_PWR_16_DBL_;


/**
 * @type {number}
 * @private
 */
Long.TWO_PWR_64_DBL_ =
    Long.TWO_PWR_32_DBL_ * Long.TWO_PWR_32_DBL_;


/**
 * @type {number}
 * @private
 */
Long.TWO_PWR_63_DBL_ =
    Long.TWO_PWR_64_DBL_ / 2;


/** @type {!Long} */
Long.ZERO = Long.fromInt(0);


/** @type {!Long} */
Long.ONE = Long.fromInt(1);

/** @type {!Long} */
Long.MAX_VALUE =
    Long.fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0);


/** @type {!Long} */
Long.MIN_VALUE = Long.fromBits(0, 0x80000000 | 0);

/**
 * @type {!Long}
 * @private
 */
Long.TWO_PWR_24_ = Long.fromInt(1 << 24);


/** @return {number} The value, assuming it is a 32-bit integer. */
Long.prototype.toInt = function() {
  return this.low_;
};

/** @return {number} The closest floating-point representation to this value. */
Long.prototype.toNumber = function() {
  return this.high_ * Long.TWO_PWR_32_DBL_ +
         this.getLowBitsUnsigned();
};

/** @return {number} The low 32-bits as an unsigned value. */
Long.prototype.getLowBitsUnsigned = function() {
  return (this.low_ >= 0) ?
      this.low_ : Long.TWO_PWR_32_DBL_ + this.low_;
};

/** @return {boolean} Whether this value is zero. */
Long.prototype.isZero = function() {
  return this.high_ == 0 && this.low_ == 0;
};


/** @return {boolean} Whether this value is negative. */
Long.prototype.isNegative = function() {
  return this.high_ < 0;
};


/** @return {boolean} Whether this value is odd. */
Long.prototype.isOdd = function() {
  return (this.low_ & 1) == 1;
};


/**
 * @param {Long} other Long to compare against.
 * @return {boolean} Whether this Long equals the other.
 */
Long.prototype.equals = function(other) {
  return (this.high_ == other.high_) && (this.low_ == other.low_);
};

/**
 * @param {Long} other Long to compare against.
 * @return {boolean} Whether this Long is less than the other.
 */
Long.prototype.lessThan = function(other) {
  return this.compare(other) < 0;
};

/**
 * @param {Long} other Long to compare against.
 * @return {boolean} Whether this Long is greater than or equal to the other.
 */
Long.prototype.greaterThanOrEqual = function(other) {
  return this.compare(other) >= 0;
};


/**
 * Compares this Long with the given one.
 * @param {Long} other Long to compare against.
 * @return {number} 0 if they are the same, 1 if the this is greater, and -1
 *     if the given one is greater.
 */
Long.prototype.compare = function(other) {
  if (this.equals(other)) {
    return 0;
  }

  var thisNeg = this.isNegative();
  var otherNeg = other.isNegative();
  if (thisNeg && !otherNeg) {
    return -1;
  }
  if (!thisNeg && otherNeg) {
    return 1;
  }

  // at this point, the signs are the same, so subtraction will not overflow
  if (this.subtract(other).isNegative()) {
    return -1;
  } else {
    return 1;
  }
};

/** @return {!Long} The negation of this value. */
Long.prototype.negate = function() {
  if (this.equals(Long.MIN_VALUE)) {
    return Long.MIN_VALUE;
  } else {
    return this.not().add(Long.ONE);
  }
};


/**
 * Returns the sum of this and the given Long.
 * @param {Long} other Long to add to this one.
 * @return {!Long} The sum of this and the given Long.
 */
Long.prototype.add = function(other) {
  // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

  var a48 = this.high_ >>> 16;
  var a32 = this.high_ & 0xFFFF;
  var a16 = this.low_ >>> 16;
  var a00 = this.low_ & 0xFFFF;

  var b48 = other.high_ >>> 16;
  var b32 = other.high_ & 0xFFFF;
  var b16 = other.low_ >>> 16;
  var b00 = other.low_ & 0xFFFF;

  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
  c00 += a00 + b00;
  c16 += c00 >>> 16;
  c00 &= 0xFFFF;
  c16 += a16 + b16;
  c32 += c16 >>> 16;
  c16 &= 0xFFFF;
  c32 += a32 + b32;
  c48 += c32 >>> 16;
  c32 &= 0xFFFF;
  c48 += a48 + b48;
  c48 &= 0xFFFF;
  return Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);
};


/**
 * Returns the difference of this and the given Long.
 * @param {Long} other Long to subtract from this.
 * @return {!Long} The difference of this and the given Long.
 */
Long.prototype.subtract = function(other) {
  return this.add(other.negate());
};


/**
 * Returns the product of this and the given long.
 * @param {Long} other Long to multiply with this.
 * @return {!Long} The product of this and the other.
 */
Long.prototype.multiply = function(other) {
  if (this.isZero()) {
    return Long.ZERO;
  } else if (other.isZero()) {
    return Long.ZERO;
  }

  if (this.equals(Long.MIN_VALUE)) {
    return other.isOdd() ? Long.MIN_VALUE : Long.ZERO;
  } else if (other.equals(Long.MIN_VALUE)) {
    return this.isOdd() ? Long.MIN_VALUE : Long.ZERO;
  }

  if (this.isNegative()) {
    if (other.isNegative()) {
      return this.negate().multiply(other.negate());
    } else {
      return this.negate().multiply(other).negate();
    }
  } else if (other.isNegative()) {
    return this.multiply(other.negate()).negate();
  }

  // If both longs are small, use float multiplication
  if (this.lessThan(Long.TWO_PWR_24_) &&
      other.lessThan(Long.TWO_PWR_24_)) {
    return Long.fromNumber(this.toNumber() * other.toNumber());
  }

  // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
  // We can skip products that would overflow.

  var a48 = this.high_ >>> 16;
  var a32 = this.high_ & 0xFFFF;
  var a16 = this.low_ >>> 16;
  var a00 = this.low_ & 0xFFFF;

  var b48 = other.high_ >>> 16;
  var b32 = other.high_ & 0xFFFF;
  var b16 = other.low_ >>> 16;
  var b00 = other.low_ & 0xFFFF;

  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
  c00 += a00 * b00;
  c16 += c00 >>> 16;
  c00 &= 0xFFFF;
  c16 += a16 * b00;
  c32 += c16 >>> 16;
  c16 &= 0xFFFF;
  c16 += a00 * b16;
  c32 += c16 >>> 16;
  c16 &= 0xFFFF;
  c32 += a32 * b00;
  c48 += c32 >>> 16;
  c32 &= 0xFFFF;
  c32 += a16 * b16;
  c48 += c32 >>> 16;
  c32 &= 0xFFFF;
  c32 += a00 * b32;
  c48 += c32 >>> 16;
  c32 &= 0xFFFF;
  c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
  c48 &= 0xFFFF;
  return Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);
};

/** @return {!Long} The bitwise-NOT of this value. */
Long.prototype.not = function() {
  return Long.fromBits(~this.low_, ~this.high_);
};


/**
 * Returns the bitwise-AND of this Long and the given one.
 * @param {Long} other The Long with which to AND.
 * @return {!Long} The bitwise-AND of this and the other.
 */
Long.prototype.and = function(other) {
  return Long.fromBits(this.low_ & other.low_,
                                 this.high_ & other.high_);
};


/**
 * Returns the bitwise-OR of this Long and the given one.
 * @param {Long} other The Long with which to OR.
 * @return {!Long} The bitwise-OR of this and the other.
 */
Long.prototype.or = function(other) {
  return Long.fromBits(this.low_ | other.low_,
                                 this.high_ | other.high_);
};

/**
 * Returns this Long with bits shifted to the right by the given amount, with
 * the new top bits matching the current sign bit.
 * @param {number} numBits The number of bits by which to shift.
 * @return {!Long} This shifted to the right by the given amount, with
 *     zeros placed into the new leading bits.
 */
Long.prototype.shiftRightUnsigned = function(numBits) {
  numBits &= 63;
  if (numBits == 0) {
    return this;
  } else {
    var high = this.high_;
    if (numBits < 32) {
      var low = this.low_;
      return Long.fromBits(
          (low >>> numBits) | (high << (32 - numBits)),
          high >>> numBits);
    } else if (numBits == 32) {
      return Long.fromBits(high, 0);
    } else {
      return Long.fromBits(high >>> (numBits - 32), 0);
    }
  }
};

/**************************************************************************************************************/

return Long;

});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

/** 
 *	Module which contains all the maths stuff
 */
define('HEALPixBase',['./HEALPixTables','./Long'], function(HealPixTables,Long) {

/**************************************************************************************************************/

var HALF_PI = 3.14159265/2;

var lonLat2ang = function(lon, lat)
{
	if ( lon < 0 )
		lon += 360;

	var phi = lon * Math.PI / 180.;
	
	var theta = ( -lat + 90. ) * Math.PI / 180.;
	return [phi, theta];
}

/**************************************************************************************************************/

/** Returns the remainder of the division {@code v1/v2}.
  The result is non-negative.
  @param v1 dividend; can be positive or negative
  @param v2 divisor; must be positive
  @return Remainder of the division; positive and smaller than {@code v2} */
var fmodulo = function(v1, v2)
{
	if (v1>=0.)
		return (v1<v2) ? v1 : v1%v2;
	var tmp=v1%v2+v2;
	return (tmp==v2) ? 0. : tmp;
}

/**************************************************************************************************************/

var spread_bits = function(v)
{
	return (HealPixTables.utab[ v      &0xff])      | ((HealPixTables.utab[(v>>> 8)&0xff])<<16)
		| ((HealPixTables.utab[(v>>>16)&0xff])<<32) | ((HealPixTables.utab[(v>>>24)&0xff])<<48);
}

/**************************************************************************************************************/

var xyf2nest = function(ix, iy, face_num, order)
{
    return ((face_num)<<(2*order)) +
     		 spread_bits(ix) + (spread_bits(iy)<<1);
}

/**************************************************************************************************************/

var loc2pix = function(order, phi, theta)
{
	var nside = Math.pow(2, order);
	var z = Math.cos(theta);
	var phi = phi;

	var loc = {
		phi: phi,
		theta: theta,
		z: z
	}
	if (Math.abs(z)>(9./10.))
	{
	  loc.sth = Math.sin(theta);
	  loc.have_sth=true;
	}

	var inv_halfpi = 2./Math.PI;
	var tt = fmodulo((phi*inv_halfpi),4.0);// in [0,4)

	var za = Math.abs(z);
	if (za<=2./3.) // Equatorial region
	{
		var temp1 = nside*(0.5+tt);
        var temp2 = nside*(z*0.75);

        var jp = Long.fromNumber(temp1 - temp2);
        var jm = Long.fromNumber(temp1 + temp2);
        var ifp = jp.shiftRightUnsigned(order);
        var ifm = jm.shiftRightUnsigned(order);
        var face_num;
        if ( ifp.equals(ifm) )
        {
        	face_num = ifp.or(Long.fromInt(4));
        }
        else
        {
        	if ( ifp.lessThan(ifm) )
        	{
        		face_num = ifp;
        	}
        	else
        	{
        		face_num = ifm.add(Long.fromInt(8));
        	}
        }

        var nSideMinusOne = Long.fromNumber(nside-1);
        var ix = jm.and( nSideMinusOne );
        var iy = nSideMinusOne.subtract( jp.and(nSideMinusOne) );

        return xyf2nest(ix.toInt(),iy.toInt(),face_num.toInt(), order);

	}
		else // polar region, za > 2/3
	{
		var ntt = parseInt( Math.min( 3, parseInt(tt) ) );
		var tp = tt-ntt;
		var tmp = ( (za < (9./10.)) || (!loc.have_sth) ) ?
						nside*Math.sqrt(3*(1-za)) :
						nside*loc.sth/Math.sqrt((1.+za)/3.);

		var jp = Long.fromNumber(tp*tmp);
		var jm = Long.fromNumber((1.0-tp)*tmp);
		var lNside = Long.fromNumber(nside);
		var nSideMinusOne = Long.fromNumber(nside-1.);
		var lOne = Long.fromInt(1);
		if ( jp.greaterThanOrEqual(lNside) )
			jp = nSideMinusOne;
		if ( jm.greaterThanOrEqual(lNside) )
			jm = nSideMinusOne;

		if (z>=0)
		{
			return xyf2nest( lNside.subtract(jm).subtract(lOne).toInt(), lNside.subtract(jp).subtract(lOne).toInt(), ntt, order );
		}
		else
		{
			return xyf2nest( jp.toInt(), jm.toInt(), ntt+8, order );
		}
	}
}

/**************************************************************************************************************/

var HEALPixBase = {
	compress_bits: function(v){
		//  raw  = v & 0x5555555555555 in place of raw = v & 0x5555555555555555
		//		--> still not resolved, dunno why
		//
		
		// in Java implementation mask == 0x5555555555555555
		// var raw = v & 0x5555555555555; // v & 101010101010101010101010101010101010101010101010101010101010101
										  // // raw>>>15 = 0101010101010101010101010101010101010101010101010
		// var dec = raw>>>15;
		// raw |= dec;				  // 101010101010101111111111111111111111111111111111111111111111111
		// var raw1 = (raw&0xffff);
		// var dec2 = raw>>>31;
		// var raw2 = (dec2&0xffff);
		
		var longV = Long.fromNumber(v);
		var longMask = Long.fromNumber(0x5555555555555);
		var raw = longV.and(longMask);
		var dec = raw.shiftRightUnsigned(15);
		raw = raw.or(dec);
		var raw1 = (raw.and(Long.fromNumber(0xffff))).toInt();
		var dec2 = raw.shiftRightUnsigned(32);
		var raw2 = (dec2.and(Long.fromNumber(0xffff))).toInt();
		
		return HealPixTables.ctab[raw1&0xff] | (HealPixTables.ctab[raw1>>>8]<< 4)
			| (HealPixTables.ctab[raw2&0xff]<<16) | (HealPixTables.ctab[raw2>>>8]<<20);
	},

	/**
	 *	Function describing a location on the sphere
	 */
	fxyf: function(_fx,_fy,_face){	
		var jr = HealPixTables.jrll[_face] - _fx - _fy;
		var z = 0;
		var phi = 0;
		var sth = 0;
		var have_sth = false;

		var nr;
		if (jr<1){
			nr = jr;
			var tmp = nr*nr/3.;
			z = 1 - tmp;
			if (z>0.99) { sth=Math.sqrt(tmp*(2.-tmp)); have_sth=true; }
		} else if (jr>3){
			nr = 4-jr;
			var tmp = nr*nr/3.;
			z = tmp - 1;
			if (z<-0.99) {
				sth=Math.sqrt(tmp*(2.-tmp)); 
				have_sth=true;
			}
		} else {
			nr = 1;
			z = (2-jr)*2./3.;
		}

		var tmp=HealPixTables.jpll[_face]*nr+_fx-_fy;
		if (tmp<0) tmp+=8;
		if (tmp>=8) tmp-=8;
		
		phi = (nr<1e-15) ? 0 : (0.5*HALF_PI*tmp)/nr;
		
		var st = (have_sth) ? sth : Math.sqrt((1.0-z)*(1.0+z));
		return [st*Math.cos(phi), st*Math.sin(phi), z];
	},

	/**
	 *	Static function
	 *	Convert nside to order
	 *	(ilog2(nside))
	 */
	nside2order: function(arg){
		var res=0;
		while (arg > 0x0000FFFF) { res+=16; arg>>>=16; }
		if (arg > 0x000000FF) { res|=8; arg>>>=8; }
		if (arg > 0x0000000F) { res|=4; arg>>>=4; }
		if (arg > 0x00000003) { res|=2; arg>>>=2; }
		if (arg > 0x00000001) { res|=1; }
		return res;
	},

	/**
	 *	Returns pixel index of point on sphere
	 *
	 *	@param order Tile order
	 *	@param lon Longitude
	 *	@param lat Latitude
	 */
	lonLat2pix: function(order, lon, lat){
		var loc = lonLat2ang( lon, lat );
		return loc2pix( order, loc[0], loc[1] );
	}
};

/**************************************************************************************************************/

return HEALPixBase;

});
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('HEALPixTiling',['./Tile', './HEALPixBase', './GeoBound', './EquatorialCoordinateSystem', './Numeric'], 
	function(Tile, HEALPixBase, GeoBound, CoordinateSystem, Numeric) {

/**************************************************************************************************************/
 
/** @constructor
 *	HEALPixTiling constructor
 *	
 *	@param order Starting tiling order
 *	@param options Options
 *		<ul>
 *			<li>coordSystem: Coordinate system of the given tiling</li>
 *		</ul>
 *	
 */
var HEALPixTiling = function(order, options)
{
	this.order = order;
	this.nside = Math.pow(2,this.order);
	this.coordSystem = options.coordSystem || "EQ";
}

/**************************************************************************************************************/

/** 
	Generate the tiles for level zero
 */
HEALPixTiling.prototype.generateLevelZeroTiles = function( config, tilePool )
{	
	config.skirt = false;
	config.cullSign = -1;
	config.tesselation = 5;
	// TODO : change name to avoid ambiguity
	config.coordSystem = this.coordSystem;
	this.coordinateSystem = config.coordinateSystem;

	var level0Tiles = [];
	
	var qpf = Math.pow(this.nside,2); // quad per face
	var nFaces = 12;
	var nQuads = nFaces * qpf;
	
	for (var i = 0; i < nQuads; i++){
		var face = Math.floor(i/qpf);
		var tile = new HEALPixTile(this.order, i, face);
		tile.config = config;
		level0Tiles.push( tile );
	}

	return level0Tiles;
}

// Get all the coordinates of a geometry
var _getGeometryCoordinates = function( geometry )
{
	var coords;
	switch ( geometry.type )
	{
	case "Point":
		coords = [];
		coords.push( geometry.coordinates );
		break;
	case "MultiPoint":
	case "LineString":
		coords = geometry.coordinates;
		break;
	case "MultiLineString":
		coords = [];
		for ( var n = 0; n < geometry.coordinates.length; n++ )
		{
			coords = coords.concat( geometry.coordinates[n] );
		}
		break;
	case "Polygon":
		coords = geometry.coordinates[0];
		break;
	case "MultiPolygon":
		coords = [];
		for ( var n = 0; n < geometry.coordinates.length; n++ )
		{
			coords = coords.concat( geometry.coordinates[n][0] );
		}
		break;
	case "GeometryCollection":
		coords = [];
		for ( var n = 0; n < geometry.geometries.length; n++ )
		{
			coords = coords.concat( _getGeometryCoordinates(geometry.geometries[n]) );
		}
		break;
	}
	return coords;
}

/**************************************************************************************************************/

/** 
	Get the level zero tiles that overlaps the given geometry
 */
HEALPixTiling.prototype.getOverlappedLevelZeroTiles = function( geometry )
{	
	var tileIndices = [];

	var coords = _getGeometryCoordinates( geometry );
	if ( !coords )
	{
		console.log("Invalid geometry type or not supported.");
		return tileIndices;
	}
		
	var indexMap = {};
	for ( var i = 0; i < coords.length; i++ )
	{
		var index = this.lonlat2LevelZeroIndex( coords[i][0], coords[i][1] );
		if ( !indexMap[index] )
		{
			indexMap[ index ] = true;
			tileIndices.push( index );
		}
	}
	
	return tileIndices;
}

/**************************************************************************************************************/

/** 
	Locate a level zero tile
 */
HEALPixTiling.prototype.lonlat2LevelZeroIndex = function(lon,lat)
{	
	if ( this.coordSystem != "EQ" )
	{
		var geo = this.coordinateSystem.convert( [lon, lat], 'EQ', this.coordSystem );
		lon = geo[0];
		lat = geo[1];
	}

	return HEALPixBase.lonLat2pix( this.order, lon, lat );
}

/**************************************************************************************************************/

/**
 	Return tile of given longitude/latitude from tiles array if exists, null otherwise
 */
HEALPixTiling.prototype.findInsideTile = function(lon, lat, tiles)
{
	if ( this.coordSystem != "EQ" )
	{
		var geo = this.coordinateSystem.convert( [lon, lat], 'EQ', this.coordSystem );
		lon = geo[0];
		lat = geo[1];
	}

	for ( var i=0; i<tiles.length; i++ )
	{
		var tile = tiles[i];
		var index = HEALPixBase.lonLat2pix( tile.order, lon, lat );
		if ( index == tile.pixelIndex )
			return tile;
	}
	return null;
}

/**************************************************************************************************************/

/** @constructor
	Tile constructor
	
		Quadrilateral which composes one tile of HEALPix sphere
		
		nside : 2^order
		order : log2(nside);
		pix : pixel index number
		face : face number = [0..11]
 */
var HEALPixTile = function( order, pix, face )
{
    // Call ancestor constructor
    Tile.prototype.constructor.call(this);
	
	this.order = order;
	this.nside = Math.pow(2, this.order);
	this.pixelIndex = pix;
	this.face = face;

	// Compute texture transform
/*	var width = 1728/64;
	var height = 1856/64;
	this.texTransform = [64/1728, 64/1856, ((this.pixelIndex % width))/width, ((Math.floor(this.pixelIndex/width))/height)];*/

	this.geoBound = null;
}

/**************************************************************************************************************/

/** inherits from Tile */
HEALPixTile.prototype = new Tile;

/**************************************************************************************************************/

/**
	Create the children
 */
HEALPixTile.prototype.createChildren = function()
{
	// Create the children
	
	var child00 = new HEALPixTile(this.order + 1, this.pixelIndex*4, this.face);
	var child10 = new HEALPixTile(this.order + 1, this.pixelIndex*4+2, this.face);
	var child01 = new HEALPixTile(this.order + 1, this.pixelIndex*4+1, this.face);
	var child11 = new HEALPixTile(this.order + 1, this.pixelIndex*4+3, this.face);
	
	child00.initFromParent( this, 0, 0 );
	child10.initFromParent( this, 1, 0 );
	child01.initFromParent( this, 0, 1 );
	child11.initFromParent( this, 1, 1 );
	
	this.children = [ child00, child10, child01, child11 ];

}

/**************************************************************************************************************/

/**
	Compute the local matrix for the tile
 */
HEALPixTile.prototype.computeLocalMatrix = function(vertices){
	var matrix = mat4.create();
	
	var east = vec3.create();
	var north = vec3.create();
	var up = vec3.create();
	
	var mx = 0;
	var my = 0;
	var mz = 0;
	for(var i=0; i<vertices.length; i++){
		mx+=vertices[i][0];
		my+=vertices[i][1];
		mz+=vertices[i][2];
	}
	var barycenter = vec3.create([mx/vertices.length,my/vertices.length,mz/vertices.length]);
	
	vec3.set(barycenter,up);
	vec3.normalize(up);
	
	vec3.subtract(vertices[0],vertices[3],north);
	
	vec3.cross(up, north, east);
	vec3.normalize(east);
	vec3.cross(up, east, north);
	vec3.normalize(north);
		
	matrix[0] = east[0];
	matrix[1] = east[1];
	matrix[2] = east[2];
	matrix[3] = 0.0;
	
	matrix[4] = north[0];
	matrix[5] = north[1];
	matrix[6] = north[2];
	matrix[7] = 0.0;
	
	matrix[8] = up[0];
	matrix[9] = up[1];
	matrix[10] = up[2];
	matrix[11] = 0.0;
	
	matrix[12] = barycenter[0];
	matrix[13] = barycenter[1];
	matrix[14] = barycenter[2];
	matrix[15] = 1.0;
	
	return matrix;
}

/**************************************************************************************************************/

/**
	Generate vertices for tile
 */
HEALPixTile.prototype.generateVertices = function()
{
	// Build the vertices
	var size = this.config.tesselation;
	var worldSpaceVertices = new Array();
	var step = 1./(size - 1);
	
	// xyf calculation
	var pix=this.pixelIndex&(this.nside*this.nside-1);
	var ix = HEALPixBase.compress_bits(pix);
	var iy = HEALPixBase.compress_bits(pix>>>1);
	var coordinateSystem = this.config.coordinateSystem;
	// Compute array of worldspace coordinates
	for(var u = 0; u < size; u++){
		for(var v = 0; v < size; v++){

			var vertice = HEALPixBase.fxyf((ix+u*step)/this.nside, (iy+v*step)/this.nside, this.face);

			// Take sphere radius into account
			vertice[0] *= this.config.coordinateSystem.radius;
			vertice[1] *= this.config.coordinateSystem.radius;
			vertice[2] *= this.config.coordinateSystem.radius;
			
			if ( this.config.coordSystem != 'EQ' )
			{
				var geo = coordinateSystem.from3DToGeo( vertice );
				var eq = coordinateSystem.convert(geo, this.config.coordSystem, 'EQ');
				worldSpaceVertices[u*size + v] = coordinateSystem.fromGeoTo3D( eq );
			}
			else
			{
				worldSpaceVertices[u*size + v] = vertice;
			}
		}
	}
	
	// Compute geoBound using corners of tile
	this.geoBound = new GeoBound();

	var corners = [];
	corners.push( coordinateSystem.from3DToGeo( worldSpaceVertices[0] ) );
	corners.push( coordinateSystem.from3DToGeo( worldSpaceVertices[size-1] ) );
	corners.push( coordinateSystem.from3DToGeo( worldSpaceVertices[size*(size-1)] ) );
	corners.push( coordinateSystem.from3DToGeo( worldSpaceVertices[size*size-1] ) );

	this.geoBound.computeFromCoordinates( corners );

	// Compute tile matrix
	this.matrix = this.computeLocalMatrix(worldSpaceVertices);	
	var invMatrix = mat4.create();
	mat4.inverse( this.matrix, invMatrix );
	this.inverseMatrix = invMatrix;
	
	// Compute tile matrix
	/*var center = HEALPixBase.fxyf((ix+0.5)/this.nside, (iy+0.5)/this.nside, face);
	var geoCenter = coordinateSystem.from3DToGeo(center);
	this.matrix = coordinateSystem.getLHVTransform( geoCenter );
	var invMatrix = mat4.create();
	mat4.inverse( this.matrix, invMatrix );
	this.inverseMatrix = invMatrix;*/
	
	// Build the vertices
	var vertices = new Float32Array( 3*size*size );
	
	// Vertex coordinates in local space
	var vertexOffset = 0;
	for(var i=0;i<worldSpaceVertices.length;i++){
		vertices[vertexOffset] = invMatrix[0]*worldSpaceVertices[i][0] + invMatrix[4]*worldSpaceVertices[i][1] + invMatrix[8]*worldSpaceVertices[i][2] + invMatrix[12];
		vertices[vertexOffset+1] = invMatrix[1]*worldSpaceVertices[i][0] + invMatrix[5]*worldSpaceVertices[i][1] + invMatrix[9]*worldSpaceVertices[i][2] + invMatrix[13];
		vertices[vertexOffset+2] = invMatrix[2]*worldSpaceVertices[i][0] + invMatrix[6]*worldSpaceVertices[i][1] + invMatrix[10]*worldSpaceVertices[i][2] + invMatrix[14];
		vertexOffset += 3;
	}
	
	return vertices;
}

/**************************************************************************************************************/

return HEALPixTiling;

});
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define( 'RendererTileData',[],function() {

/**************************************************************************************************************/

/** @constructor
	RendererTileData constructor
	Contains a list of renderables for the tiles
	
	A renderable contains the following attributes/methods :
		Attributes :
			bucket : the renderable bucket
			initChild (opt) : create a child at "init" time (children are created but not yet loaded)
			generateChild (opt) : generate a child at "generate" time (children are loaded)
			dispose : discard any gl data
			add : add a geometry to the renderable
			remove: remove a geometry from the renderable
 */
var RendererTileData = function(manager)
{
	this.manager = manager;
	this.renderables = [];
}

/**************************************************************************************************************/

/**
 * Initialize a child tile
 */
RendererTileData.prototype.initChild = function(childTile,i,j)
{
	var childData;
	for ( var n = 0; n < this.renderables.length; n++ ) 
	{
		if ( this.renderables[n].initChild )
		{		
			var r = this.renderables[n].initChild(i,j,childTile);
			if (r)
			{
				if (!childData)
					childData = childTile.extension.renderer = new RendererTileData(this.manager);
				childData.renderables.push( r );
			}
		}
	}
}

/**************************************************************************************************************/

/**
 * Traverse the renderer data
 */
RendererTileData.prototype.traverse = function(tile,isLeaf)
{
	for ( var i = 0; i < this.renderables.length; i++ ) 
	{
		var renderable = this.renderables[i];
		var bucket = renderable.bucket;
		if ( bucket.layer._visible && bucket.layer._opacity > 0 )
		{
			if ( renderable.traverse )
			{
				renderable.traverse( this.manager, tile, isLeaf  );
			}
			else
			{
				if ( renderable.hasChildren 
					&& !isLeaf )
					continue;
				
				this.manager.renderables.push( renderable );
			}
		}
	}
}

/**************************************************************************************************************/

/**
	Get a renderable from the tile, given the bucket
 */
RendererTileData.prototype.getRenderable = function(bucket)
{
	for ( var i=0; i < this.renderables.length; i++ )
	{
		if ( bucket == this.renderables[i].bucket )
		{
			return this.renderables[i];
		}
	}
	return null;
}

/**************************************************************************************************************/

/**
	Dispose renderable data from tile
 */
RendererTileData.prototype.dispose = function(renderContext,tilePool)
{
	for ( var i=0; i < this.renderables.length; i++ )
	{
		this.renderables[i].dispose(renderContext,tilePool);
	}
	this.renderables.length = 0;
}

/**************************************************************************************************************/

return RendererTileData;

});
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define( 'RasterOverlayRenderer',['./Program','./Tile','./ImageRequest','./RendererTileData'], function(Program, Tile, ImageRequest, RendererTileData) {

/**************************************************************************************************************/

/** 
	@constructor
	RasterOverlayRenderer constructor
 */
var RasterOverlayRenderer = function(globe)
{
	this.vertexShader = "\
	attribute vec3 vertex;\n\
	attribute vec2 tcoord;\n\
	uniform mat4 modelViewMatrix;\n\
	uniform mat4 projectionMatrix;\n\
	uniform vec4 textureTransform; \n\
	varying vec2 texCoord;\n\
	void main(void) \n\
	{\n\
		gl_Position = projectionMatrix * modelViewMatrix * vec4(vertex, 1.0);\n\
		texCoord = tcoord * textureTransform.xy + textureTransform.zw;\n\
	}\n\
	";

	this.fragmentShader = "\
	precision lowp float;\n\
	varying vec2 texCoord;\n\
	uniform sampler2D overlayTexture;\n\
	uniform float opacity; \n\
	void main(void)\n\
	{\n\
		gl_FragColor.rgba = texture2D(overlayTexture, texCoord.xy); \n\
		gl_FragColor.a *= opacity; \n\
	}\n\
	";
	
	this.rendererManager = globe.vectorRendererManager;
	this.tileManager = globe.tileManager;
	this.programs = [];
	this.program = this.createProgram( {
		vertexCode: this.vertexShader,
		fragmentCode: this.fragmentShader,
		updateUniforms: null
	});
	
	this.buckets = [];
	this.imageRequests = [];
	this.frameNumber = 0;
	
	
	var self = this;
	for ( var i = 0; i < 4; i++ ) {
		var imageRequest = new ImageRequest({
			successCallback: function(){
				if ( this.renderable )
				{
					if ( this.renderable.bucket.layer.handleImage )
						this.renderable.bucket.layer.handleImage(this);

					this.renderable.ownTexture = self.tileManager.tilePool.createGLTexture(this.image);
					this.renderable.texture = this.renderable.ownTexture;
					this.renderable.uvScale = 1.0;
					this.renderable.uTrans = 0.0;
					this.renderable.vTrans = 0.0;
					this.renderable.updateChildrenTexture();
					this.renderable.onRequestFinished(true);
					this.renderable = null;
					self.tileManager.renderContext.requestFrame();
				}
			},
			failCallback: function(){
				if ( this.renderable )
				{
					this.renderable.onRequestFinished(true);
					this.renderable = null;
				}
			},
			abortCallback: function(){
				//console.log("Raster overlay request abort.");
				if ( this.renderable )
				{
					this.renderable.onRequestFinished(false);
					this.renderable = null;
				}
			}
		});

		this.imageRequests.push( imageRequest );
	}
}

/**************************************************************************************************************/

/** 
	@constructor
	Create a renderable for the overlay.
	There is one renderable per overlay and per tile.
 */
var RasterOverlayRenderable = function( bucket )
{
	this.bucket = bucket;
	this.ownTexture = null;
	this.texture = null;
	this.request = null;
	this.requestFinished = false;
	this.tile = null;
	this.uvScale = 1.0;
	this.uTrans = 0.0;
	this.vTrans = 0.0;
}

/**************************************************************************************************************/

/** 
	Called when a request is started
 */
RasterOverlayRenderable.prototype.onRequestStarted = function(request)
{
	this.request = request;
	this.requestFinished = false;
	var layer = this.bucket.layer;
	if ( layer._numRequests == 0 )
	{
		layer.globe.publish('startLoad',layer);
	}
	layer._numRequests++;
}

/**************************************************************************************************************/

/** 
	Called when a request is finished
 */
RasterOverlayRenderable.prototype.onRequestFinished = function(completed)
{
	this.request = null;
	this.requestFinished = completed;
	var layer = this.bucket.layer;
	layer._numRequests--;
	if ( layer.globe && layer._numRequests == 0 )
	{
		layer.globe.publish('endLoad',layer);
	}
}

/**************************************************************************************************************/

/**
 * Initialize a child renderable
 */
RasterOverlayRenderable.prototype.initChild = function(i,j,childTile)
{				
	// Request finished and no texture  : no init needed for children
/*	// TODO : does not work because sometimes level 0 cannot be loaded
	if (this.requestFinished && !this.ownTexture)
		return null;*/
		
	var renderable = this.bucket.createRenderable();
	renderable.tile = childTile;	
	if ( this.texture )
	{
		renderable.texture = this.texture;
		renderable.uvScale = this.uvScale;
		renderable.uTrans = this.uTrans;
		renderable.vTrans = this.vTrans;
	}
	
	return renderable;
}

/**************************************************************************************************************/

/** 
	Generate child renderable
 */
RasterOverlayRenderable.prototype.generateChild = function( tile )
{
	// Request finished and no texture  : no generate needed for children
/*	// TODO : does not work because sometimes level 0 cannot be loaded
	if (this.requestFinished && !this.ownTexture)
		return;*/

	var r = this.bucket.renderer;
	r.addOverlayToTile( tile, this.bucket, this );
}

/**************************************************************************************************************/

/** 
	Update the children texture
 */
 RasterOverlayRenderable.prototype.updateChildrenTexture = function()
{
	if ( this.tile.children )
	{
		for ( var i = 0; i < 4; i++ )
		{
			var rd = this.tile.children[i].extension.renderer;
			if ( rd )
			{
				var cr = rd.getRenderable(this.bucket);
				if ( cr && !cr.ownTexture )
				{
					cr.updateTextureFromParent( this );
					cr.updateChildrenTexture();
				}
			}
		}
	}
}

/**************************************************************************************************************/

/** 
	Update texture from its parent
 */
RasterOverlayRenderable.prototype.updateTextureFromParent = function( parent )
{
	if ( this.tile.state == Tile.State.LOADED )
	{
		this.texture = parent.texture;
		this.uvScale = parent.uvScale * 0.5;
		this.uTrans = parent.uTrans;
		this.vTrans = parent.vTrans;
		
		this.uTrans += (this.tile.parentIndex & 1) ? this.uvScale : 0;
		this.vTrans += (this.tile.parentIndex & 2) ? this.uvScale : 0;
	}
	else
	{
		this.texture = parent.texture;
		this.uvScale = parent.uvScale;
		this.uTrans = parent.uTrans;
		this.vTrans = parent.vTrans;
	}
}

/**************************************************************************************************************/

/** 
	Traverse renderable : add it to renderables list if there is a texture
	Request the texture
 */
 RasterOverlayRenderable.prototype.traverse = function( manager, tile, isLeaf  )
{
	if ( isLeaf && this.texture )
	{
		manager.renderables.push( this );
	}
	
	if (!this.requestFinished && this.tile.state == Tile.State.LOADED)
	{
		this.bucket.renderer.requestOverlayTextureForTile( this);
	}
}

/**************************************************************************************************************/

/** 
	Dispose the renderable
 */
RasterOverlayRenderable.prototype.dispose = function(renderContext,tilePool)
{
	if ( this.ownTexture ) 
	{
		tilePool.disposeGLTexture(this.ownTexture);
		this.ownTexture = null;
	}
}


/**************************************************************************************************************/

/**
	Bucket constructor for RasterOverlay
 */
var Bucket = function(layer)
{
	this.layer = layer;
	this.renderer = null;
	// TODO : hack
	this.style = layer;
}

/**************************************************************************************************************/

/**
	Create a renderable for this bucket
 */
Bucket.prototype.createRenderable = function()
{
	return new RasterOverlayRenderable(this);
}

/**************************************************************************************************************/

/**
	Add an overlay into the renderer.
	The overlay is added to all loaded tiles.
 */
RasterOverlayRenderer.prototype.addOverlay = function( overlay )
{
	// Initialize num requests to 0
	overlay._numRequests = 0;

	var bucket = new Bucket(overlay);
	bucket.renderer = this;
	bucket.id = this.rendererManager.bucketId++;
	this.buckets.push( bucket );
	
	overlay._bucket = bucket;
	
	for ( var i = 0; i < this.tileManager.level0Tiles.length; i++ )
	{
		var tile = this.tileManager.level0Tiles[i];
		if ( tile.state == Tile.State.LOADED )
		{
			this.addOverlayToTile( tile, bucket );
		}
	}
}

/**************************************************************************************************************/

/**
	Remove an overlay
	The overlay is removed from all loaded tiles.
 */
RasterOverlayRenderer.prototype.removeOverlay = function( overlay )
{
	var index = this.buckets.indexOf( overlay._bucket );
	this.buckets.splice(index,1);
	
	var rc = this.tileManager.renderContext;
	var tp = this.tileManager.tilePool;
	this.tileManager.visitTiles( function(tile) 
			{
				var rs = tile.extension.renderer;
				var renderable = rs ?  rs.getRenderable( overlay._bucket ) : null;
				if ( renderable ) 
				{
					// Remove the renderable
					var index = rs.renderables.indexOf(renderable);
					rs.renderables.splice(index,1);
					
					// Dispose its data
					renderable.dispose(rc,tp);
					
					// Remove tile data if not needed anymore
					if ( rs.renderables.length == 0 )
						delete tile.extension.renderer;
				}
			}
	);
}

/**************************************************************************************************************/

/**
	Add an overlay into a tile.
	Create tile data if needed, and create the renderable for the overlay.
 */
RasterOverlayRenderer.prototype.addOverlayToTile = function( tile, bucket, parentRenderable )
{
	if (!this.overlayIntersects( tile.geoBound, bucket.layer ))
		return;
		
	if ( !tile.extension.renderer )
		tile.extension.renderer = new RendererTileData(this.rendererManager);
	
	var renderable = bucket.createRenderable();
	renderable.tile = tile;
	tile.extension.renderer.renderables.push( renderable );
	
	if ( parentRenderable && parentRenderable.texture )
	{
		renderable.updateTextureFromParent( parentRenderable );
	}
	
	if ( tile.children )
	{
		// Add the overlay to loaded children
		for ( var i = 0; i < 4; i++ )
		{
			if ( tile.children[i].state == Tile.State.LOADED )
			{
				this.addOverlayToTile( tile.children[i], bucket, renderable );
			}
		}
	}

}

/**************************************************************************************************************/

/**
	Create an interpolated for polygon clipping
 */	
var _createInterpolatedVertex = function( t, p1, p2 )
{
	return [ p1[0] + t * (p2[0] - p1[0]), p1[1] + t * (p2[1] - p1[1]) ];
}

/**************************************************************************************************************/

/**
	Clip polygon to a side (used by bound-overlay intersection)
 */	
RasterOverlayRenderer.prototype.clipPolygonToSide = function( coord, sign, value, polygon )
{
	var clippedPolygon = [];

	// iterate through vertices
	for ( var i = 0; i < polygon.length; i++ )
	{
		var p1 = polygon[i];
		var p2 = polygon[ (i+1) % polygon.length ];
		var val1 = p1[coord];
		var val2 = p2[coord];

		// test containement
		var firstInside = (val1 - value) * sign >= 0.0;
		var secondInside = (val2 - value) * sign >= 0.0;
	
		// output vertices for inside polygon
		if ( !firstInside && secondInside )
		{
			var t = (value - val1) / (val2- val1);
			var newPoint = _createInterpolatedVertex( t, p1, p2 );
			clippedPolygon.push( newPoint );
			clippedPolygon.push( p2 );
		}
		else if ( firstInside && secondInside )
		{
			clippedPolygon.push( p2 );
		}
		else if ( firstInside && !secondInside )
		{
			var t = (value - val1) / (val2- val1);
			var newPoint = _createInterpolatedVertex( t, p1, p2 );
			clippedPolygon.push( newPoint );
		}
	}
	
	return clippedPolygon;
}

/**************************************************************************************************************/

/**
	Check the intersection between a geo bound and an overlay
 */	
RasterOverlayRenderer.prototype.overlayIntersects = function( bound, overlay )
{
	if ( overlay.coordinates )
	{
		var c;
		c = this.clipPolygonToSide( 0, 1, bound.west, overlay.coordinates );
		c = this.clipPolygonToSide( 0, -1, bound.east, c );
		c = this.clipPolygonToSide( 1, 1, bound.south, c );
		c = this.clipPolygonToSide( 1, -1, bound.north, c );
		return c.length > 0;
	}
	else if ( overlay.geoBound )
	{
		return overlay.geoBound.intersects( bound );
	}
	
	// No geobound or coordinates : always return true
	return true;
}

/**************************************************************************************************************/

/**
	Generate Raster overlay data on the tile.
	The method is called by TileManager when a new tile has been generated.
 */
RasterOverlayRenderer.prototype.generateLevelZero = function( tile )
{
	// Traverse all overlays
	for ( var i = 0; i < this.buckets.length; i++ )
	{
		this.addOverlayToTile(tile,this.buckets[i]);
	}
}

/**************************************************************************************************************/

/**
	Request the overlay texture for a tile
 */
RasterOverlayRenderer.prototype.requestOverlayTextureForTile = function( renderable )
{	
	if ( !renderable.request )
	{
		var imageRequest;
		for ( var i = 0; i < this.imageRequests.length; i++ )
		{
			if ( !this.imageRequests[i].renderable  ) 
			{
				imageRequest = this.imageRequests[i];
				break;
			}
		}
		
		if ( imageRequest )
		{
			renderable.onRequestStarted(imageRequest);
			imageRequest.renderable = renderable;
			imageRequest.frameNumber = this.frameNumber;
			imageRequest.send(renderable.bucket.layer.getUrl(renderable.tile), renderable.bucket.layer.crossOrigin);
		}
	}
	else
	{
		renderable.request.frameNumber = this.frameNumber;
	}
}

/**************************************************************************************************************/

/**
 	Create program from customShader object
 */
RasterOverlayRenderer.prototype.createProgram = function(customShader)
{
	var program = new Program(this.tileManager.renderContext);
	program.createFromSource(this.vertexShader, customShader.fragmentCode);
	
    // Add program
    program.id = this.programs.length;
    this.programs.push({ 
    	fragmentCode: customShader.fragmentCode,
    	program: program
	});
	return program;
}

/**************************************************************************************************************/

/**
 	Get program if known by renderer, create otherwise
 */
RasterOverlayRenderer.prototype.getProgram = function(customShader) {

	var program;

    for(var id=0; id<this.programs.length; id++)
    {
        if( this.programs[id].fragmentCode == customShader.fragmentCode )
        {
        	program = this.programs[id].program;
        }
    }

    if ( !program )
    {
    	program = this.createProgram(customShader);
    }
    return program;
}

/**************************************************************************************************************/

/**
 *	Render the raster overlays for the given tiles
 */
RasterOverlayRenderer.prototype.render = function( renderables, start, end )
{
	var rc = this.tileManager.renderContext;
 	var gl = rc.gl;

	// Update gl states
	gl.enable(gl.BLEND);
	gl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA );
	gl.depthFunc( gl.LEQUAL );
	
	var modelViewMatrix = mat4.create();
	
	var currentTile = null;
	var currentIB = null;
	var currentProgram = null;

	for ( var n = start; n < end; n++ )
	{
		var renderable = renderables[n];
		var bucket = renderable.bucket;
		var layer = bucket.layer;
		
		var updateUniforms;
		var program;
		if ( layer.customShader )
		{
			program = this.getProgram(layer.customShader);
			updateUniforms = layer.customShader.updateUniforms;
		}
		else
		{
			program = this.getProgram({
				vertexCode: this.vertexShader,
				fragmentCode: this.fragmentShader,
				updateUniforms: null
			});
		}
		
		// Apply program if changed
		if ( program != currentProgram )
		{
			currentProgram = program;
			program.apply();
							
			gl.uniformMatrix4fv(program.uniforms["projectionMatrix"], false, rc.projectionMatrix);
			gl.uniform1i(program.uniforms["overlayTexture"], 0);
			
			// Bind tcoord buffer
			gl.bindBuffer(gl.ARRAY_BUFFER, this.tileManager.tcoordBuffer);
			gl.vertexAttribPointer(program.attributes['tcoord'], 2, gl.FLOAT, false, 0, 0);
		}	
		
		if (updateUniforms)
			updateUniforms(gl, program);
		
		// Bind the vertex buffer
		gl.bindBuffer(gl.ARRAY_BUFFER, renderable.tile.vertexBuffer);
		gl.vertexAttribPointer(program.attributes['vertex'], 3, gl.FLOAT, false, 4*renderable.tile.config.vertexSize, 0);
		
		// Bind the index buffer only if different (index buffer is shared between tiles)
		var indexBuffer = ( renderable.tile.state == Tile.State.LOADED ) ? this.tileManager.tileIndexBuffer.getSolid() : this.tileManager.tileIndexBuffer.getSubSolid(renderable.tile.parentIndex);
		if ( currentIB != indexBuffer )
		{	
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer );
			currentIB = indexBuffer;
		}

		// Bind the tile tile matrix
		mat4.multiply( rc.viewMatrix, renderable.tile.matrix, modelViewMatrix );
		gl.uniformMatrix4fv(program.uniforms["modelViewMatrix"], false, modelViewMatrix);
					
		gl.uniform1f(program.uniforms["opacity"], layer._opacity );
		gl.uniform4f(program.uniforms["textureTransform"], renderable.uvScale, renderable.uvScale, renderable.uTrans, renderable.vTrans );
		
		gl.activeTexture(gl.TEXTURE0);
		gl.bindTexture(gl.TEXTURE_2D, renderable.texture );
		
		// Finally draw the tiles
		gl.drawElements(gl.TRIANGLES, currentIB.numIndices, gl.UNSIGNED_SHORT, 0);
	}
	
	// reset gl states
	gl.disable(gl.BLEND);
	//gl.disable(gl.POLYGON_OFFSET_FILL);
	gl.depthFunc( gl.LESS );
}

/**************************************************************************************************************/

/**
 * Check if renderer is applicable
 */
RasterOverlayRenderer.prototype.canApply = function(type,style)
{
	return false;
}

/**************************************************************************************************************/
									
return RasterOverlayRenderer;

});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Cache',[],function() {

/**
 *	Cache storing <RasterLayer> tile requests in browser's local storage
 *	Due to performance reasons, it's recommended to use it only for tiles of level 0
 *	@param options
 *		<ul>
 *			<li>layer: Layer which will contain the given cache(required)</li>
 *			<li>cacheLevel: the maximum level of tiles to be cached</li>
 *		</ul>
 */
var Cache = function(options) {
	
	this.layer = options.layer;

	this.cacheLevel = options.hasOwnProperty('cacheLevel') ? options.cacheLevel : 1;

	if ( !localStorage.getItem(this.layer.name) )
	{
		// Create cache space in local storage named after layer
		localStorage.setItem(this.layer.name, JSON.stringify({}));
	}

	this._cacheMap = JSON.parse(localStorage.getItem(this.layer.name));

	this.imgCanvas = document.createElement("canvas");
	// Make sure canvas is as big as layer requests
	this.imgCanvas.width = options['tilePixelSize'] || 256;
	this.imgCanvas.height = options['tilePixelSize'] || 256;

	this.imgContext = this.imgCanvas.getContext("2d");
}


/**************************************************************************************************************/

/**
 *	Get tile request from cache for the given tile
 *	@returns The image(TODO: handle elevations) corresponding to the given tile, null if doesn't exist in cache
 */
Cache.prototype.getFromCache = function( tile )
{
	var cachedTileRequest = null;
	if ( this.cacheLevel >= tile.level )
	{
		var tileId = this.layer.getUrl(tile);
		var tileInfo = this._cacheMap[tileId];
		if ( tileInfo )
		{
			// Update access info
			tileInfo.lastAccess = Date.now();

			var image = new Image();
			image.src = tileInfo.dataUrl;
			image.dataType = "byte";
			cachedTileRequest = {
				image: image,
				elevations: tileInfo.elevations
			};
		}
	}
	return cachedTileRequest;
};

/**************************************************************************************************************/

/**
 *	Internal method to generate data url from HTML image object
 */
Cache.prototype._createDataURL = function( image )
{
	// Draw image into canvas element
	this.imgContext.drawImage(image, 0, 0, image.width, image.height);

	// Save image as a data URL
	return this.imgCanvas.toDataURL("image/png");
};

/**************************************************************************************************************/

/**
 *	Store tile request in cache
 */
Cache.prototype.storeInCache = function( tileRequest )
{
	var tile = tileRequest.tile;
	if ( this.cacheLevel >= tile.level )
	{
		var tileId = this.layer.getUrl(tile);
		this._cacheMap[tileId] = {
			dataUrl: this._createDataURL(tileRequest.image),
			elevations: tileRequest.elevations,
			lastAccess: Date.now()
		};
		console.log("Stored for " + tileRequest.image.src);

		// Update local storage with new cache
		localStorage.setItem(this.layer.name, JSON.stringify(this._cacheMap));
	}
};

return Cache;

});
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 define('RasterLayer',['./Utils', './BaseLayer', './RasterOverlayRenderer', './Cache' ], 
	function(Utils, BaseLayer, RasterOverlayRenderer, Cache) {

/**************************************************************************************************************/


/** @name RasterLayer
	@class
	Base class for raster layer
	@augments BaseLayer
	@param options Configuration properties for the RasterLayer. See {@link BaseLayer} for base properties :
		<ul>
			<li>tilePixelSize : the image size for a tile, default is 256.</li>
			<li>numberOfLevels : the maximum number of levels</li> 
			<li>geoBound : the extent of the layer</li>
			<li>cache : Object containing cache options</li>
		</ul>
*/
var RasterLayer = function( options )
{
	BaseLayer.prototype.constructor.call( this, options );
	
	// Base properties
	this.tilePixelSize = -1;
	this.tiling = null;
	this.numberOfLevels = -1;
	this.geoBound = options.geoBound || null;
	this.coordinates = options.coordinates || null;
	this.zIndex = options.zIndex || 0;
	this.crossOrigin = options.crossOrigin || 'anonymous';

	// Init cache if defined
	if ( options.cache )
	{
		options.cache.layer = this;
		this.cache = new Cache(options.cache);
	}
	
	// Internal
	this._overlay = true; 
	this._ready = true; // Ready is use by TileManager
}

/**************************************************************************************************************/

Utils.inherits( BaseLayer,RasterLayer );

/**************************************************************************************************************/

/** 
  Attach the raster layer to the globe
 */
RasterLayer.prototype._attach = function( g )
{
	if ( !this._overlay )
	{
		// Override id of background layer because of unicity of background not overlayed layer
		this.id = 0;
	}

	BaseLayer.prototype._attach.call( this, g );
		
	if ( this._overlay )
	{
		// Create the renderer if needed
		if ( !g.rasterOverlayRenderer )
		{
			var renderer = new RasterOverlayRenderer(g);
			g.vectorRendererManager.renderers.push( renderer );
			g.rasterOverlayRenderer = renderer;
		}
		g.rasterOverlayRenderer.addOverlay(this);
	}
}

/**************************************************************************************************************/

/** 
  Detach the raster layer from the globe
 */
RasterLayer.prototype._detach = function()
{
	// Remove raster from overlay renderer if needed
	if ( this._overlay && this.globe.rasterOverlayRenderer )
	{
		this.globe.rasterOverlayRenderer.removeOverlay(this);
	}
	
	BaseLayer.prototype._detach.call(this);
}

/**************************************************************************************************************/

return RasterLayer;

});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('HEALPixLayer',['./Utils', './HEALPixTiling', './RasterLayer'], 
	function(Utils, HEALPixTiling, RasterLayer) {

/**************************************************************************************************************/

/** @export
	@constructor
	HEALPixLayer constructor
*/

var HEALPixLayer = function(options)
{
	RasterLayer.prototype.constructor.call( this, options );
	
	this.tilePixelSize = options.tilePixelSize || 512;
	this.tiling = new HEALPixTiling( options.baseLevel || 2, options );
	this.numberOfLevels = options.numberOfLevels || 10;
	this.type = "ImageryRaster";
	this.baseUrl = options['baseUrl'];
	this.format = options.format || "jpg";
	this.coordSystem = options.coordSystem || "EQ";
	
	// allsky
	this.levelZeroImage = new Image();
	var self = this;
	this.levelZeroImage.crossOrigin = '';
	this.levelZeroImage.onload = function () 
	{
		self._ready = true;
		
		// Call callback if set
		if (options.onready && options.onready instanceof Function)
		{
			options.onready(self);
		}
		
		// Request a frame
		if ( self.globe )
		{
			self.globe.renderContext.requestFrame();
		}
	}
	this.levelZeroImage.onerror = function(event) {
		self.globe.publish("baseLayersError", self);
		self._ready = false;
		
		console.log("Cannot load " + self.levelZeroImage.src );
	}
	
	this._ready = false;
}

/**************************************************************************************************************/

Utils.inherits(RasterLayer, HEALPixLayer);

/**************************************************************************************************************/

/** 
  Attach the raster layer to the globe
 */
HEALPixLayer.prototype._attach = function( g )
{
	RasterLayer.prototype._attach.call( this, g );

	// Load level zero image now, only for background
	if ( !this._overlay )
	{
		this.levelZeroImage.src = this.baseUrl + "/Norder3/Allsky."+this.format;
	}
}

/**************************************************************************************************************/

/**
 *	Get url from a given tile
 */
HEALPixLayer.prototype.getUrl = function(tile)
{
	var url = this.baseUrl;
	
	url += "/Norder";
	url += tile.order;
	
	url += "/Dir";
	var indexDirectory = Math.floor(tile.pixelIndex/10000) * 10000;
	url += indexDirectory;
	
	url += "/Npix";
	url += tile.pixelIndex;
	url += "."+this.format;
	
	return url;
}


/**************************************************************************************************************/

/**
 *	Generate the level0 texture for the tiles
 */
HEALPixLayer.prototype.generateLevel0Textures = function(tiles,tilePool)
{
	// Create a canvas to build the texture
	var canvas = document.createElement("canvas");
	canvas.width = 128;
	canvas.height = 128;
	
	var context = canvas.getContext("2d");
	
	for ( var i = 0; i < tiles.length; i++ )
	{
		var tile = tiles[i];
		
		// Top left
		var pi = tile.pixelIndex * 4;
		var sx = ( pi % 27) * 64;
		var sy = ( Math.floor(pi /27) ) * 64;
		context.drawImage(this.levelZeroImage,sx,sy,64,64,0,0,64,64);
		
		// Top right
		pi = tile.pixelIndex * 4 + 2;
		var sx = ( pi % 27) * 64;
		var sy = ( Math.floor(pi /27) ) * 64;
		context.drawImage(this.levelZeroImage,sx,sy,64,64,64,0,64,64);
		
		// Bottom left
		pi = tile.pixelIndex * 4 + 1;
		var sx = ( pi % 27) * 64;
		var sy = ( Math.floor(pi /27) ) * 64;
		context.drawImage(this.levelZeroImage,sx,sy,64,64,0,64,64,64);
		
		// Bottom right
		pi = tile.pixelIndex * 4 + 3;
		var sx = ( pi % 27) * 64;
		var sy = ( Math.floor(pi /27) ) * 64;
		context.drawImage(this.levelZeroImage,sx,sy,64,64,64,64,64,64);

		var imgData = context.getImageData(0, 0, 128, 128);
		imgData.dataType = 'byte';
		
		tile.texture = tilePool.createGLTexture( imgData );
		tile.imageSize = 128;
	}
}

/**************************************************************************************************************/

return HEALPixLayer;

});
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 define('OpenSearchLayer',['./FeatureStyle','./VectorRendererManager','./Utils','./BaseLayer','./RendererTileData', './Tile'],
	function(FeatureStyle,VectorRendererManager,Utils,BaseLayer,RendererTileData, Tile) {

/**************************************************************************************************************/

/**	@constructor
 * 	@class
 * 	OpenSearch dynamic layer
 * 	
 * 	@param options Configuration options
 * 		<ul>
			<li>serviceUrl : Url of OpenSearch description XML file(necessary option)</li>
			<li>minOrder : Starting order for OpenSearch requests</li>
			<li>displayProperties : Properties which will be shown in priority</li>
			<li>invertY : a boolean, if set all the image data of current layer is flipped along the vertical axis</li>
		</ul>
*/
var OpenSearchLayer = function(options){
	BaseLayer.prototype.constructor.call( this, options );
	
	this.serviceUrl = options.serviceUrl;
	this.minOrder = options.minOrder || 5;
	this.maxRequests = options.maxRequests || 2;
	this.requestProperties = "";
	this.invertY = options.invertY || false;
	this.coordSystemRequired = options.hasOwnProperty('coordSystemRequired') ? options.coordSystemRequired : true;

	// Set style
	if ( options && options['style'] )
	{
		this.style = options['style'];
	}
	else
	{
		this.style = new FeatureStyle();
	}
	
	this.extId = "os";

	// Used for picking management
	this.features = [];
	// Counter set, indicates how many times the feature has been requested
	this.featuresSet = {};

	// Maximum two requests for now
	this.freeRequests = [];
	this.tilesToLoad = [];
	
	// Build the request objects
	for ( var i =0; i < this.maxRequests; i++ )
	{
		var xhr = new XMLHttpRequest();
		this.freeRequests.push( xhr );
	}
}

/**************************************************************************************************************/

Utils.inherits( BaseLayer, OpenSearchLayer );

/**************************************************************************************************************/

/**
 * 	Attach the layer to the globe
 * 
 * 	@param g The globe
 */
OpenSearchLayer.prototype._attach = function( g )
{
	BaseLayer.prototype._attach.call( this, g );
	this.extId += this.id;
	g.tileManager.addPostRenderer(this);
}

/**************************************************************************************************************/

/** 
  Detach the layer from the globe
 */
OpenSearchLayer.prototype._detach = function()
{
	this.globe.tileManager.removePostRenderer(this);	
	BaseLayer.prototype._detach.call(this);
}

/**************************************************************************************************************/

/**
 * 	Launch request to the OpenSearch service
 */
OpenSearchLayer.prototype.launchRequest = function(tile, url)
{
	var tileData = tile.extension[this.extId];
	var index = null;
	
	if ( this.freeRequests.length == 0 )
	{
		return;
	}
	
	// Set that the tile is loading its data for OpenSearch
	tileData.state = OpenSearchLayer.TileState.LOADING;

	// Add request properties to length
	if ( this.requestProperties != "" )
	{
		url += '&' + this.requestProperties;
	}
		
	// Pusblish the start load event, only if there is no pending requests
	if ( this.maxRequests == this.freeRequests.length )
	{
		this.globe.publish("startLoad",this);
	}
	
	var xhr = this.freeRequests.pop();
	var self = this;
	xhr.onreadystatechange = function(e)
	{
		if ( xhr.readyState == 4 ) 
		{
			if ( xhr.status == 200 )
			{

				var response = JSON.parse(xhr.response);

				tileData.complete = (response.totalResults == response.features.length);
					
				self.updateFeatures(response.features);
				
				for ( var i=response.features.length-1; i >= 0; i-- )
				{
					var feature = response.features[i];
					// Eliminate already added features from response
					var alreadyAdded = self.featuresSet.hasOwnProperty(feature.properties.identifier);
					if ( alreadyAdded )
						response.features.splice(i, 1);

					self.addFeature( feature, tile );
				}
				self.globe.refresh();
			}
			else if ( xhr.status >= 400 )
			{
				tileData.complete = true;
				console.error( xhr.responseText );
			}
			
			tileData.state = OpenSearchLayer.TileState.LOADED;
			self.freeRequests.push( xhr );
			
			// Publish event that layer have received new features
			if ( response.features.length > 0 )
			{
				self.publish("features:added", {layer: self, features: response.features});
			}

			// Publish the end load event, only if there is no pending requests
			if ( self.maxRequests == self.freeRequests.length )
			{
				self.globe.publish("endLoad",self);
			}
		}
	};
	xhr.open("GET", url );
	xhr.send();
}

/**************************************************************************************************************/

/**
 * 	Set new request properties
 */
OpenSearchLayer.prototype.setRequestProperties = function(properties)
{
	// clean renderers
	for ( var x in this.featuresSet )
	{
		var featureData = this.featuresSet[x];
		for ( var i=0; i<featureData.tiles.length; i++ )
		{
			var tile = featureData.tiles[i];
			var feature = this.features[featureData.index];
			this.globe.vectorRendererManager.removeGeometryFromTile(this,feature.geometry,tile);
		}
	}

	// Clean old results
	var self = this;
	this.globe.tileManager.visitTiles( function(tile) {
		if( tile.extension[self.extId] )
		{
			tile.extension[self.extId].dispose();
			tile.extension[self.extId].featureIds = []; // exclusive parameter to remove from layer
			tile.extension[self.extId].state = OpenSearchLayer.TileState.NOT_LOADED;
			tile.extension[self.extId].complete = false;
		}
	});
	this.featuresSet = {};
	this.features = [];

	// Set request properties
	this.requestProperties = "";
	for (var key in properties)
	{
		if ( this.requestProperties != "" )
			this.requestProperties += '&'
		this.requestProperties += key+'='+properties[key];
	}
	
}

/**************************************************************************************************************/

/**
 *	Add feature to the layer and to the tile extension
 */
OpenSearchLayer.prototype.addFeature = function( feature, tile )
{
	var tileData = tile.extension[this.extId];
	var featureData;
	
	// Add feature if it doesn't exist
	if ( !this.featuresSet.hasOwnProperty(feature.properties.identifier) )
	{
		this.features.push( feature );
		featureData = {
			index: this.features.length-1, 
			tiles: [tile]
		};
		this.featuresSet[feature.properties.identifier] = featureData;
	}
	else
	{
		featureData = this.featuresSet[feature.properties.identifier];
		
		// Store the tile
		featureData.tiles.push(tile);

		// Always use the base feature to manage geometry indices
		feature = this.features[ featureData.index ];
	}
	
	// Add feature id
	tileData.featureIds.push( feature.properties.identifier );
	
	// Set the identifier on the geometry
	feature.geometry.gid = feature.properties.identifier;

	// Add to renderer
	//this.addFeatureToRenderer(feature, tile);
	
	// MS: Feature could be added from ClusterOpenSearch which have features with different styles
	var style = feature.properties.style ? feature.properties.style : this.style;

	this.globe.vectorRendererManager.addGeometryToTile(this, feature.geometry, style, tile);
}


/**************************************************************************************************************/

/**
 *	Remove feature from Dynamic OpenSearch layer
 */
OpenSearchLayer.prototype.removeFeature = function( identifier, tile )
{
	var featureIt = this.featuresSet[identifier];
	
	if (!featureIt) {
		return;
	}
	
	// Remove tile from array
	var tileIndex = featureIt.tiles.indexOf(tile);
	if ( tileIndex >= 0 )
	{
		featureIt.tiles.splice(tileIndex,1);
	}
	else
	{
		console.log('OpenSearchLayer internal error : tile not found when removing feature');
	}
	
	if ( featureIt.tiles.length == 0 )
	{
		// Remove it from the set		
		delete this.featuresSet[identifier];

		// Remove it from the array by swapping it with the last feature to optimize removal.
		var lastFeature = this.features.pop();
		if ( featureIt.index < this.features.length ) 
		{
			// Set the last feature at the position of the removed feature
			this.features[ featureIt.index ] = lastFeature;
			// Update its index in the Set.
			this.featuresSet[ lastFeature.properties.identifier ].index = featureIt.index;
		}
	}
}

/**************************************************************************************************************/

/**
 *	Modify feature style
 */
OpenSearchLayer.prototype.modifyFeatureStyle = function( feature, style )
{
	feature.properties.style = style;
	var featureData = this.featuresSet[feature.properties.identifier];
	if ( featureData )
	{
		for ( var i = 0; i < featureData.tiles.length; i++ )
		{
			var tile = featureData.tiles[i];
			this.globe.vectorRendererManager.removeGeometryFromTile(feature.geometry,tile);
			this.globe.vectorRendererManager.addGeometryToTile(this,feature.geometry,style,tile);
		}
		
	}
}

OpenSearchLayer.TileState = {
	LOADING: 0,
	LOADED: 1,
	NOT_LOADED: 2,
	INHERIT_PARENT: 3
};


/**************************************************************************************************************/

/**
 *	Generate the tile data
 */
OpenSearchLayer.prototype.generate = function(tile) 
{
	if ( tile.order == this.minOrder )
	{
		tile.extension[this.extId] = new OSData(this,tile,null);
	}
	
};

/**************************************************************************************************************/

/**
 *	OpenSearch renderable
 */

var OSData = function(layer,tile,p)
{
	this.layer = layer;
	this.parent = p;
	this.tile = tile;
	this.featureIds = []; // exclusive parameter to remove from layer
	this.state = OpenSearchLayer.TileState.NOT_LOADED;
	this.complete = false;
	this.childrenCreated = false;
}

/**************************************************************************************************************/

/**
 * Traverse 
 */
OSData.prototype.traverse = function( tile )
{
	if (!this.layer._visible)
		return;
		
	if (tile.state != Tile.State.LOADED)
		return;

	// Check if the tile need to be loaded
	if ( this.state == OpenSearchLayer.TileState.NOT_LOADED )
	{
		this.layer.tilesToLoad.push( this );
	}
	
	// Create children if needed
	if ( this.state == OpenSearchLayer.TileState.LOADED && !this.complete
			&&  tile.state == Tile.State.LOADED && tile.children && !this.childrenCreated )
	{
		for ( var i = 0; i < 4; i++ )
		{
			if (!tile.children[i].extension[this.layer.extId])
				tile.children[i].extension[this.layer.extId] = new OSData(this.layer,tile.children[i],this);
		}
		this.childrenCreated = true;
	
		
		// HACK : set renderable to have children
		var renderables = tile.extension.renderer ? tile.extension.renderer.renderables : [];
		for ( var i=0; i<renderables.length; i++ )
		{
			if ( renderables[i].bucket.layer == this.layer )
				renderables[i].hasChildren = true;
		}
	}
}

/**************************************************************************************************************/

/**
 * 	Dispose renderable data from tile
 */
OSData.prototype.dispose = function( renderContext, tilePool )
{
	if (this.parent && this.parent.childrenCreated)
	{
		this.parent.childrenCreated = false;
		// HACK : set renderable to not have children!
		var renderables = this.parent.tile.extension.renderer ? this.parent.tile.extension.renderer.renderables : [];
		for ( var i=0; i<renderables.length; i++ )
		{
			if ( renderables[i].bucket.layer == this.layer )
				renderables[i].hasChildren = false;
		}
	}
	
	for( var i = 0; i < this.featureIds.length; i++ )
	{
		this.layer.removeFeature( this.featureIds[i], this.tile );
	}
	this.tile = null;
	this.parent = null;
}

/**************************************************************************************************************/

/**
 *	Build request url
 */
OpenSearchLayer.prototype.buildUrl = function( tile )
{
	var url = this.serviceUrl + "/search?order=" + tile.order + "&healpix=" + tile.pixelIndex;
	if ( this.coordSystemRequired )
	{
		// OpenSearchLayer always works in equatorial
		url += "&coordSystem=EQUATORIAL";
	}
	url += "&media=json";
	return url;
}

/**************************************************************************************************************/

// Internal function to sort tiles
function _sortTilesByDistance(t1,t2)
{
	return t1.tile.distance - t2.tile.distance;
};

/**
	Render function
	
	@param tiles The array of tiles to render
 */
OpenSearchLayer.prototype.render = function( tiles )
{
	if (!this._visible)
		return;
	
	// Sort tiles
	this.tilesToLoad.sort( _sortTilesByDistance );

	// Load data for the tiles if needed
	for ( var i = 0; i < this.tilesToLoad.length && this.freeRequests.length > 0; i++ )
	{
		var tile = this.tilesToLoad[i].tile;
		var url = this.buildUrl(tile);
		if ( url )
		{
			this.launchRequest(tile, url);
		}
	}
	
	this.tilesToLoad.length = 0;
}

/**************************************************************************************************************/

/**
 * 	Update features
 */
OpenSearchLayer.prototype.updateFeatures = function( features )
{
	for ( var i=0; i<features.length; i++ )
	{
		var currentFeature = features[i];
		
		switch ( currentFeature.geometry.type )
		{
			case "Point":

				// Convert to default coordinate system if needed
				/*if ( "EQ" != this.globe.tileManager.imageryProvider.tiling.coordSystem )
				{
					currentFeature.geometry.coordinates = CoordinateSystem.convert(currentFeature.geometry.coordinates, this.globe.tileManager.imageryProvider.tiling.coordSystem, "EQ");
				}*/

				// Convert to geographic to simplify picking
				if ( currentFeature.geometry.coordinates[0] > 180 )
					currentFeature.geometry.coordinates[0] -= 360;
				break;
			case "Polygon":
				var ring = currentFeature.geometry.coordinates[0];
				for ( var j = 0; j < ring.length; j++ )
				{
					// Convert to default coordinate system if needed
					/*if ( "EQ" != this.globe.tileManager.imageryProvider.tiling.coordSystem )
					{
						ring[j] = CoordinateSystem.convert(ring[j], this.globe.tileManager.imageryProvider.tiling.coordSystem, "EQ");
					}*/

					// Convert to geographic to simplify picking
					if ( ring[j][0] > 180 )
						ring[j][0] -= 360;
				}
				break;
			default:
				break;
		}
	}
}

/*************************************************************************************************************/

return OpenSearchLayer;

});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/
 
define('TileWireframeLayer',['./Utils', './BaseLayer','./Program','./Tile'], 
	function(Utils, BaseLayer, Program, Tile) {

/**************************************************************************************************************/

/** 
	@constructor
	Function constructor for TileWireframeLayer
 */
var TileWireframeLayer = function( options )
{
	BaseLayer.prototype.constructor.call( this, options );
	this.outline = (options && options['outline']) ? options['outline'] : false;
	this.color = (options && options['color']) ? options['color'] : [1.,1.,1.];
	this.globe = null;
	this.program = null;
	this.indexBuffer = null;
	this.subIndexBuffer = [ null, null, null, null ];
	this.zIndex = -1;
}

/**************************************************************************************************************/

Utils.inherits( BaseLayer,TileWireframeLayer );

/**************************************************************************************************************/

/** 
  Build the index buffer
 */
TileWireframeLayer.prototype.buildIndexBuffer = function()
{
	var gl = this.globe.renderContext.gl;
	var size = this.globe.tileManager.tileConfig.tesselation;
	var indices = [];
	
	var step = this.outline ? size-1 : 1;
	
	// Build horizontal lines
	for ( var j=0; j < size; j += step)
	{
		for ( var i=0; i < size-1; i++)
		{
			indices.push( j * size + i );
			indices.push( j * size + i + 1 );
		}
	}

	// Build vertical lines
	for ( var j=0; j < size; j += step)
	{
		for ( var i=0; i < size-1; i++)
		{
			indices.push( i * size + j );
			indices.push( (i+1) * size + j );
		}
	}

	
	var ib = gl.createBuffer();
	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ib);
	gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
	
	ib.numIndices = indices.length;
	this.indexBuffer = ib;
	
	var halfTesselation = (size-1) / 2;
	step = this.outline ? halfTesselation : 1;
	for ( var ii = 0; ii < 4; ii++ )
	{
		var i = ii % 2;
		var j = Math.floor( ii / 2 );
		
		// Build the sub grid for 'inside' tile
		var indices = [];
		for ( var n=halfTesselation*j; n < halfTesselation*(j+1)+1; n+= step)
		{
			for ( var k=halfTesselation*i; k < halfTesselation*(i+1); k++)
			{
				indices.push( n * size + k );
				indices.push( n * size + k + 1 );
			}
		}
		for ( var n=halfTesselation*i; n < halfTesselation*(i+1)+1; n+= step)
		{
			for ( var k=halfTesselation*j; k < halfTesselation*(j+1); k++)
			{
				indices.push( k * size + n );
				indices.push( (k+1) * size + n );
			}
		}
	
		var ib = gl.createBuffer();
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ib);
		gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
		ib.numIndices = indices.length;
		this.subIndexBuffer[ii] = ib;
	}
}

/**************************************************************************************************************/

/** 
  Attach the layer to the globe
 */
TileWireframeLayer.prototype._attach = function( g )
{
	BaseLayer.prototype._attach.call( this, g );
	
	if ( this._visible )
	{
		this.globe.tileManager.addPostRenderer(this);
	}
	
	if (!this.program)
	{
		var vertexShader = "\
		attribute vec3 vertex;\n\
		uniform mat4 modelViewMatrix;\n\
		uniform mat4 projectionMatrix;\n\
		void main(void) \n\
		{\n\
			gl_Position = projectionMatrix * modelViewMatrix * vec4(vertex, 1.0);\n\
		}\n\
		";

		var fragmentShader = "\
		precision highp float; \n\
		uniform vec3 color; \n\
		uniform float alpha; \n\
		void main(void)\n\
		{\n\
			gl_FragColor = vec4(color,alpha);\n\
		}\n\
		";
		
		this.program = new Program(this.globe.renderContext);
		this.program.createFromSource( vertexShader, fragmentShader );
		
		this.buildIndexBuffer();
	}
}

/**************************************************************************************************************/

/** 
  Detach the layer from the globe
 */
TileWireframeLayer.prototype._detach = function()
{
	this.globe.tileManager.removePostRenderer(this);
	BaseLayer.prototype._detach.call(this);
}

/**************************************************************************************************************/

/**
	Render the tiles outline
 */
TileWireframeLayer.prototype.render = function( tiles )
{
	var rc = this.globe.renderContext;
	var gl = rc.gl;
	
	gl.enable(gl.BLEND);
	
	// Setup program
	this.program.apply();
	gl.uniformMatrix4fv(this.program.uniforms["projectionMatrix"], false, rc.projectionMatrix);
	
	var vertexAttribute = this.program.attributes['vertex'];
	var currentIB = null;	
	
	for ( var i = 0; i < tiles.length; i++ )
	{
		var tile = tiles[i];
		
		var isLoaded = ( tile.state == Tile.State.LOADED );
		var isLevelZero = ( tile.parentIndex == -1 );
	
		// Update uniforms for modelview matrix
		mat4.multiply( rc.viewMatrix, tile.matrix, rc.modelViewMatrix );
		gl.uniformMatrix4fv(this.program.uniforms["modelViewMatrix"], false, rc.modelViewMatrix);
		gl.uniform3f(this.program.uniforms["color"], this.color[0], this.color[1], this.color[2] );
		gl.uniform1f(this.program.uniforms["alpha"], this.opacity() );
			
		// Bind the vertex buffer
		gl.bindBuffer(gl.ARRAY_BUFFER, tile.vertexBuffer);
		gl.vertexAttribPointer(vertexAttribute, 3, gl.FLOAT, false, 4*tile.config.vertexSize, 0);
		
		var indexBuffer = ( isLoaded || isLevelZero ) ? this.indexBuffer : this.subIndexBuffer[tile.parentIndex];
		// Bind the index buffer only if different (index buffer is shared between tiles)
		if ( currentIB != indexBuffer )
		{
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
			currentIB = indexBuffer;
		}
		
		// Draw the tiles in wireframe mode
		var numIndices = currentIB.numIndices;
		gl.drawElements(gl.LINES, currentIB.numIndices, gl.UNSIGNED_SHORT, 0);
	}
	
	gl.disable(gl.BLEND);
}

/**************************************************************************************************************/

/**
 * 	Get/Set visibility of the layer
 */
TileWireframeLayer.prototype.visible = function( arg )
{
	BaseLayer.prototype.visible.call( this, arg );
	
	if ( typeof arg == "boolean" )
	{	
		if ( this._visible ){
			this.globe.tileManager.addPostRenderer(this);
		}
		else
		{
			this.globe.tileManager.removePostRenderer(this);
		}
	}
	
	return this._visible;
}

return TileWireframeLayer;

});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define( 'TouchNavigationHandler',[],function() {

/**************************************************************************************************************/

/**
 *	Types of actions for inertia execution
 */
var Type = {
	PAN : 0,
	ROTATE : 1,
	TILT : 2,
	ZOOM : 3
};

/** @export
	@constructor
	TouchNavigationHandler constructor
	@param options Configuration properties for the TouchNavigationHandler :
			<ul>
				<li>inversed : if true inverse the sens of touching events</li>
				<li>zoomOnDblClick : if true defines animation on double click</li>
			</ul>
 */
var TouchNavigationHandler = function(options){

	/**************************************************************************************************************/
	
	/**
 	 * Private variables
	 */
	 
	var _navigation = null;
	var _lastFingerDistance;

	var _startTouches = [];
	var _lastTouches;
	var _lastAngle;

	var _dx, _dy;
	var _type;

	// Parameters for intertia management
	var _actionHits = [0, 0, 0, 0];
	var _lastTapDate;
	var _rotation;


	// Double tap
	var _doubletap_interval = 300;
	var _inversed = (options && options.hasOwnProperty('inversed')) ? options.inversed : false;

	/**************************************************************************************************************/
	
	/**
 	 * Private methods
	 */

	/**
	 * Calculate the angle between two coordinates
	 */
	var _getAngle = function(touch1, touch2) {
		var y = touch2.clientY - touch1.clientY,
			x = touch2.clientX - touch1.clientX;
		return Math.atan2(y, x) * 180 / Math.PI;
	};

	/**************************************************************************************************************/

	/**
	 * Calculate the rotation degrees between two touchLists (fingers)
	 */
	var _getRotation = function(start, end) {
		// Need two fingers
		if(start.length >= 2 && end.length >= 2) {
			return _getAngle(end[1], end[0]) - _getAngle(start[1], start[0]);
		}
		return 0;
    };

    /**************************************************************************************************************/

	/** 
	  Handle touch start event
	 */
	var _handleTouchStart = function(event)
	{
		//console.log("# events : " + event.touches.length );
		_lastTouches = event.touches;
		_startTouches = event.touches;
		
		_actionHits = [0, 0, 0, 0];

		// Stop all animations when an event is received
		_navigation.stopAnimations();
		_dx = 0;
		_dy = 0;
		if ( event.touches.length == 2 )
		{
			var dx = event.touches[0].clientX - event.touches[1].clientX;
			var dy = event.touches[0].clientY - event.touches[1].clientY;
			_lastFingerDistance = Math.sqrt( dx * dx + dy * dy );
			console.log("Finger distance : " + _lastFingerDistance );
			
			_lastAngle = _getRotation( _startTouches, event.touches );
		}
				
		if ( event.preventDefault )
		{
			event.preventDefault();
		}
		event.returnValue = false;

		// Return false to stop event to be propagated
		return false;
	};

	/**************************************************************************************************************/

	/** 
	  Handle touch move event
	 */
	var _handleTouchMove = function(event)
	{
		_dx = event.touches[0].clientX - _lastTouches[0].clientX;
		_dy = event.touches[0].clientY - _lastTouches[0].clientY;
		if ( event.touches.length == 1 )
		{	
			// Pan
	       	_navigation.pan(_dx, _dy);
	        _actionHits[Type.PAN]++;
		}
		else
		{
			// Depending on direction of two fingers, decide if tilt OR rotation
			var sameDirection = ( (event.touches[0].clientY - _lastTouches[0].clientY) * (event.touches[1].clientY - _lastTouches[1].clientY) > 0 );
			if ( sameDirection )
			{
				// Tilt
				_navigation.rotate(0., -_dy);
				_actionHits[Type.TILT]++;
			}
			else
			{
				// Rotation
				var rotation = _getRotation( _startTouches, event.touches );
				var dx = rotation - _lastAngle;
				_lastAngle = rotation;

				if ( _inversed )
				{
					dx *= -1;
				}
				
				_rotation = dx * 10;
				_navigation.rotate(_rotation, 0);
				_actionHits[Type.ROTATE]++;
			}

			// Zoom
			var dx = event.touches[0].clientX - event.touches[1].clientX;
			var dy = event.touches[0].clientY - event.touches[1].clientY;
			var fingerDistance = Math.sqrt( dx * dx + dy * dy );
			var deltaDistance = (fingerDistance - _lastFingerDistance);

			var scale;
			if ( _inversed )
			{
				scale = fingerDistance/_lastFingerDistance;
			}
			else
			{
				scale = _lastFingerDistance/fingerDistance;
			}

			if (_lastFingerDistance != 0)
			{
				_navigation.zoom( deltaDistance * 0.025, scale);
				_actionHits[Type.ZOOM]++;
			}
			_navigation.renderContext.requestFrame();
			_lastFingerDistance = fingerDistance;
		}

		// Update _lastTouches
		_lastTouches = event.touches;
		
		if ( event.preventDefault )
		{
			event.preventDefault();
		}
		event.returnValue = false;
		
		return false;
	};

	/**************************************************************************************************************/

	/** 
	  Handle touch end event
	 */
	var _handleTouchEnd = function(event)
	{	
		if ( options && options.zoomOnDblClick && event.touches.length == 0 && _dx == 0 && _dy == 0 )
		{
			// Handle double tap
			// TODO : take into account the distance
			var now = Date.now();
			if ( now - _lastTapDate < _doubletap_interval )
			{
				var geo = _navigation.globe.getLonLatFromPixel( _lastTouches[0].clientX, _lastTouches[0].clientY );
		
				if (geo)
				{
					_navigation.zoomTo(geo);
				}
			}
			_lastTapDate = now;
		}

		// Update last touches
		_lastTouches = event.touches;

		if ( _navigation.inertia && (_dx != 0 || _dy != 0) )
		{
			// Launch inertia depending on action hits while "moving" phase
			var hitIndex = _actionHits.indexOf( Math.max.apply(this,_actionHits) );
			if ( hitIndex == Type.PAN )
			{
				// Pan
				_navigation.inertia.launch("pan", _dx, _dy);
			}
			else if ( hitIndex == Type.ROTATE )
			{
				// Rotate
				//_navigation.inertia.launch("rotate", _rotation, 0);
			}
			else if ( hitIndex == Type.TILT )
			{
				// No inertia for tilt
			}
		}

		if ( event.preventDefault )
		{
			event.preventDefault();
		}
		event.returnValue = false;
		
		return false;
	};

	/**************************************************************************************************************/
	
	/**
	 * Public methods
	 */
			
	/** 
	 *	Setup the default event handlers for the _navigation
	 */
	this.install = function(nav)
	{
		_navigation = nav;
		
		// Setup the touch event handlers
		var canvas = _navigation.renderContext.canvas;
		
		canvas.addEventListener("touchstart", _handleTouchStart,false);
		canvas.addEventListener("touchend", _handleTouchEnd,false);
		canvas.addEventListener("touchmove", _handleTouchMove,false);
	};

	/** 
	 *	Remove the default event handlers for the _navigation
	 */
	this.uninstall = function()
	{
		// Setup the mouse event handlers
		var canvas = _navigation.renderContext.canvas;

		canvas.removeEventListener("touchstart", _handleTouchStart,false);
		canvas.removeEventListener("touchend", _handleTouchEnd,false);
		canvas.removeEventListener("touchmove", _handleTouchMove,false);
	};
};

return TouchNavigationHandler;

});
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 define( 'Animation',[],function() {
 
/**************************************************************************************************************/

/**	@constructor
	Base animation class
	Defines animation states (STOPPED, STARTED), animation base members
	and start() stop() functions.
*/
var Animation = function()
{
    this.startTime = -1;
	this.pauseTime = -1;
	this.renderContext = null;
}

/**************************************************************************************************************/

/**
  Unregister as active animation
*/
Animation.prototype._unregisterActive = function()
{
	var index = this.renderContext.activeAnimations.indexOf(this);
	if ( index >= 0 )
	{
		this.renderContext.activeAnimations.splice(index,1);
	}
}

/**************************************************************************************************************/

/**
  Get animation status
*/
Animation.prototype.getStatus = function()
{
	if ( this.startTime == -1 )
		return "STOPPED";
	else 
		return this.pauseTime == -1 ? "RUNNING" : "PAUSED";
}

/**************************************************************************************************************/

/** @export
	Start function, record the start time in startTime member
	and register the animation in the GlobWeb object.
*/
Animation.prototype.start = function()
{
	if ( !this.renderContext )
		return;
	
	if ( this.startTime == -1 || this.pauseTime != - 1 )
	{
 		var now = Date.now();
		if ( this.startTime == -1 )
		{
			this.startTime = now;
		}
		else
		{
			// resume after pause
			this.startTime += now - this.pauseTime;
			this.pauseTime = -1;
		}
		
		// Register animation as active
		this.renderContext.activeAnimations.push(this);
		this.renderContext.requestFrame();
	}
}

/**************************************************************************************************************/

/** @export
	Pause function
*/
Animation.prototype.pause = function()
{	
	if ( !this.renderContext )
		return;
		
	if ( this.startTime != -1 && this.pauseTime == -1 )
	{
		this.pauseTime = Date.now();
		this._unregisterActive(this);
	}
}

/**************************************************************************************************************/

/** @export
	Stop function, removes the animation from the GlobWeb object
*/
Animation.prototype.stop = function()
{
	this.startTime = -1;
	this.pauseTime = -1;
		
	if ( this.onstop )
		this.onstop();

    // Unregister animation
    this._unregisterActive(this);
}

/**************************************************************************************************************/

return Animation;

});
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 define('InertiaAnimation',['./Utils','./Animation'], function(Utils,Animation) {
 
/**************************************************************************************************************/

var epsilon = 0.1;

/**	@constructor
 *	Animation simulating inertia for camera navigation
 *
 *	@param nav Navigation
 *	@param options Configuration of navigation
 *			<ul>
 *				<li>panFactor : Pan factor</li>
 *				<li>rotateFactor : Rotate factor</li>
 *				<li>zoomFactor : Zoom factor</li>
 *			</ul>
 */
var InertiaAnimation = function(nav, options)
{
    Animation.prototype.constructor.call(this);

    if ( options )
    {
		this.panFactor = options.hasOwnProperty('panFactor') ? options['panFactor'] : 0.95;
		this.rotateFactor = options.hasOwnProperty('rotateFactor') ? options['rotateFactor'] : 0.95;
		this.zoomFactor = options.hasOwnProperty('zoomFactor') ? options['zoomFactor'] : 0.95;
	}

	this.type = null;
	this.dx = 0;
	this.dy = 0;
	this.navigation = nav;
	this.renderContext = nav.renderContext;
}

/**************************************************************************************************************/

Utils.inherits(Animation,InertiaAnimation);

/**************************************************************************************************************/

/**
 * Update inertia
 */
InertiaAnimation.prototype.update = function(now)
{
	var hasToStop = false;
	
	switch(this.type)
	{
		case "pan":
			this.navigation.pan(this.dx,this.dy);
			this.dx *= this.panFactor;
			this.dy *= this.panFactor;
			hasToStop = (Math.abs(this.dx) < epsilon && Math.abs(this.dy) < epsilon);
			break;
		case "rotate":
			this.navigation.rotate(this.dx,this.dy);
			this.dx *= this.rotateFactor;
			this.dy *= this.rotateFactor;
			hasToStop = (Math.abs(this.dx) < epsilon && Math.abs(this.dy) < epsilon);
			break;
		case "zoom":
			this.navigation.zoom(this.dx);
			this.dx *= this.zoomFactor;
			hasToStop = (Math.abs(this.dx) < epsilon);
			break;
		default:
	}
	this.navigation.renderContext.requestFrame();

	if ( hasToStop )
		this.stop();
}

/**************************************************************************************************************/

/**
 *	@param type Type of inertia
 *				<ul>
 *					<li>pan</li>
 *					<li>rotate</li>
 *					<li>zoom</li>
 *				</ul>
 *	@param speed Starting speed
 *	@param {Int[]} inertiaVector Vector of mouvement in window coordinates(for pan and rotate inertias)
 */
InertiaAnimation.prototype.launch = function(type, dx, dy)
{
	// Set first value
 	this.type = type;
	this.dx = dx;
	this.dy = dy;

	this.start();
}

/**************************************************************************************************************/

return InertiaAnimation;

});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 define('SegmentedAnimation',['./Utils','./Animation','./Numeric'], function(Utils,Animation,Numeric) {

/**************************************************************************************************************/

/** @constructor
  SegmentedAnimation is an animation defined with segments.
  Each segment has a [start,end] pair of 't' value and a [start,end] pair of
  values that will be interpolated with the interpolator set on the segment.
  When the animation runs, a t parameter is mapped to [0,1] according to
  current time and animation duration.
  The current segment is then looked up with that 't' value and used to interpolate
  the animation's current value.
 */
var SegmentedAnimation = function(duration, valueSetter)
{
    // Call ancestor constructor
    Animation.prototype.constructor.call(this);

    this.segments = [];
    this.duration = duration;
    this.valueSetter = valueSetter;
}

/**************************************************************************************************************/

Utils.inherits(Animation,SegmentedAnimation);

/**************************************************************************************************************/

/** @constructor
  Segment struct
*/
var Segment = function(start, startValue, end, endValue, interpolator)
{
    this.start = start;
    this.startValue = startValue;
    this.end = end;
    this.endValue = endValue;
    this.interpolator = interpolator;
}

/**************************************************************************************************************/

/*
	Adds a new segment to the animation.
	start, end are 't' values at which the segment will be the current segment
	startValue, endValue are animation values at 't'=start and 't'=end
	interpolator is the function that will be called to interpolate bewteen startValue and endValue.
*/
SegmentedAnimation.prototype.addSegment = function(start, startValue, end, endValue, interpolator)
{
    var count = this.segments.length;
    var index = 0;
    while (index < count && this.segments[index].end <= start) index++;
    // Insert new segment at position 'index'
    this.segments.splice(index, 0, new Segment(start, startValue, end, endValue, interpolator));
}

/**************************************************************************************************************/

/*
	Animation update method
*/
SegmentedAnimation.prototype.update = function(now)
{
    var t = Numeric.map01(now, this.startTime, this.startTime + this.duration);
    if (t >= 1)
    {
		 // Set last value
		var lastIndex = this.segments.length - 1;
		this.valueSetter(this.segments[lastIndex].endValue);
		this.stop();
    }
	else
	{
		// Find current segment
		var count = this.segments.length;
		var index = 0;
		while (index < count && this.segments[index].end < t) index++;
		index = Math.min(index, count-1);
		
		// Remap t between segment bounds
		t = Numeric.map01(t, this.segments[index].start, this.segments[index].end);
		// Interpolate value
		var value = this.segments[index].interpolator(t, this.segments[index].startValue, this.segments[index].endValue);
		// Use value
		this.valueSetter(value);
	}
}

/**************************************************************************************************************/

return SegmentedAnimation;

});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define( 'BaseNavigation',['./Utils', './Event', './MouseNavigationHandler', './KeyboardNavigationHandler', './TouchNavigationHandler', './InertiaAnimation', './SegmentedAnimation', './Numeric', './glMatrix' ], 
	function(Utils,Event,MouseNavigationHandler,KeyboardNavigationHandler,TouchNavigationHandler,InertiaAnimation,SegmentedAnimation,Numeric) {

/**************************************************************************************************************/

/** @name BaseNavigation
	@constructor
	Base class for navigation object

	@param renderContext Render context
	@param options Configuration options
		<ul>
			<li>handlers : Array of objects defining navigation events for different supports(mouse, keyboard..)</li>
			<li>inertia : Boolean for inertia effect</li>
			<li>panFactor : Pan factor</li>
			<li>rotateFactor : Rotate factor</li>
			<li>zoomFactor : Zoom factor</li>
			<li>isMobile : Boolean indicating if navigation supports touch events</li>
		</ul>

 */
var BaseNavigation = function(renderContext, options)
{
	Event.prototype.constructor.call( this );
	
	this.renderContext = renderContext;

	// Create default handlers if none are created in options
	if ( options && options.handlers ) 
	{
		this.handlers = options.handlers;
	}
	else
	{
		// Use mouse & keyboard as default handlers if isMobile isn't defined
		if ( options && options.isMobile )
		{
			this.handlers = [ new TouchNavigationHandler(options ? options.touch : null) ];	
		}
		else
		{
			this.handlers = [ new MouseNavigationHandler(options ? options.mouse : null), new KeyboardNavigationHandler(options ? options.keyboard : null) ];
		}
	}
	
	// Inertia effect
	if( options && options.inertia )
	{
		this.inertia = new InertiaAnimation(this, options);
	}
	// ZoomTo animation
	this.zoomToAnimation = null;

	// Automatically start
	this.start();
}

/**************************************************************************************************************/

Utils.inherits( Event, BaseNavigation );

/**************************************************************************************************************/

/** @export
	Start the navigation
*/
BaseNavigation.prototype.start = function()
{
	// Install handlers
	for (var i=0; i<this.handlers.length; i++)
	{
		this.handlers[i].install(this);
	}
}

/**************************************************************************************************************/

/** @export
	Stop the navigation
*/
BaseNavigation.prototype.stop = function()
{
	// Uninstall handlers
	for (var i=0; i<this.handlers.length; i++)
	{
		this.handlers[i].uninstall();
	}
}

/**************************************************************************************************************/

/** @export
	Stop the animations running on the navigation
*/
BaseNavigation.prototype.stopAnimations = function()
{
	if ( this.inertia )
	{
		this.inertia.stop();
	}
	if( this.zoomToAnimation )
	{
		this.zoomToAnimation.stop();
		this.zoomToAnimation = null;
	}
}

/**************************************************************************************************************/

/** @export
	Get the field of view used by the navigation
	
	@return {Float[]} Fovx and fovy in degrees
*/
BaseNavigation.prototype.getFov = function()
{
	var aspect = this.renderContext.canvas.width / this.renderContext.canvas.height;
	return [ aspect * this.renderContext.fov, this.renderContext.fov ];
}

/**************************************************************************************************************/

/**
	Basic animation from current view matrix to the given one
	@param {Array[16]} mat Destination view matrix
	@param {Int} fov Final zooming fov in degrees
	@param {Int} duration Duration of animation in milliseconds
	@param {Function} callback Callback on the end of animation
 */
BaseNavigation.prototype.toViewMatrix = function(mat, fov, duration, callback)
{
	var navigation = this;
	var vm = this.renderContext.viewMatrix;

	var srcViewMatrix = mat4.toMat3( vm );
	var srcQuat = quat4.fromRotationMatrix( srcViewMatrix );
	var destViewMatrix = mat4.toMat3( mat );
	var destQuat = quat4.fromRotationMatrix( destViewMatrix );	
	var destFov = fov || 45;
	duration = duration || 1000;

	// Animate rotation matrix(with quaternion support), tranlation and fov
	var startValue = [srcQuat, [vm[12], vm[13], vm[14]], navigation.renderContext.fov];
	var endValue = [destQuat, [mat[12],mat[13],mat[14]], destFov];
	var animation = new SegmentedAnimation(
		duration,
		// Value setter
		function(value) {
			// Update rotation matrix
			var newRotationMatrix = quat4.toMat4(value[0]);
			// Need to transpose the new rotation matrix due to bug in glMatrix
			navigation.renderContext.viewMatrix = mat4.transpose(newRotationMatrix);

			// Update translation
			navigation.renderContext.viewMatrix[12] = value[1][0];
		    navigation.renderContext.viewMatrix[13] = value[1][1];
		    navigation.renderContext.viewMatrix[14] = value[1][2];

		    // Update fov
		    navigation.renderContext.fov = value[2];

			navigation.renderContext.requestFrame();
		});

	// Add segment
	animation.addSegment(
		0.0, startValue,
		1.0, endValue,
		function(t, a, b) {
			var pt = Numeric.easeOutQuad(t);
			var resQuat = quat4.create();
			quat4.slerp(a[0], b[0], pt, resQuat);

			var resTranslate = vec3.create();
			vec3.lerp(a[1], b[1], pt, resTranslate);
			
			var resFov = Numeric.lerp(pt, a[2], b[2]);
			return [resQuat,		// quaternions
					resTranslate,	// translate
					resFov]; 		// fov
		}
	);

	animation.onstop = function() {
		if ( callback )
		{
			callback();
		}
	}

	this.globe.addAnimation(animation);
	animation.start();
}

/**************************************************************************************************************/

return BaseNavigation;

});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('AstroNavigation',['./Utils', './BaseNavigation', './SegmentedAnimation', './Numeric', './Ray', './glMatrix'], function(Utils,BaseNavigation,SegmentedAnimation,Numeric,Ray) {

/**************************************************************************************************************/

/** @export
	@constructor
	Astronavigation constructor
	@param globe Globe
	@param options Configuration properties for the AstroNavigation :
		<ul>
			<li>minFov : The minimum field of view in degrees</li>
			<li>maxFov : The maximum field of view in degrees</li>
		</ul>
 */
var AstroNavigation = function(globe, options)
{
	BaseNavigation.prototype.constructor.call( this, globe.renderContext, options );
	
	this.globe = globe;
	
	// Default values for fov (in degrees)
	this.minFov = (options && options.minFov) || 0.001;
	this.maxFov = (options && options.maxFov) || 100;

	// Initialize the navigation
	this.center3d = [1.0, 0.0, 0.0];
	this.up = [0., 0., 1.];

	if ( options )
	{
		if ( options.initTarget ) {
			this.globe.coordinateSystem.fromGeoTo3D(options.initTarget, this.center3d );
		}

		if ( options.initFov ) {
			this.renderContext.fov = options.initFov;
			this._clampFov();
		}

		if ( options.up )
		{
			this.up = options.up;
		}
	}
		
	// Update the view matrix now
	this.computeViewMatrix();
}

/**************************************************************************************************************/

Utils.inherits( BaseNavigation, AstroNavigation );

/**************************************************************************************************************/

/** @export
	Zoom to a 3d position
	@param {Float[]} geoPos Array of two floats corresponding to final Longitude and Latitude(in this order) to zoom
	@param {Int} fov Final zooming fov in degrees
	@param {Int} duration Duration of animation in milliseconds
	@param {Function} callback Callback on the end of animation
 */
AstroNavigation.prototype.zoomTo = function(geoPos, fov, duration, callback)
{
	var navigation = this;
	
	// default values
	var destFov = fov || 2.0;
	duration = duration || 2000;
	
	// Create a single animation to animate center3d and fov
	var geoStart = [];
	var middleFov = 25.0;	// arbitrary middle fov value which determines if the animation needs two segments
	
	this.globe.coordinateSystem.from3DToGeo(this.center3d, geoStart);
	var startValue = [geoStart[0], geoStart[1], this.renderContext.fov];
	var endValue = [geoPos[0], geoPos[1], destFov];
	
	// Compute the shortest path if needed
	if (Math.abs(geoPos[0] - geoStart[0]) > 180. )
	{
		if (geoStart[0] < geoPos[0])
			startValue[0] += 360;
		else
			endValue[0] +=360;
	}
	var animation = new SegmentedAnimation(
		duration,
		// Value setter
		function(value) {
			var position3d = navigation.globe.coordinateSystem.fromGeoTo3D( [ value[0], value[1] ] );
			navigation.center3d[0] = position3d[0];
			navigation.center3d[1] = position3d[1];
			navigation.center3d[2] = position3d[2];
			navigation.globe.renderContext.fov = value[2];
			navigation.computeViewMatrix();
		});
	
	// TODO : maybe improve it ?
	// End point which is out of frustum invokes two steps animation, one step otherwise
	var end3DValue = this.globe.coordinateSystem.fromGeoTo3D( geoPos );
	if (middleFov > this.renderContext.fov && this.renderContext.worldFrustum.containsSphere( end3DValue, 0.005 ) < 0 )
	{
		// Two steps animation, 'rising' & 'falling'
		
		// Compute the middle value
		var midValue = [startValue[0]*0.5 + endValue[0]*0.5,
			startValue[1]*0.5 + endValue[1]*0.5,
			middleFov];

		// Add two segments
		animation.addSegment(
			0.0, startValue,
			0.5, midValue,
			function(t, a, b) {
				var pt = Numeric.easeInQuad(t);
				var dt = Numeric.easeOutQuad(t);
				return [Numeric.lerp(pt, a[0], b[0]), // geoPos.long
					Numeric.lerp(pt, a[1], b[1]), // geoPos.lat
					Numeric.lerp(dt, a[2], b[2])]; // fov
			});

		animation.addSegment(
			0.5, midValue,
			1.0, endValue,
			function(t, a, b) {
				var pt = Numeric.easeOutQuad(t);
				var dt = Numeric.easeInQuad(t);
				return [Numeric.lerp(pt, a[0], b[0]), // geoPos.long
					Numeric.lerp(pt, a[1], b[1]), // geoPos.lat
					Numeric.lerp(dt, a[2], b[2])]; // fov
		});
	}
	else
	{
		// One step animation, 'falling' only
		
		// Add only one segment
		animation.addSegment(
			0.0, startValue,
			1.0, endValue,
			function(t, a, b) {
				var pt = Numeric.easeOutQuad(t);
				var dt = Numeric.easeInQuad(t);
				return [Numeric.lerp(pt, a[0], b[0]),  // geoPos.long
					Numeric.lerp(pt, a[1], b[1]),  // geoPos.lat
					Numeric.lerp(dt, a[2], b[2])];  // fov
		});
	}

	animation.onstop = function() {
		if ( callback )
		{
			callback();
		}
		navigation.zoomToAnimation = null;
	}
	
	this.globe.addAnimation(animation);
	animation.start();
	this.zoomToAnimation = animation;
}

/**************************************************************************************************************/

/** @export
	Move to a 3d position
	@param {Float[]} geoPos Array of two floats corresponding to final Longitude and Latitude(in this order) to zoom
	@param {Int} duration Duration of animation in milliseconds
	@param {Function} callback Callback on the end of animation
 */
AstroNavigation.prototype.moveTo = function(geoPos, duration, callback)
{
	var navigation = this;
	
	duration = duration || 5000;
	
	// Create a single animation to animate center3d
	var geoStart = [];
	this.globe.coordinateSystem.from3DToGeo(this.center3d, geoStart);
	
	var startValue = [geoStart[0], geoStart[1]];
	var endValue = [geoPos[0], geoPos[1]];
	
	// Compute the shortest path if needed
	if (Math.abs(geoPos[0] - geoStart[0]) > 180. )
	{
		if (geoStart[0] < geoPos[0])
			startValue[0] += 360;
		else
			endValue[0] +=360;
	}
	
	var animation = new SegmentedAnimation(
		duration,
		// Value setter
		function(value) {
			var position3d = navigation.globe.coordinateSystem.fromGeoTo3D( [ value[0], value[1] ] );
			navigation.center3d[0] = position3d[0];
			navigation.center3d[1] = position3d[1];
			navigation.center3d[2] = position3d[2];
			navigation.computeViewMatrix();
		}
	);
	
	animation.addSegment(
		0.0, startValue,
		1.0, endValue,
		function(t, a, b) {
			var pt = Numeric.easeOutQuad(t);
			return [Numeric.lerp(pt, a[0], b[0]),  // geoPos.long
				Numeric.lerp(pt, a[1], b[1])];  // geoPos.lat
		}
	);

	animation.onstop = function() {
		if ( callback )
		{
			callback();
		}
	}
	
	this.globe.addAnimation(animation);
	animation.start();
}

/**************************************************************************************************************/

/**
 *	Move up vector
 */
 AstroNavigation.prototype.moveUpTo = function(vec, duration)
 {
	// Create a single animation to animate up
	var startValue = [];
	var endValue = [];
	this.globe.coordinateSystem.from3DToGeo(this.up, startValue);
	this.globe.coordinateSystem.from3DToGeo(vec, endValue);
	var duration = duration || 1000;

	var navigation = this;
	var animation = new SegmentedAnimation(
		duration,
		// Value setter
		function(value) {
			var position3d = navigation.globe.coordinateSystem.fromGeoTo3D( [ value[0], value[1] ] );
			navigation.up[0] = position3d[0];
			navigation.up[1] = position3d[1];
			navigation.up[2] = position3d[2];
			navigation.computeViewMatrix();
		}
	);
	
	animation.addSegment(
		0.0, startValue,
		1.0, endValue,
		function(t, a, b) {
			var pt = Numeric.easeOutQuad(t);
			return [Numeric.lerp(pt, a[0], b[0]),  // geoPos.long
				Numeric.lerp(pt, a[1], b[1])];  // geoPos.lat
		}
	);
	
	this.globe.addAnimation(animation);
	animation.start();
}

/**************************************************************************************************************/

/**
	Compute the view matrix
 */
AstroNavigation.prototype.computeViewMatrix = function()
{
	var eye = [];
	vec3.normalize(this.center3d);
	
	var vm = this.renderContext.viewMatrix;

	mat4.lookAt([0., 0., 0.], this.center3d, this.up, vm);
	// mat4.inverse( vm );
	// mat4.rotate(vm, this.heading * Math.PI/180., [1., 0., 0.])
	// mat4.inverse( vm );

	this.up = [ vm[1], vm[5], vm[9] ];
	this.publish("modified");
	this.renderContext.requestFrame();
}

/**************************************************************************************************************/

/**
	Event handler for mouse wheel
	@param delta Delta zoom
 */
AstroNavigation.prototype.zoom = function(delta, scale)
{
	
	// TODO : improve zoom, using scale or delta ? We should use scale always
	if ( scale )
	{
		this.renderContext.fov *= 1/scale;
	}
	else
	{
		// Arbitrary value for smooth zooming
		this.renderContext.fov *= (1 + delta * 0.1);
	}
	
	this._clampFov();
	this.computeViewMatrix();
}

/**************************************************************************************************************/

/**
	Pan the navigation by computing the difference between 3D centers
	@param dx Window delta x
	@param dy Window delta y
 */
AstroNavigation.prototype.pan = function(dx, dy)
{
	var x = this.renderContext.canvas.width / 2.;
	var y = this.renderContext.canvas.height / 2.;
	var ray = Ray.createFromPixel(this.renderContext, x - dx, y - dy);
	this.center3d = ray.computePoint( ray.sphereIntersect( [0,0,0], this.globe.coordinateSystem.radius ) );
		
	this.computeViewMatrix();
}

/**************************************************************************************************************/

/**
	Rotate the navigation
	@param dx Window delta x
	@param dy Window delta y
 */
AstroNavigation.prototype.rotate = function(dx,dy)
{
	// constant tiny angle 
	var angle = dx * 0.1 * Math.PI/180.;
	
	var rot = quat4.fromAngleAxis(angle,this.center3d);
	quat4.multiplyVec3( rot, this.up );

	this.computeViewMatrix();
}

/**************************************************************************************************************/

/**
 *	Clamping of fov
 */
AstroNavigation.prototype._clampFov = function() {
	if ( this.renderContext.fov > this['maxFov'] )
	{
		this.renderContext.fov = this['maxFov'];
	}
	if ( this.renderContext.fov < this['minFov'] )
	{
		this.renderContext.fov = this['minFov'];
	}
}

/**************************************************************************************************************/

return AstroNavigation;

});
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 define( 'Stats',[],function() {
 
/**************************************************************************************************************/

/** 
	@name Stats
	@class
	Display some rendering statistics in a HTML element
	@param options Configuration properties for Stats.
		<ul>
			<li>element : the HTML element to receivce statistcs, can be a string (the ID) or the DOM element itself</li>
			<li>verbose : the verbosity of the stats, default is false</li>
		</ul>
 */
var Stats = function(renderContext,options)
{
	renderContext.stats = this;
	this.renderContext = renderContext;
	
	var elt = options ? options['element'] : undefined;
	if ( elt )
	{	
		if (typeof elt == "string") 
		{
			this.element = document.getElementById(elt);
		}
		else
		{
			this.element = elt;
		}
	}
	
	this.showFPS = this.renderContext.continuousRendering;
	this.verbose = options && options['verbose'] ? options['verbose'] : false;
	this.numFrames = 0;
	
	var self = this;
	window.setInterval( function() { self.print(); }, 1000 );
}

/**************************************************************************************************************/

/** 
	Start measuring time
 */
Stats.prototype.start = function(name)
{
	this[name] = Date.now();
}

/**************************************************************************************************************/

/** 
	End measuring time
 */
Stats.prototype.end = function(name)
{
	var time = Date.now() - this[name];
	
	var max = this["max_"+name] || -1; 
	if (max < time) max = time;
	
	var sum = this["sum_"+name] || 0; 
	sum += time;
	
	this[name] = time;
	this["max_"+name] = max;
	this["sum_"+name] = sum;
	
	if ( name == "globalRenderTime" )
	{
		this.numFrames++;
	}
}

/**************************************************************************************************************/

/** 
	Print stats in an HTML element
 */
Stats.prototype.print = function()
{
	if ( this.numFrames > 0 )
	{
		var content = "";
		
		if ( this.showFPS )
		{
			content += "FPS : " + this.numFrames + "<br>";
		}
		
		content += "Average render time : " + (this["sum_globalRenderTime"] / this.numFrames).toFixed(2) + " ms";
		// FIXME: currently count stats for the first renderer in render context
		if ( this.renderContext.renderers[0].getRenderStats )
			content += "<br>" + this.renderContext.renderers[0].getRenderStats();
		
		if ( this.verbose )
		{
			content += "<br>Average traverse tiles time : " + (this["sum_traverseTime"] / this.numFrames).toFixed(2) + " ms";
			content += "<br>Average render tiles time : " + (this["sum_renderTime"] / this.numFrames).toFixed(2) + " ms";
			content += "<br>Average generate tiles time : " + (this["sum_generateTime"] / this.numFrames).toFixed(2) + " ms";
			content += "<br>Average request tiles time : " + (this["sum_requestTime"] / this.numFrames).toFixed(2) + " ms";
			content += "<br>Max render time : " + this["max_globalRenderTime"] + " ms";
			content += "<br>Max traverse tiles time : " + this["max_traverseTime"] + " ms";
			content += "<br>Max render tiles time : " + this["max_renderTime"] + " ms";
			content += "<br>Max generate tiles time : " + this["max_generateTime"]  + " ms";
			content += "<br>Max request tiles time : " + this["max_requestTime"] + " ms";
		}
		
		this.element.innerHTML = content;
		
		this["sum_globalRenderTime"] = 0;
		this["sum_traverseTime"] = 0;
		this["sum_renderTime"] = 0;
		this["sum_generateTime"] = 0;
		this["sum_requestTime"] = 0;
		this["max_globalRenderTime"] = 0;
		this["max_traverseTime"] = 0;
		this["max_renderTime"] = 0;
		this["max_generateTime"] = 0;
		this["max_requestTime"] = 0;
		this.numFrames = 0;
	}
}

/**************************************************************************************************************/

return Stats;

});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('VectorRenderer',['./RendererTileData','./Tile'],
	function(RendererTileData, Tile) {

/**************************************************************************************************************/

/** @constructor
	VectorRenderer constructor
 */
var VectorRenderer = function(globe)
{
	this.tileManager = globe.tileManager;
	this.globe = globe;
	this.buckets = [];
	this.maxTilePerGeometry = 100;
	this.levelZeroTiledGeometries = [];
}

/**************************************************************************************************************/

/**
	Find a compatible bucket
 */
VectorRenderer.prototype.findBucket = function(layer,style)
{
	// Find an existing bucket for the given style
	for ( var i = 0; i < this.buckets.length; i++ )
	{
		var bucket = this.buckets[i];
		if ( bucket.layer == layer 
			&& bucket.isCompatible(style) )
		{
			return bucket;
		}
	}

	return null;
}


/**************************************************************************************************************/

/**
 	Generate the level zero for a tile
 */
VectorRenderer.prototype.generateLevelZero = function(tile)
{
	for ( var i=0; i < this.levelZeroTiledGeometries.length; i++ )
	{
		var geometry = this.levelZeroTiledGeometries[i];
		
		// Check that the geometry is on this tile
		var isFound = false;
		for ( var n = 0; n < geometry._tileIndices.length && !isFound; n++ )
		{
			var t = this.tileManager.level0Tiles[ geometry._tileIndices[n] ];
			isFound = ( t == tile );
		}
		
		// Found the tile, so add it
		if ( isFound )
		{
			this._addGeometryToTile(geometry._bucket, geometry, tile);
		}
	}
}

/**************************************************************************************************************/

/**
 	Recursively add a geometry to a tile
*/
VectorRenderer.prototype._recursiveAddGeometryToTile = function(bucket, geometry, tile)
{
	var renderable = this._addGeometryToTile(bucket, geometry, tile);
	
	if ( renderable && renderable.generateChild && tile.children)
	{
		for ( var i = 0; i < 4; i++ )
		{
			if ( tile.children[i].state == Tile.State.LOADED )
			{
				renderable.hasChildren = true;
				this._recursiveAddGeometryToTile( bucket, geometry, tile.children[i] );
			}
		}
	}
}

/**************************************************************************************************************/

/**
 	Add a geometry to a vector renderer
 */
VectorRenderer.prototype.addGeometry = function(layer, geometry, style)
{
	var bucket = this.getOrCreateBucket(layer, geometry, style);
	geometry._bucket = bucket;
	
	var tileIndices = this.maxTilePerGeometry > 0 ? this.tileManager.tiling.getOverlappedLevelZeroTiles(geometry) : null;
	if ( tileIndices && tileIndices.length < this.maxTilePerGeometry )
	{
		// Add geometry to each tile in range
		for ( var i=0; i < tileIndices.length; i++ )
		{
			var tile = this.tileManager.level0Tiles[ tileIndices[i] ];
			if ( tile.state == Tile.State.LOADED )
			{
				this._recursiveAddGeometryToTile(bucket, geometry, tile);
			}
		}
		
		geometry._tileIndices = tileIndices;
		this.levelZeroTiledGeometries.push(geometry);
	}
	else
	{
		// Attach to mainRenderable
		if (!bucket.mainRenderable)
		{
			bucket.mainRenderable = bucket.createRenderable();
		}
		bucket.mainRenderable.add(geometry);
	}
}

/**************************************************************************************************************/

/**
 	Remove a geometry from a vector renderer
 */
VectorRenderer.prototype.removeGeometry = function(geometry)
{
	var tileIndices = geometry._tileIndices;

	if ( tileIndices )
	{
		// Remove from tile
		for ( var i = 0; i < tileIndices.length; i++ )
		{
			var tile = this.tileManager.level0Tiles[ tileIndices[i] ];
			this.removeGeometryFromTile(geometry, tile);
		}
		// Remove from geometry arrays
		this.levelZeroTiledGeometries.splice( this.levelZeroTiledGeometries.indexOf(geometry), 1 );
		
		 geometry._tileIndices = null;
	}
	else
	{
		var bucket = geometry._bucket;
		if ( bucket.mainRenderable )
		{
			var numGeometries = bucket.mainRenderable.remove(geometry);
			if ( numGeometries == 0 )
			{
				bucket.mainRenderable.dispose(this.renderContext);
				bucket.mainRenderable = null;
			}
		}
	}
}

/**************************************************************************************************************/

/**
 	Get or create a bucket for the given configuration
 */
VectorRenderer.prototype.getOrCreateBucket = function(layer, geometry, style )
{		
	// Then find an existing bucket
	var bucket = this.findBucket(layer,style);
	if (!bucket)
	{
		bucket = this.createBucket(layer,style);
		bucket.renderer = this;
		bucket.id = this.globe.vectorRendererManager.bucketId++;
		this.buckets.push( bucket );
	}
	return bucket;
}

/**************************************************************************************************************/

/**
	Add a geometry to a tile
 */
VectorRenderer.prototype.addGeometryToTile = function(layer, geometry, style, tile)
{
	var bucket = this.getOrCreateBucket(layer, geometry, style);
	geometry._bucket = bucket;
	return this._addGeometryToTile( bucket, geometry, tile );
}
	
/**************************************************************************************************************/

/**
	Internal method to add a geometry to a tile
 */
VectorRenderer.prototype._addGeometryToTile = function(bucket, geometry, tile)
{	
	var tileData = tile.extension.renderer;
	if (!tileData)
	{
		tileData = tile.extension.renderer = new RendererTileData(this.globe.vectorRendererManager);
	}
	
	var renderable = tileData.getRenderable(bucket);
	var needsToAdd = false;
	if (!renderable) 
	{
		renderable = bucket.createRenderable();
		needsToAdd = true;
	}
	
	if ( renderable.add(geometry, tile) )
	{
		if (needsToAdd)
		{
			tileData.renderables.push(renderable);
		}
		return renderable;
	}
	
	return null;
}

/**************************************************************************************************************/

/**
	Remove a geometry from a tile
 */
VectorRenderer.prototype.removeGeometryFromTile = function(geometry,tile)
{
	var tileData = tile.extension.renderer;
	if (tileData)
	{
		var i = 0;
		while ( i < tileData.renderables.length )
		{
			var renderable = tileData.renderables[i];
			var renderer = renderable.bucket.renderer;
			if ( renderer == this )
			{
				// Remove renderable
				var numGeometries = renderable.remove(geometry);
				if ( numGeometries == 0 )
				{
					tileData.renderables.splice(i,1);
				}
				else
				{
					i++;
				}
	
				// Remove geoemtry from children if needed
				if ( renderable.hasChildren && tile.children)
				{
					for ( var n = 0; n < 4; n++ )
					{
						if ( tile.children[n].state == Tile.State.LOADED )
						{
							this.removeGeometryFromTile( geometry, tile.children[n] );
						}
					}
				}
			}
			else
			{
				i++;
			}
		}
	}
}

/**************************************************************************************************************/

return VectorRenderer;

});
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('PointSpriteRenderer',['./Utils','./VectorRenderer','./Program','./FeatureStyle', './VectorRendererManager'],
	function(Utils,VectorRenderer,Program,FeatureStyle,VectorRendererManager) {

/**************************************************************************************************************/

/** @constructor
	PointSpriteRenderer constructor
 */
var PointSpriteRenderer = function(globe)
{
	VectorRenderer.prototype.constructor.call( this, globe );
	
	// For stats
	this.numberOfRenderPoints = 0;
 	
	var vertexShader = "\
	attribute vec3 vertex; \n\
	uniform mat4 viewProjectionMatrix; \n\
	uniform float pointSize; \n\
	void main(void)  \n\
	{ \n\
		gl_Position = viewProjectionMatrix * vec4(vertex,1.0); \n\
		gl_PointSize = pointSize; \n\
	} \n\
	";
	
	var fragmentShader = "\
	precision lowp float; \n\
	uniform sampler2D texture; \n\
	uniform float alpha; \n\
	uniform vec3 color; \n\
	\n\
	void main(void) \n\
	{ \n\
		vec4 textureColor = texture2D(texture, gl_PointCoord); \n\
		gl_FragColor = vec4(textureColor.rgb * color, textureColor.a * alpha); \n\
		if (gl_FragColor.a <= 0.0) discard; \n\
		//gl_FragColor = vec4(1.0); \n\
	} \n\
	";

    this.program = new Program(globe.renderContext);
    this.program.createFromSource(vertexShader, fragmentShader);
	
	this.defaultTexture = null;
}

Utils.inherits(VectorRenderer,PointSpriteRenderer);

/**************************************************************************************************************/

/**
 * Renderable constructor for PointSprite
 */
var Renderable = function(bucket) 
{
	this.bucket = bucket;
	this.geometry2vb = {};
	this.vertices = [];
	this.vertexBuffer = null;
	this.vertexBufferDirty = false;
}

/**************************************************************************************************************/

/**
 * Add a geometry to the renderbale
 * @return if the geometry has been successfully added to the renderable
 */
Renderable.prototype.add = function(geometry)
{
	this.geometry2vb[ geometry.gid ] = this.vertices.length;
	// TODO: Find a better way to access to coordinate system
	var pt = this.bucket.renderer.globe.coordinateSystem.fromGeoTo3D( geometry['coordinates'] );
	// Hack : push away/abroad the point depending on globe type
	var scale = this.bucket.renderer.globe.isSky ? 0.99 : 1.01;
	this.vertices.push( scale * pt[0], scale * pt[1], scale * pt[2] );
	this.vertexBufferDirty = true;
	
	return true;
}

/**************************************************************************************************************/

/**
 * Remove a geometry from the renderable
 */
Renderable.prototype.remove = function(geometry)
{
	if ( this.geometry2vb.hasOwnProperty(geometry.gid) )
	{
		var vbIndex = this.geometry2vb[ geometry.gid ];
		delete this.geometry2vb[ geometry.gid ];
		this.vertices.splice( vbIndex, 3 );
		this.vertexBufferDirty = true;
		
		// Update render data for all other geometries
		for ( var g in this.geometry2vb ) 
		{
			if ( g ) 
			{
				if ( this.geometry2vb[g] > vbIndex ) 
				{
					this.geometry2vb[g] -= 3;
				}
			}
		}
	}
	return this.vertices.length;
}

/**************************************************************************************************************/

/**
 * Dispose the renderable
 */
Renderable.prototype.dispose = function(renderContext)
{
	if ( this.vertexBuffer ) 
	{
		renderContext.gl.deleteBuffer( this.vertexBuffer );
	}
}

/**************************************************************************************************************/

/**
	Build a default texture
 */
PointSpriteRenderer.prototype._buildDefaultTexture = function(bucket)
{  	
	if ( !this.defaultTexture )
	{
		var gl = this.globe.renderContext.gl;
		this.defaultTexture = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, this.defaultTexture);
		var whitePixel = new Uint8Array([255, 255, 255, 255]);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, whitePixel);
	}

	bucket.texture = this.defaultTexture;
	bucket.textureWidth = 10;
	bucket.textureHeight = 10;
}

/**************************************************************************************************************/

/**
	Build a texture from an image and store in a bucket
 */
PointSpriteRenderer.prototype._buildTextureFromImage = function(bucket,image)
{  	
	bucket.texture = this.globe.renderContext.createNonPowerOfTwoTextureFromImage(image);
	bucket.textureWidth = image.width;
	bucket.textureHeight = image.height;
}

/**************************************************************************************************************/

/**
	Check if renderer is applicable
 */
PointSpriteRenderer.prototype.canApply = function(type,style)
{
	return type == "Point" && !style.label; 
}

/**************************************************************************************************************/

/**
	Bucket constructor for PointSpriteRenderer
 */
 var Bucket = function(layer,style)
{
	this.layer = layer;
	this.style = new FeatureStyle(style);
	this.texture = null;
	this.renderer = null;
}

/**************************************************************************************************************/

/**
	Create a renderable for this bucket
 */
Bucket.prototype.createRenderable = function()
{
	return new Renderable(this);
}

/**************************************************************************************************************/

/**
	Check if a bucket is compatible
 */
Bucket.prototype.isCompatible = function(style)
{
	if ( this.style.iconUrl == style.iconUrl
		&& this.style.icon == style.icon
		&& this.style.fillColor[0] == style.fillColor[0]
		&& this.style.fillColor[1] == style.fillColor[1]
		&& this.style.fillColor[2] == style.fillColor[2] )
	{
		return true;
	}
	
	return false;
}

/**************************************************************************************************************/

/**
	Create bucket to render a point
 */
PointSpriteRenderer.prototype.createBucket = function(layer,style)
{
	var gl = this.globe.renderContext.gl;
	var vb = gl.createBuffer();

	// Create a bucket
	var bucket = new Bucket(layer,style);
	bucket.renderer = this;
		
	// Initialize bucket : create the texture	
	if ( style['iconUrl'] )
	{
		var image = new Image();
		image.crossOrigin = '';
		var self = this;
		image.onload = function() {self._buildTextureFromImage(bucket,image); self.globe.renderContext.requestFrame(); }
		image.onerror = function() { self._buildDefaultTexture(bucket); }
		image.src = style.iconUrl;
	}
	else if ( style['icon'] )
	{
		this._buildTextureFromImage(bucket,style.icon);
	}
	else
	{
		this._buildDefaultTexture(bucket);
	}
	
	return bucket;
}

/**************************************************************************************************************/

/**
	Render
 */
PointSpriteRenderer.prototype.render = function(renderables,start,end)
{	
	var renderContext = this.globe.renderContext;
	var gl = renderContext.gl;
	
	// Setup states
	//gl.disable(gl.DEPTH_TEST);
	gl.enable(gl.BLEND);
	gl.blendEquation(gl.FUNC_ADD);
	gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

	// Setup program
	this.program.apply();
	
	// The shader only needs the viewProjection matrix, use GlobWeb.modelViewMatrix as a temporary storage
	mat4.multiply(renderContext.projectionMatrix, renderContext.viewMatrix, renderContext.modelViewMatrix)
	gl.uniformMatrix4fv(this.program.uniforms["viewProjectionMatrix"], false, renderContext.modelViewMatrix);
	gl.uniform1i(this.program.uniforms["texture"], 0);
	
	// Render each renderables
	var currentBucket = null;
	for ( var n = start; n < end; n++ )
	{
		var renderable = renderables[n];
		var bucket = renderable.bucket;
		
		if ( currentBucket != bucket )
		{
			gl.uniform1f(this.program.uniforms["alpha"], bucket.layer._opacity);
			var color = bucket.style.fillColor;
			gl.uniform3f(this.program.uniforms["color"], color[0], color[1], color[2] );
			gl.uniform1f(this.program.uniforms["pointSize"], bucket.textureWidth);
			
			// Bind point texture
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, bucket.texture);
			
			currentBucket = bucket;
		}
		
			
		if ( !renderable.vertexBuffer )
		{
			renderable.vertexBuffer = gl.createBuffer();
		}
		
		gl.bindBuffer(gl.ARRAY_BUFFER, renderable.vertexBuffer);
		gl.vertexAttribPointer(this.program.attributes['vertex'], 3, gl.FLOAT, false, 0, 0);
		
		if ( renderable.vertexBufferDirty )
		{
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(renderable.vertices), gl.STATIC_DRAW);
			renderable.vertexBufferDirty = false;
		}

							
		gl.drawArrays(gl.POINTS, 0, renderable.vertices.length/3);
	}

    //gl.enable(gl.DEPTH_TEST);
    gl.disable(gl.BLEND);
}


/**************************************************************************************************************/

// Register the renderer
VectorRendererManager.factory.push( function(globe) { return new PointSpriteRenderer(globe); } );

return PointSpriteRenderer;

});
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/
 
 define( 'Triangulator',[],function() {
 
 /**
  Triangulator code taken from http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
  Does not manage holes
  Seems to be O(n^3)!
 */
var EPSILON = 0.0000000001;

/*
 Compute the signed area of a polygon
*/
var Area = function(contour)
{
	var n = contour.length;
	var A=0.0;
	for(var p=n-1,q=0; q<n; p=q++)
	{
		A+= contour[p][0]*contour[q][1] - contour[q][0]*contour[p][1];
	}
	return A*0.5;
}

/*
 InsideTriangle decides if a point P is Inside of the triangle
 defined by A, B, C.
*/
var InsideTriangle = function(Ax, Ay,
					  Bx, By,
					  Cx, Cy,
					  Px, Py)

{
  var ax, ay, bx, by, cx, cy, apx, apy, bpx, bpy, cpx, cpy;
  var cCROSSap, bCROSScp, aCROSSbp;

  ax = Cx - Bx;  ay = Cy - By;
  bx = Ax - Cx;  by = Ay - Cy;
  cx = Bx - Ax;  cy = By - Ay;
  apx= Px - Ax;  apy= Py - Ay;
  bpx= Px - Bx;  bpy= Py - By;
  cpx= Px - Cx;  cpy= Py - Cy;

  aCROSSbp = ax*bpy - ay*bpx;
  cCROSSap = cx*apy - cy*apx;
  bCROSScp = bx*cpy - by*cpx;

  return ((aCROSSbp >= 0.0) && (bCROSScp >= 0.0) && (cCROSSap >= 0.0));
};

/*
 Check if the giben triangle (u,v,w) is a ear : not other vertex inside
*/
var Snip = function(contour, u, v, w, n, V)
{
  var p;
  var Ax, Ay, Bx, By, Cx, Cy, Px, Py;

  Ax = contour[V[u]][0];
  Ay = contour[V[u]][1];

  Bx = contour[V[v]][0];
  By = contour[V[v]][1];

  Cx = contour[V[w]][0];
  Cy = contour[V[w]][1];

  if ( EPSILON > (((Bx-Ax)*(Cy-Ay)) - ((By-Ay)*(Cx-Ax))) ) return false;

  for (p=0;p<n;p++)
  {
	if( (p == u) || (p == v) || (p == w) ) continue;
	Px = contour[V[p]][0];
	Py = contour[V[p]][1];
	if (InsideTriangle(Ax,Ay,Bx,By,Cx,Cy,Px,Py)) return false;
  }

  return true;
}
			
/*
 Process triangulation on the given contour
*/
var Process = function( contour )
{
  /* allocate and initialize list of Vertices in polygon */

  var n = contour.length; 
  if ( contour[0][0] == contour[n-1][0] && contour[0][1] == contour[n-1][1] )
	n--;
	
  if ( n < 3 ) return null;

  var V = new Array(n);

  /* we want a counter-clockwise polygon in V */

  if ( 0.0 < Area(contour) )
	for (var v=0; v<n; v++) V[v] = v;
  else
	for(var v=0; v<n; v++) V[v] = (n-1)-v;

  var nv = n;
  
  var results = [];

  /*  remove nv-2 Vertices, creating 1 triangle every time */
  var count = 2*nv;   /* error detection */

  for (var m=0, v=nv-1; nv>2; )
  {
	/* if we loop, it is probably a non-simple polygon */
	if (0 >= (count--))
	{
	  //** Triangulate: ERROR - probable bad polygon!
	  return null;
	}

	/* three consecutive vertices in current polygon, <u,v,w> */
	var u = v  ; if (nv <= u) u = 0;     /* previous */
	v = u+1; if (nv <= v) v = 0;     /* new v    */
	var w = v+1; if (nv <= w) w = 0;     /* next     */

	if ( Snip(contour,u,v,w,nv,V) )
	{
	  var a,b,c,s,t;

	  /* true names of the vertices */
	  a = V[u]; b = V[v]; c = V[w];

	  /* output Triangle */
	  results.push( a );
	  results.push( b );
	  results.push( c );
	  
	  m++;

	  /* remove v from remaining polygon */
	  for(s=v,t=v+1;t<nv;s++,t++) V[s] = V[t]; nv--;

	  /* resest error detection counter */
	  count = 2*nv;
	}
  }

  return results;
}
	
var Triangulator = 	{
	process: Process
};

return Triangulator;

});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('ConvexPolygonRenderer',['./Utils','./VectorRenderer','./Program','./FeatureStyle', './VectorRendererManager', './Triangulator', './glMatrix'],
	function(Utils,VectorRenderer,Program,FeatureStyle,VectorRendererManager, Triangulator) {

/**************************************************************************************************************/

/** @constructor
	ConvexPolygonRenderer constructor
 */
var ConvexPolygonRenderer = function(globe)
{
	VectorRenderer.prototype.constructor.call( this, globe );
	this.maxTilePerGeometry = 2;
	
	// Store object for rendering
	this.renderContext = globe.tileManager.renderContext;
	this.tileConfig = globe.tileManager.tileConfig;
	
	this.programs = [];

	this.basicVertexShader = "\
	attribute vec3 vertex;\n\
	uniform mat4 viewProjectionMatrix;\n\
	\n\
	void main(void)\n\
	{\n\
		gl_Position = viewProjectionMatrix * vec4(vertex, 1.0);\n\
	}\n\
	";
	
	this.basicFragmentShader = "\
	precision lowp float; \n\
	uniform vec4 color; \n\
	\n\
	void main(void) \n\
	{ \n\
		gl_FragColor = color; \n\
	} \n\
	";
	
	this.texVertexShader = "\
	attribute vec3 vertex;\n\
	attribute vec2 tcoord;\n\
	uniform mat4 viewProjectionMatrix;\n\
	\n\
	varying vec2 vTextureCoord;\n\
	\n\
	void main(void) \n\
	{\n\
		vTextureCoord = tcoord;\n\
		vTextureCoord.y = 1.0 - vTextureCoord.y; \n\
		gl_Position = viewProjectionMatrix * vec4(vertex, 1.0);\n\
	}\n\
	";


	this.texFragmentShader = "\
		precision lowp float; \n\
		uniform vec4 color;\n\
		varying vec2 vTextureCoord;\n\
		uniform sampler2D texture; \n\
		void main(void)\n\
		{\n\
			gl_FragColor = texture2D(texture, vTextureCoord) * color;\n\
		}\n\
		";

	this.basicFillShader = {
		vertexCode: this.basicVertexShader,
		fragmentCode: this.basicFragmentShader,
		updateUniforms: null
	};

	this.texFillShader = {
		vertexCode: this.texVertexShader,
		fragmentCode: this.texFragmentShader,
		updateUniforms: null
	};


	this.basicProgram = this.createProgram(this.basicFillShader);
	this.texProgram = this.createProgram(this.texFillShader);

	var gl = this.renderContext.gl;
	// Parameters used to implement ONE shader for color xor texture rendering
	this.whiteTexture = gl.createTexture();
	gl.bindTexture(gl.TEXTURE_2D, this.whiteTexture);
	var whitePixel = new Uint8Array([255, 255, 255, 255]);
	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, whitePixel);

	// Shared buffer
	// Create texCoord buffer
	this.tcoordBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, this.tcoordBuffer);
	
	var textureCoords = [
		0.0, 0.0,
		1.0, 0.0,
		1.0, 1.0,
		0.0, 1.0,
		0.0, 0.0
	];
	
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoords), gl.STATIC_DRAW);
	this.tcoordBuffer.itemSize = 2;
	this.tcoordBuffer.numItems = 5;
}

Utils.inherits(VectorRenderer,ConvexPolygonRenderer);

/**************************************************************************************************************/

/**
	Renderable constructor
	Attach to a bucket
 */
var Renderable = function(bucket) 
{
	this.bucket = bucket;
	this.geometry2vb = {};
	this.vertices = [];
	this.lineIndices = [];
	this.triangleIndices = [];
	this.vertexBuffer = null;
	this.lineIndexBuffer = null;
	this.triangleIndexBuffer = null;
	this.bufferDirty = false;
	this.triBufferDirty = false;
	this.tcoords = [];
}

/**************************************************************************************************************/

/**
 *	Add the geometry to the renderable
 * @return if the geometry has been successfully added to the renderable
 */
Renderable.prototype.add = function(geometry)
{
	var rings = [];
	if ( geometry['type'] == 'MultiPolygon' )
	{
		for ( var i=0; i<geometry['coordinates'].length; i++ )
		{
			rings.push( geometry['coordinates'][i][0] );
		}
	}
	else
	{
		rings.push( geometry['coordinates'][0] );
	}

	for ( var r=0; r<rings.length; r++ )
	{
		var coords = rings[r];
		// var coords = geometry['coordinates'][0];
		var numPoints = coords.length-1;
		
		// Store information for the geometry in the buffers used for rendering
		var data = {
			vertexStart: this.vertices.length,
			vertexCount: 3 * numPoints,
			lineIndexStart: this.lineIndices.length,
			lineIndexCount: 2 * numPoints,
			triIndexStart: 0,
			triIndexCount: 0
		};

		var coordinateSystem = this.bucket.renderer.globe.coordinateSystem;
		// Compute texture coordinates if defined
		if ( geometry._imageCoordinates )
		{
			data.tcoordsStart = this.tcoords.length;
			data.tcoordsCount = 2 * numPoints;

			// Initialize variables used for texture coordinates computation
			var p0 = coordinateSystem.fromGeoTo3D( geometry._imageCoordinates[0][0] ); // origin
			var p1 = coordinateSystem.fromGeoTo3D( geometry._imageCoordinates[0][1] );
			var p3 = coordinateSystem.fromGeoTo3D( geometry._imageCoordinates[0][3] ); 
			var v01 = [];
			vec3.subtract( p1, p0, v01 ); // U-axis
			var v03 = [];
			vec3.subtract( p3, p0, v03 ); // V-axis
			var squaredU = vec3.length(v01) * vec3.length(v01);
			var squaredV = vec3.length(v03) * vec3.length(v03);

			for ( var i=0; i<numPoints; i++ )
			{
				var pt = coordinateSystem.fromGeoTo3D( coords[i] );
				var v0P = [];
				vec3.subtract( pt, p0, v0P );

				var uDotProduct = vec3.dot( v0P, v01 );
				var vDotProduct = vec3.dot( v0P, v03 );
				var u = uDotProduct / squaredU;
				var v = vDotProduct / squaredV;
				this.tcoords.push( u );
				this.tcoords.push( v );		
			}

		}
		
		// Compute vertices and indices and store them in the buffers
		var startIndex = this.vertices.length / 3;
		for ( var i = 0; i < numPoints; i++ ) 
		{
			var pt = coordinateSystem.fromGeoTo3D( coords[i] );
			this.vertices.push( pt[0], pt[1], pt[2] );
			this.lineIndices.push( startIndex + i, startIndex + ((i+1) % numPoints) );
		}
		
		// If fill, build the triangle indices
		if ( this.bucket.style.fill ) 
		{
			data.triIndexStart = this.triangleIndices.length;
			data.triIndexCount = 3 * (numPoints-2);
			
			var triangleIndices = Triangulator.process( coords );
			if ( triangleIndices != null  )
			{
				this.triangleIndices = triangleIndices;
			}
			else
			{
				// HACK for not trivial polygons
				for ( var i = 0; i < numPoints-2; i++ ) 
				{
					this.triangleIndices.push( startIndex, startIndex + i+1, startIndex + i+2 );
				}
			}
		}

		if ( this.geometry2vb[ geometry.gid ] )
		{
			this.geometry2vb[ geometry.gid ].vertexCount += data.vertexCount;
			this.geometry2vb[ geometry.gid ].lineIndexCount += data.lineIndexCount;
			this.geometry2vb[ geometry.gid ].triIndexCount += data.triIndexCount;
		}
		else
		{
			this.geometry2vb[ geometry.gid ] = data;
		}
		
		this.bufferDirty = true;
		this.triBufferDirty = true;
	}
	
	return true;
}

/**************************************************************************************************************/

/**
	Remove the geometry from the renderable
 */
Renderable.prototype.remove = function(geometry)
{
	if ( this.geometry2vb.hasOwnProperty(geometry.gid) )
	{
		// retreive the render data for the geometry
		var data = this.geometry2vb[ geometry.gid ];
		delete this.geometry2vb[ geometry.gid ];

		// Remove geometry vertex
		this.vertices.splice( data.vertexStart, data.vertexCount );
		
		// Update indices after vertex removal
		for ( var i = data.lineIndexStart+data.lineIndexCount; i < this.lineIndices.length; i++ ) 
		{
			this.lineIndices[i] -= (data.vertexCount/3);
		}
		for ( var i = data.triIndexStart+data.triIndexCount; i < this.triangleIndices.length; i++ ) 
		{
			this.triangleIndices[i] -= (data.vertexCount/3);
		}

		this.lineIndices.splice( data.lineIndexStart, data.lineIndexCount );
		this.triangleIndices.splice( data.triIndexStart, data.triIndexCount );
		if ( data.tcoordsStart >= 0 )
		{
			this.tcoords.splice( data.tcoordsStart, data.tcoordsCount );
		}
		
		// Update render data for all other geometries
		for ( var g in this.geometry2vb ) 
		{
			if ( g ) 
			{
				var d = this.geometry2vb[g];
				if ( d.vertexStart > data.vertexStart ) 
				{
					d.vertexStart -= data.vertexCount;
					d.lineIndexStart -= data.lineIndexCount;
					d.triIndexStart -= data.triIndexCount;
					if ( d.tcoordsStart >= 0 )
					{
						d.tcoordsStart -= data.tcoordsCount;
					}
				}
			}
		}
		
		this.bufferDirty = true;
		this.triBufferDirty = true;
	}
	return this.vertices.length;
}

/**************************************************************************************************************/

/**
	Dispose the renderable : remove all buffers
 */
Renderable.prototype.dispose = function(renderContext)
{
	if ( this.vertexBuffer ) 
	{
		renderContext.gl.deleteBuffer( this.vertexBuffer );
	}
	if ( this.lineIndexBuffer ) 
	{
		renderContext.gl.deleteBuffer( this.lineIndexBuffer );
	}
	if ( this.triangleIndexBuffer ) 
	{
		renderContext.gl.deleteBuffer( this.triangleIndexBuffer );
	}
	if ( this.tcoordBuffer )
	{
		renderContext.gl.deleteBuffer( this.tcoordBuffer );
	}
}

/**************************************************************************************************************/

/**
	Check if renderer is applicable
 */
ConvexPolygonRenderer.prototype.canApply = function(type,style)
{
	if ( !this.globe.isSky ) 
		return false;

	return type == "Polygon" || type == "MultiPolygon" || type == "LineString" || type == "MultiLineString"; 
}

/**************************************************************************************************************/

/**
 	Create program from fillShader object	
 */
ConvexPolygonRenderer.prototype.createProgram = function(fillShader)
{
	var program = new Program(this.renderContext);
	program.createFromSource(fillShader.vertexCode, fillShader.fragmentCode);
	
    // Add program
    program.id = this.programs.length;
    this.programs.push({ 
    	fillShader: fillShader,
    	program: program
	});
	return program;
}

/**************************************************************************************************************/

/**
 	Get program if known by renderer, create otherwise
 */
ConvexPolygonRenderer.prototype.getProgram = function(fillShader) {

	var program;

    for(var id=0; id<this.programs.length; id++)
    {
        if( this.programs[id].fillShader == fillShader )
        {
        	program = this.programs[id].program;
        }
    }

    if ( !program )
    {
    	program = this.createProgram(fillShader);
    }
    return program;
}

/**************************************************************************************************************/

/**
	Bucket constructor for ConvexPolygonRenderer
 */
var Bucket = function(layer,style)
{
	this.layer = layer;
	this.style = new FeatureStyle(style);
	this.texture = null;
	this.polygonProgram = null;
	this.renderer = null;
	this.mainRenderable = null;
}

/**************************************************************************************************************/

/**
	Create a renderable for this bucket
 */
Bucket.prototype.createRenderable = function()
{
	return new Renderable(this);
}

/**************************************************************************************************************/

/**
	Check if a bucket is compatible
 */
Bucket.prototype.isCompatible = function(style)
{
	if ( this.style.strokeColor[0] == style.strokeColor[0]
		&& this.style.strokeColor[1] == style.strokeColor[1]
		&& this.style.strokeColor[2] == style.strokeColor[2]
		&& this.style.fill == style.fill
		&& this.style.fillTexture == style.fillTexture
		&& this.style.fillTextureUrl == style.fillTextureUrl
		&& this.style.fillShader == style.fillShader )
	{
		return true;
	}
	
	return false;
}

/**************************************************************************************************************/

/**
	Create bucket to render a polygon
 */
ConvexPolygonRenderer.prototype.createBucket = function(layer,style)
{
	var gl = this.renderContext.gl;
	var vb = gl.createBuffer();

	// Create a bucket
	var bucket = new Bucket(layer,style);

	// Create texture
	var self = this;
	if ( style.fill )
	{
		var hasTexture = false;
		if ( style.fillTextureUrl )
		{
			var image = new Image();
			image.crossOrigin = '';
			image.onload = function () 
			{
				bucket.texture = self.renderContext.createNonPowerOfTwoTextureFromImage(image, layer.invertY);
			}
			
			image.onerror = function(event)
			{
				console.log("Cannot load " + image.src );
			}
			
			image.src = style.fillTextureUrl;
			hasTexture = true;
		}
		else if ( style.fillTexture )
		{
			bucket.texture = style.fillTexture;
			hasTexture = true;
		}
			
		if ( style.fillShader&& style.fillShader.fragmentCode )
		{
			// User defined texture program
			if ( !style.fillShader.vertexCode )
				style.fillShader.vertexCode = this.texVertexShader;
			if ( !style.fillShader.vertexCode )
				style.fillShader.fragmentCode = this.texFragmentShader;

			bucket.polygonProgram = this.getProgram(style.fillShader);
		}
		else
		{
			// Default program
			bucket.polygonProgram = hasTexture ? this.texProgram : this.basicProgram;
		}
	}
		
	return bucket;
}

/**************************************************************************************************************/

/**
	Render all the POIs
 */
ConvexPolygonRenderer.prototype.render = function(renderables,start,end)
{	
	var renderContext = this.renderContext;
	var gl = this.renderContext.gl;
	
	// Setup states
	gl.disable(gl.DEPTH_TEST);
	gl.depthMask(false);
	gl.enable(gl.BLEND);
	gl.blendEquation(gl.FUNC_ADD);
	gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
	
	// Setup the basic program
	this.basicProgram.apply();
	mat4.multiply(renderContext.projectionMatrix, renderContext.viewMatrix, renderContext.modelViewMatrix)
	gl.uniformMatrix4fv(this.basicProgram.uniforms["viewProjectionMatrix"], false, renderContext.modelViewMatrix);
	
	// Render each renderables
	var currentBucket = null;
	for ( var n = start; n < end; n++ )
	{
		var renderable = renderables[n];
		var bucket = renderable.bucket;
		
		// Set the color
		var color = bucket.style.strokeColor;
		gl.uniform4f(this.basicProgram.uniforms["color"], color[0], color[1], color[2], color[3] * bucket.layer.opacity() );
					
		// Update vertex buffer
		if ( !renderable.vertexBuffer )
		{
			renderable.vertexBuffer = gl.createBuffer();
			renderable.lineIndexBuffer = gl.createBuffer();
		}
		
		gl.bindBuffer(gl.ARRAY_BUFFER, renderable.vertexBuffer);
		gl.vertexAttribPointer(this.basicProgram.attributes['vertex'], 3, gl.FLOAT, false, 0, 0);
	
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, renderable.lineIndexBuffer);
		
		if ( renderable.bufferDirty )
		{
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(renderable.vertices), gl.STATIC_DRAW);
			gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(renderable.lineIndices), gl.STATIC_DRAW);
			renderable.bufferDirty = false;
		}

		gl.drawElements( gl.LINES, renderable.lineIndices.length, gl.UNSIGNED_SHORT, 0);

		if ( bucket.polygonProgram )
		{
			var program = bucket.polygonProgram;
			
			program.apply();
			gl.uniformMatrix4fv(program.uniforms["viewProjectionMatrix"], false, renderContext.modelViewMatrix);
			
			gl.uniform1i(program.uniforms["texture"], 0);
			if ( renderable.tcoords.length > 0 )
			{
				// Use tcoord buffer defined by _imageCoordinates
				if ( !renderable.tcoordBuffer )
				{
					renderable.tcoordBuffer = gl.createBuffer();
					gl.bindBuffer(gl.ARRAY_BUFFER, renderable.tcoordBuffer);
								
					gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(renderable.tcoords), gl.STATIC_DRAW);
					renderable.tcoordBuffer.itemSize = 2;
					renderable.tcoordBuffer.numItems = renderable.tcoords.length / 2;
				}

				gl.bindBuffer(gl.ARRAY_BUFFER, renderable.tcoordBuffer);
			}
			else
			{
				// Use default tcoord buffer
				gl.bindBuffer(gl.ARRAY_BUFFER, this.tcoordBuffer);
			}
			gl.vertexAttribPointer(program.attributes['tcoord'], 2, gl.FLOAT, false, 0, 0);
			
			gl.bindBuffer(gl.ARRAY_BUFFER, renderable.vertexBuffer);
			gl.vertexAttribPointer(program.attributes['vertex'], 3, gl.FLOAT, false, 0, 0);
			
			if ( bucket.style.fillShader && bucket.style.fillShader.updateUniforms )
				bucket.style.fillShader.updateUniforms(gl, renderable.bucket, program);
				
			if ( !renderable.triangleIndexBuffer )
			{
				renderable.triangleIndexBuffer = gl.createBuffer();
			}
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, renderable.triangleIndexBuffer);
			if ( renderable.triBufferDirty )
			{
				gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(renderable.triangleIndices), gl.STATIC_DRAW);
				renderable.triBufferDirty = false;
			}
			// Add texture
			gl.activeTexture(gl.TEXTURE0);
			if ( renderable.bucket.texture ) 
			{
				gl.bindTexture(gl.TEXTURE_2D, renderable.bucket.texture); // use texture of renderable
				gl.uniform4f(program.uniforms["color"], 1.0, 1.0, 1.0, color[3] * bucket.layer.opacity());  // use whiteColor
			}
			else
			{
				gl.bindTexture(gl.TEXTURE_2D, this.whiteTexture);  // use white texture
				color = renderable.bucket.style.fillColor;
				gl.uniform4f(program.uniforms["color"], color[0], color[1], color[2], color[3] * bucket.layer.opacity() );
			}
			
			gl.drawElements( gl.TRIANGLES, renderable.triangleIndices.length, gl.UNSIGNED_SHORT, 0);
			
			this.basicProgram.apply();
		}
	}

    gl.enable(gl.DEPTH_TEST);
	gl.depthMask(true);
    gl.disable(gl.BLEND);
}


/**************************************************************************************************************/

// Register the renderer
VectorRendererManager.factory.push( function(globe) { return new ConvexPolygonRenderer(globe); } );

/**************************************************************************************************************/

return ConvexPolygonRenderer;

});
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

 // Declare the AstroWeb namespace
 define( 'AstroWeb',["./Globe", "./Sky",
 		"./KeyboardNavigationHandler", "./MouseNavigationHandler",
		"./VectorLayer", "./HEALPixLayer", "./OpenSearchLayer", "./TileWireframeLayer", // Layers
		"./AstroNavigation", "./FeatureStyle", "./Stats", // Others
		"./PointSpriteRenderer", "./ConvexPolygonRenderer"], // Renderers
	function(Globe, Sky,
		KeyboardNavigationHandler, MouseNavigationHandler,
		VectorLayer, HEALPixLayer, OpenSearchLayer, TileWireframeLayer,
		AstroNavigation, FeatureStyle, Stats) {

// Declare AstroWeb 
var AstroWeb = {};

AstroWeb.Sky = Sky;
AstroWeb.Globe = Globe;
AstroWeb.VectorLayer = VectorLayer;
AstroWeb.HEALPixLayer = HEALPixLayer;
AstroWeb.OpenSearchLayer = OpenSearchLayer;
AstroWeb.TileWireframeLayer = TileWireframeLayer;
AstroWeb.AstroNavigation = AstroNavigation;
AstroWeb.FeatureStyle = FeatureStyle;
AstroWeb.Stats = Stats;

AstroWeb.MouseNavigationHandler = MouseNavigationHandler;
AstroWeb.KeyboardNavigationHandler = KeyboardNavigationHandler;

window.AstroWeb = AstroWeb;

return AstroWeb;

});
require(["AstroWeb"]);
}());